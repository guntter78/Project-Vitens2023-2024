(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const g of s.addedNodes) g.tagName === "LINK" && g.rel === "modulepreload" && n(g) }).observe(document, { childList: !0, subtree: !0 }); function i(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function n(r) { if (r.ep) return; r.ep = !0; const s = i(r); fetch(r.href, s) } })(); var Ka = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function _o(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Za = { exports: {} }, ns = {}, Qa = { exports: {} }, Pe = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Gn = Symbol.for("react.element"), mc = Symbol.for("react.portal"), yc = Symbol.for("react.fragment"), xc = Symbol.for("react.strict_mode"), vc = Symbol.for("react.profiler"), Sc = Symbol.for("react.provider"), kc = Symbol.for("react.context"), wc = Symbol.for("react.forward_ref"), Cc = Symbol.for("react.suspense"), bc = Symbol.for("react.memo"), Mc = Symbol.for("react.lazy"), Il = Symbol.iterator; function Tc(e) { return e === null || typeof e != "object" ? null : (e = Il && e[Il] || e["@@iterator"], typeof e == "function" ? e : null) } var qa = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Ja = Object.assign, eh = {}; function nn(e, t, i) { this.props = e, this.context = t, this.refs = eh, this.updater = i || qa } nn.prototype.isReactComponent = {}; nn.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; nn.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function th() { } th.prototype = nn.prototype; function Ho(e, t, i) { this.props = e, this.context = t, this.refs = eh, this.updater = i || qa } var Uo = Ho.prototype = new th; Uo.constructor = Ho; Ja(Uo, nn.prototype); Uo.isPureReactComponent = !0; var Rl = Array.isArray, ih = Object.prototype.hasOwnProperty, Go = { current: null }, nh = { key: !0, ref: !0, __self: !0, __source: !0 }; function rh(e, t, i) { var n, r = {}, s = null, g = null; if (t != null) for (n in t.ref !== void 0 && (g = t.ref), t.key !== void 0 && (s = "" + t.key), t) ih.call(t, n) && !nh.hasOwnProperty(n) && (r[n] = t[n]); var j = arguments.length - 2; if (j === 1) r.children = i; else if (1 < j) { for (var D = Array(j), J = 0; J < j; J++)D[J] = arguments[J + 2]; r.children = D } if (e && e.defaultProps) for (n in j = e.defaultProps, j) r[n] === void 0 && (r[n] = j[n]); return { $$typeof: Gn, type: e, key: s, ref: g, props: r, _owner: Go.current } } function Pc(e, t) { return { $$typeof: Gn, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function Xo(e) { return typeof e == "object" && e !== null && e.$$typeof === Gn } function Ec(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (i) { return t[i] }) } var Bl = /\/+/g; function vs(e, t) { return typeof e == "object" && e !== null && e.key != null ? Ec("" + e.key) : t.toString(36) } function xr(e, t, i, n, r) { var s = typeof e; (s === "undefined" || s === "boolean") && (e = null); var g = !1; if (e === null) g = !0; else switch (s) { case "string": case "number": g = !0; break; case "object": switch (e.$$typeof) { case Gn: case mc: g = !0 } }if (g) return g = e, r = r(g), e = n === "" ? "." + vs(g, 0) : n, Rl(r) ? (i = "", e != null && (i = e.replace(Bl, "$&/") + "/"), xr(r, t, i, "", function (J) { return J })) : r != null && (Xo(r) && (r = Pc(r, i + (!r.key || g && g.key === r.key ? "" : ("" + r.key).replace(Bl, "$&/") + "/") + e)), t.push(r)), 1; if (g = 0, n = n === "" ? "." : n + ":", Rl(e)) for (var j = 0; j < e.length; j++) { s = e[j]; var D = n + vs(s, j); g += xr(s, t, i, D, r) } else if (D = Tc(e), typeof D == "function") for (e = D.call(e), j = 0; !(s = e.next()).done;)s = s.value, D = n + vs(s, j++), g += xr(s, t, i, D, r); else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return g } function er(e, t, i) { if (e == null) return e; var n = [], r = 0; return xr(e, n, "", "", function (s) { return t.call(i, s, r++) }), n } function Ac(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (i) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = i) }, function (i) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = i) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var rt = { current: null }, vr = { transition: null }, Lc = { ReactCurrentDispatcher: rt, ReactCurrentBatchConfig: vr, ReactCurrentOwner: Go }; Pe.Children = { map: er, forEach: function (e, t, i) { er(e, function () { t.apply(this, arguments) }, i) }, count: function (e) { var t = 0; return er(e, function () { t++ }), t }, toArray: function (e) { return er(e, function (t) { return t }) || [] }, only: function (e) { if (!Xo(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; Pe.Component = nn; Pe.Fragment = yc; Pe.Profiler = vc; Pe.PureComponent = Ho; Pe.StrictMode = xc; Pe.Suspense = Cc; Pe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Lc; Pe.cloneElement = function (e, t, i) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var n = Ja({}, e.props), r = e.key, s = e.ref, g = e._owner; if (t != null) { if (t.ref !== void 0 && (s = t.ref, g = Go.current), t.key !== void 0 && (r = "" + t.key), e.type && e.type.defaultProps) var j = e.type.defaultProps; for (D in t) ih.call(t, D) && !nh.hasOwnProperty(D) && (n[D] = t[D] === void 0 && j !== void 0 ? j[D] : t[D]) } var D = arguments.length - 2; if (D === 1) n.children = i; else if (1 < D) { j = Array(D); for (var J = 0; J < D; J++)j[J] = arguments[J + 2]; n.children = j } return { $$typeof: Gn, type: e.type, key: r, ref: s, props: n, _owner: g } }; Pe.createContext = function (e) { return e = { $$typeof: kc, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: Sc, _context: e }, e.Consumer = e }; Pe.createElement = rh; Pe.createFactory = function (e) { var t = rh.bind(null, e); return t.type = e, t }; Pe.createRef = function () { return { current: null } }; Pe.forwardRef = function (e) { return { $$typeof: wc, render: e } }; Pe.isValidElement = Xo; Pe.lazy = function (e) { return { $$typeof: Mc, _payload: { _status: -1, _result: e }, _init: Ac } }; Pe.memo = function (e, t) { return { $$typeof: bc, type: e, compare: t === void 0 ? null : t } }; Pe.startTransition = function (e) { var t = vr.transition; vr.transition = {}; try { e() } finally { vr.transition = t } }; Pe.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; Pe.useCallback = function (e, t) { return rt.current.useCallback(e, t) }; Pe.useContext = function (e) { return rt.current.useContext(e) }; Pe.useDebugValue = function () { }; Pe.useDeferredValue = function (e) { return rt.current.useDeferredValue(e) }; Pe.useEffect = function (e, t) { return rt.current.useEffect(e, t) }; Pe.useId = function () { return rt.current.useId() }; Pe.useImperativeHandle = function (e, t, i) { return rt.current.useImperativeHandle(e, t, i) }; Pe.useInsertionEffect = function (e, t) { return rt.current.useInsertionEffect(e, t) }; Pe.useLayoutEffect = function (e, t) { return rt.current.useLayoutEffect(e, t) }; Pe.useMemo = function (e, t) { return rt.current.useMemo(e, t) }; Pe.useReducer = function (e, t, i) { return rt.current.useReducer(e, t, i) }; Pe.useRef = function (e) { return rt.current.useRef(e) }; Pe.useState = function (e) { return rt.current.useState(e) }; Pe.useSyncExternalStore = function (e, t, i) { return rt.current.useSyncExternalStore(e, t, i) }; Pe.useTransition = function () { return rt.current.useTransition() }; Pe.version = "18.2.0"; Qa.exports = Pe; var We = Qa.exports; const Si = _o(We);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Oc = We, jc = Symbol.for("react.element"), Dc = Symbol.for("react.fragment"), Nc = Object.prototype.hasOwnProperty, zc = Oc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Ic = { key: !0, ref: !0, __self: !0, __source: !0 }; function sh(e, t, i) { var n, r = {}, s = null, g = null; i !== void 0 && (s = "" + i), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (g = t.ref); for (n in t) Nc.call(t, n) && !Ic.hasOwnProperty(n) && (r[n] = t[n]); if (e && e.defaultProps) for (n in t = e.defaultProps, t) r[n] === void 0 && (r[n] = t[n]); return { $$typeof: jc, type: e, key: s, ref: g, props: r, _owner: zc.current } } ns.Fragment = Dc; ns.jsx = sh; ns.jsxs = sh; Za.exports = ns; var ve = Za.exports, oh = { exports: {} }, yt = {}, lh = { exports: {} }, ah = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(h, d) { var m = h.length; h.push(d); e: for (; 0 < m;) { var p = m - 1 >>> 1, T = h[p]; if (0 < r(T, d)) h[p] = d, h[m] = T, m = p; else break e } } function i(h) { return h.length === 0 ? null : h[0] } function n(h) { if (h.length === 0) return null; var d = h[0], m = h.pop(); if (m !== d) { h[0] = m; e: for (var p = 0, T = h.length, U = T >>> 1; p < U;) { var ee = 2 * (p + 1) - 1, Z = h[ee], H = ee + 1, Y = h[H]; if (0 > r(Z, m)) H < T && 0 > r(Y, Z) ? (h[p] = Y, h[H] = m, p = H) : (h[p] = Z, h[ee] = m, p = ee); else if (H < T && 0 > r(Y, m)) h[p] = Y, h[H] = m, p = H; else break e } } return d } function r(h, d) { var m = h.sortIndex - d.sortIndex; return m !== 0 ? m : h.id - d.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; e.unstable_now = function () { return s.now() } } else { var g = Date, j = g.now(); e.unstable_now = function () { return g.now() - j } } var D = [], J = [], se = 1, $ = null, R = 3, Q = !1, E = !1, I = !1, W = typeof setTimeout == "function" ? setTimeout : null, y = typeof clearTimeout == "function" ? clearTimeout : null, a = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function v(h) { for (var d = i(J); d !== null;) { if (d.callback === null) n(J); else if (d.startTime <= h) n(J), d.sortIndex = d.expirationTime, t(D, d); else break; d = i(J) } } function k(h) { if (I = !1, v(h), !E) if (i(D) !== null) E = !0, u(w); else { var d = i(J); d !== null && l(k, d.startTime - h) } } function w(h, d) { E = !1, I && (I = !1, y(_), _ = -1), Q = !0; var m = R; try { for (v(d), $ = i(D); $ !== null && (!($.expirationTime > d) || h && !C());) { var p = $.callback; if (typeof p == "function") { $.callback = null, R = $.priorityLevel; var T = p($.expirationTime <= d); d = e.unstable_now(), typeof T == "function" ? $.callback = T : $ === i(D) && n(D), v(d) } else n(D); $ = i(D) } if ($ !== null) var U = !0; else { var ee = i(J); ee !== null && l(k, ee.startTime - d), U = !1 } return U } finally { $ = null, R = m, Q = !1 } } var L = !1, G = null, _ = -1, N = 5, F = -1; function C() { return !(e.unstable_now() - F < N) } function x() { if (G !== null) { var h = e.unstable_now(); F = h; var d = !0; try { d = G(!0, h) } finally { d ? P() : (L = !1, G = null) } } else L = !1 } var P; if (typeof a == "function") P = function () { a(x) }; else if (typeof MessageChannel < "u") { var f = new MessageChannel, o = f.port2; f.port1.onmessage = x, P = function () { o.postMessage(null) } } else P = function () { W(x, 0) }; function u(h) { G = h, L || (L = !0, P()) } function l(h, d) { _ = W(function () { h(e.unstable_now()) }, d) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (h) { h.callback = null }, e.unstable_continueExecution = function () { E || Q || (E = !0, u(w)) }, e.unstable_forceFrameRate = function (h) { 0 > h || 125 < h ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : N = 0 < h ? Math.floor(1e3 / h) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return R }, e.unstable_getFirstCallbackNode = function () { return i(D) }, e.unstable_next = function (h) { switch (R) { case 1: case 2: case 3: var d = 3; break; default: d = R }var m = R; R = d; try { return h() } finally { R = m } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (h, d) { switch (h) { case 1: case 2: case 3: case 4: case 5: break; default: h = 3 }var m = R; R = h; try { return d() } finally { R = m } }, e.unstable_scheduleCallback = function (h, d, m) { var p = e.unstable_now(); switch (typeof m == "object" && m !== null ? (m = m.delay, m = typeof m == "number" && 0 < m ? p + m : p) : m = p, h) { case 1: var T = -1; break; case 2: T = 250; break; case 5: T = 1073741823; break; case 4: T = 1e4; break; default: T = 5e3 }return T = m + T, h = { id: se++, callback: d, priorityLevel: h, startTime: m, expirationTime: T, sortIndex: -1 }, m > p ? (h.sortIndex = m, t(J, h), i(D) === null && h === i(J) && (I ? (y(_), _ = -1) : I = !0, l(k, m - p))) : (h.sortIndex = T, t(D, h), E || Q || (E = !0, u(w))), h }, e.unstable_shouldYield = C, e.unstable_wrapCallback = function (h) { var d = R; return function () { var m = R; R = d; try { return h.apply(this, arguments) } finally { R = m } } } })(ah); lh.exports = ah; var Rc = lh.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hh = We, mt = Rc; function xe(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, i = 1; i < arguments.length; i++)t += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var uh = new Set, Pn = {}; function Ei(e, t) { Ki(e, t), Ki(e + "Capture", t) } function Ki(e, t) { for (Pn[e] = t, e = 0; e < t.length; e++)uh.add(t[e]) } var Ut = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Ys = Object.prototype.hasOwnProperty, Bc = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Fl = {}, Wl = {}; function Fc(e) { return Ys.call(Wl, e) ? !0 : Ys.call(Fl, e) ? !1 : Bc.test(e) ? Wl[e] = !0 : (Fl[e] = !0, !1) } function Wc(e, t, i, n) { if (i !== null && i.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return n ? !1 : i !== null ? !i.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function _c(e, t, i, n) { if (t === null || typeof t > "u" || Wc(e, t, i, n)) return !0; if (n) return !1; if (i !== null) switch (i.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function st(e, t, i, n, r, s, g) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = n, this.attributeNamespace = r, this.mustUseProperty = i, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = g } var Qe = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Qe[e] = new st(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Qe[t] = new st(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Qe[e] = new st(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Qe[e] = new st(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Qe[e] = new st(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Qe[e] = new st(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Qe[e] = new st(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Qe[e] = new st(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Qe[e] = new st(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Yo = /[\-:]([a-z])/g; function Vo(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Yo, Vo); Qe[t] = new st(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Yo, Vo); Qe[t] = new st(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Yo, Vo); Qe[t] = new st(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Qe[e] = new st(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Qe.xlinkHref = new st("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Qe[e] = new st(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function $o(e, t, i, n) { var r = Qe.hasOwnProperty(t) ? Qe[t] : null; (r !== null ? r.type !== 0 : n || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (_c(t, i, r, n) && (i = null), n || r === null ? Fc(t) && (i === null ? e.removeAttribute(t) : e.setAttribute(t, "" + i)) : r.mustUseProperty ? e[r.propertyName] = i === null ? r.type === 3 ? !1 : "" : i : (t = r.attributeName, n = r.attributeNamespace, i === null ? e.removeAttribute(t) : (r = r.type, i = r === 3 || r === 4 && i === !0 ? "" : "" + i, n ? e.setAttributeNS(n, t, i) : e.setAttribute(t, i)))) } var Vt = hh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, tr = Symbol.for("react.element"), Oi = Symbol.for("react.portal"), ji = Symbol.for("react.fragment"), Ko = Symbol.for("react.strict_mode"), Vs = Symbol.for("react.profiler"), ch = Symbol.for("react.provider"), dh = Symbol.for("react.context"), Zo = Symbol.for("react.forward_ref"), $s = Symbol.for("react.suspense"), Ks = Symbol.for("react.suspense_list"), Qo = Symbol.for("react.memo"), Kt = Symbol.for("react.lazy"), ph = Symbol.for("react.offscreen"), _l = Symbol.iterator; function on(e) { return e === null || typeof e != "object" ? null : (e = _l && e[_l] || e["@@iterator"], typeof e == "function" ? e : null) } var Be = Object.assign, Ss; function fn(e) {
    if (Ss === void 0) try { throw Error() } catch (i) { var t = i.stack.trim().match(/\n( *(at )?)/); Ss = t && t[1] || "" } return `
`+ Ss + e
} var ks = !1; function ws(e, t) {
    if (!e || ks) return ""; ks = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (J) { var n = J } Reflect.construct(e, [], t) } else { try { t.call() } catch (J) { n = J } e.call(t.prototype) } else { try { throw Error() } catch (J) { n = J } e() } } catch (J) {
        if (J && n && typeof J.stack == "string") {
            for (var r = J.stack.split(`
`), s = n.stack.split(`
`), g = r.length - 1, j = s.length - 1; 1 <= g && 0 <= j && r[g] !== s[j];)j--; for (; 1 <= g && 0 <= j; g--, j--)if (r[g] !== s[j]) {
                if (g !== 1 || j !== 1) do if (g--, j--, 0 > j || r[g] !== s[j]) {
                    var D = `
`+ r[g].replace(" at new ", " at "); return e.displayName && D.includes("<anonymous>") && (D = D.replace("<anonymous>", e.displayName)), D
                } while (1 <= g && 0 <= j); break
            }
        }
    } finally { ks = !1, Error.prepareStackTrace = i } return (e = e ? e.displayName || e.name : "") ? fn(e) : ""
} function Hc(e) { switch (e.tag) { case 5: return fn(e.type); case 16: return fn("Lazy"); case 13: return fn("Suspense"); case 19: return fn("SuspenseList"); case 0: case 2: case 15: return e = ws(e.type, !1), e; case 11: return e = ws(e.type.render, !1), e; case 1: return e = ws(e.type, !0), e; default: return "" } } function Zs(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case ji: return "Fragment"; case Oi: return "Portal"; case Vs: return "Profiler"; case Ko: return "StrictMode"; case $s: return "Suspense"; case Ks: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case dh: return (e.displayName || "Context") + ".Consumer"; case ch: return (e._context.displayName || "Context") + ".Provider"; case Zo: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Qo: return t = e.displayName || null, t !== null ? t : Zs(e.type) || "Memo"; case Kt: t = e._payload, e = e._init; try { return Zs(e(t)) } catch { } }return null } function Uc(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Zs(t); case 8: return t === Ko ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function hi(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function fh(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Gc(e) { var t = fh(e) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), n = "" + e[t]; if (!e.hasOwnProperty(t) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var r = i.get, s = i.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return r.call(this) }, set: function (g) { n = "" + g, s.call(this, g) } }), Object.defineProperty(e, t, { enumerable: i.enumerable }), { getValue: function () { return n }, setValue: function (g) { n = "" + g }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function ir(e) { e._valueTracker || (e._valueTracker = Gc(e)) } function gh(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var i = t.getValue(), n = ""; return e && (n = fh(e) ? e.checked ? "true" : "false" : e.value), e = n, e !== i ? (t.setValue(e), !0) : !1 } function Lr(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Qs(e, t) { var i = t.checked; return Be({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? e._wrapperState.initialChecked }) } function Hl(e, t) { var i = t.defaultValue == null ? "" : t.defaultValue, n = t.checked != null ? t.checked : t.defaultChecked; i = hi(t.value != null ? t.value : i), e._wrapperState = { initialChecked: n, initialValue: i, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function mh(e, t) { t = t.checked, t != null && $o(e, "checked", t, !1) } function qs(e, t) { mh(e, t); var i = hi(t.value), n = t.type; if (i != null) n === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + i) : e.value !== "" + i && (e.value = "" + i); else if (n === "submit" || n === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Js(e, t.type, i) : t.hasOwnProperty("defaultValue") && Js(e, t.type, hi(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Ul(e, t, i) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var n = t.type; if (!(n !== "submit" && n !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, i || t === e.value || (e.value = t), e.defaultValue = t } i = e.name, i !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, i !== "" && (e.name = i) } function Js(e, t, i) { (t !== "number" || Lr(e.ownerDocument) !== e) && (i == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + i && (e.defaultValue = "" + i)) } var gn = Array.isArray; function Ui(e, t, i, n) { if (e = e.options, t) { t = {}; for (var r = 0; r < i.length; r++)t["$" + i[r]] = !0; for (i = 0; i < e.length; i++)r = t.hasOwnProperty("$" + e[i].value), e[i].selected !== r && (e[i].selected = r), r && n && (e[i].defaultSelected = !0) } else { for (i = "" + hi(i), t = null, r = 0; r < e.length; r++) { if (e[r].value === i) { e[r].selected = !0, n && (e[r].defaultSelected = !0); return } t !== null || e[r].disabled || (t = e[r]) } t !== null && (t.selected = !0) } } function eo(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(xe(91)); return Be({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Gl(e, t) { var i = t.value; if (i == null) { if (i = t.children, t = t.defaultValue, i != null) { if (t != null) throw Error(xe(92)); if (gn(i)) { if (1 < i.length) throw Error(xe(93)); i = i[0] } t = i } t == null && (t = ""), i = t } e._wrapperState = { initialValue: hi(i) } } function yh(e, t) { var i = hi(t.value), n = hi(t.defaultValue); i != null && (i = "" + i, i !== e.value && (e.value = i), t.defaultValue == null && e.defaultValue !== i && (e.defaultValue = i)), n != null && (e.defaultValue = "" + n) } function Xl(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function xh(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function to(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? xh(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var nr, vh = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, i, n, r) { MSApp.execUnsafeLocalFunction(function () { return e(t, i, n, r) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (nr = nr || document.createElement("div"), nr.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = nr.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function En(e, t) { if (t) { var i = e.firstChild; if (i && i === e.lastChild && i.nodeType === 3) { i.nodeValue = t; return } } e.textContent = t } var xn = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Xc = ["Webkit", "ms", "Moz", "O"]; Object.keys(xn).forEach(function (e) { Xc.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), xn[t] = xn[e] }) }); function Sh(e, t, i) { return t == null || typeof t == "boolean" || t === "" ? "" : i || typeof t != "number" || t === 0 || xn.hasOwnProperty(e) && xn[e] ? ("" + t).trim() : t + "px" } function kh(e, t) { e = e.style; for (var i in t) if (t.hasOwnProperty(i)) { var n = i.indexOf("--") === 0, r = Sh(i, t[i], n); i === "float" && (i = "cssFloat"), n ? e.setProperty(i, r) : e[i] = r } } var Yc = Be({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function io(e, t) { if (t) { if (Yc[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(xe(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(xe(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(xe(61)) } if (t.style != null && typeof t.style != "object") throw Error(xe(62)) } } function no(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var ro = null; function qo(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var so = null, Gi = null, Xi = null; function Yl(e) { if (e = Vn(e)) { if (typeof so != "function") throw Error(xe(280)); var t = e.stateNode; t && (t = as(t), so(e.stateNode, e.type, t)) } } function wh(e) { Gi ? Xi ? Xi.push(e) : Xi = [e] : Gi = e } function Ch() { if (Gi) { var e = Gi, t = Xi; if (Xi = Gi = null, Yl(e), t) for (e = 0; e < t.length; e++)Yl(t[e]) } } function bh(e, t) { return e(t) } function Mh() { } var Cs = !1; function Th(e, t, i) { if (Cs) return e(t, i); Cs = !0; try { return bh(e, t, i) } finally { Cs = !1, (Gi !== null || Xi !== null) && (Mh(), Ch()) } } function An(e, t) { var i = e.stateNode; if (i === null) return null; var n = as(i); if (n === null) return null; i = n[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (n = !n.disabled) || (e = e.type, n = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !n; break e; default: e = !1 }if (e) return null; if (i && typeof i != "function") throw Error(xe(231, t, typeof i)); return i } var oo = !1; if (Ut) try { var ln = {}; Object.defineProperty(ln, "passive", { get: function () { oo = !0 } }), window.addEventListener("test", ln, ln), window.removeEventListener("test", ln, ln) } catch { oo = !1 } function Vc(e, t, i, n, r, s, g, j, D) { var J = Array.prototype.slice.call(arguments, 3); try { t.apply(i, J) } catch (se) { this.onError(se) } } var vn = !1, Or = null, jr = !1, lo = null, $c = { onError: function (e) { vn = !0, Or = e } }; function Kc(e, t, i, n, r, s, g, j, D) { vn = !1, Or = null, Vc.apply($c, arguments) } function Zc(e, t, i, n, r, s, g, j, D) { if (Kc.apply(this, arguments), vn) { if (vn) { var J = Or; vn = !1, Or = null } else throw Error(xe(198)); jr || (jr = !0, lo = J) } } function Ai(e) { var t = e, i = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (i = t.return), e = t.return; while (e) } return t.tag === 3 ? i : null } function Ph(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Vl(e) { if (Ai(e) !== e) throw Error(xe(188)) } function Qc(e) { var t = e.alternate; if (!t) { if (t = Ai(e), t === null) throw Error(xe(188)); return t !== e ? null : e } for (var i = e, n = t; ;) { var r = i.return; if (r === null) break; var s = r.alternate; if (s === null) { if (n = r.return, n !== null) { i = n; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === i) return Vl(r), e; if (s === n) return Vl(r), t; s = s.sibling } throw Error(xe(188)) } if (i.return !== n.return) i = r, n = s; else { for (var g = !1, j = r.child; j;) { if (j === i) { g = !0, i = r, n = s; break } if (j === n) { g = !0, n = r, i = s; break } j = j.sibling } if (!g) { for (j = s.child; j;) { if (j === i) { g = !0, i = s, n = r; break } if (j === n) { g = !0, n = s, i = r; break } j = j.sibling } if (!g) throw Error(xe(189)) } } if (i.alternate !== n) throw Error(xe(190)) } if (i.tag !== 3) throw Error(xe(188)); return i.stateNode.current === i ? e : t } function Eh(e) { return e = Qc(e), e !== null ? Ah(e) : null } function Ah(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Ah(e); if (t !== null) return t; e = e.sibling } return null } var Lh = mt.unstable_scheduleCallback, $l = mt.unstable_cancelCallback, qc = mt.unstable_shouldYield, Jc = mt.unstable_requestPaint, _e = mt.unstable_now, ed = mt.unstable_getCurrentPriorityLevel, Jo = mt.unstable_ImmediatePriority, Oh = mt.unstable_UserBlockingPriority, Dr = mt.unstable_NormalPriority, td = mt.unstable_LowPriority, jh = mt.unstable_IdlePriority, rs = null, It = null; function id(e) { if (It && typeof It.onCommitFiberRoot == "function") try { It.onCommitFiberRoot(rs, e, void 0, (e.current.flags & 128) === 128) } catch { } } var At = Math.clz32 ? Math.clz32 : sd, nd = Math.log, rd = Math.LN2; function sd(e) { return e >>>= 0, e === 0 ? 32 : 31 - (nd(e) / rd | 0) | 0 } var rr = 64, sr = 4194304; function mn(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Nr(e, t) { var i = e.pendingLanes; if (i === 0) return 0; var n = 0, r = e.suspendedLanes, s = e.pingedLanes, g = i & 268435455; if (g !== 0) { var j = g & ~r; j !== 0 ? n = mn(j) : (s &= g, s !== 0 && (n = mn(s))) } else g = i & ~r, g !== 0 ? n = mn(g) : s !== 0 && (n = mn(s)); if (n === 0) return 0; if (t !== 0 && t !== n && !(t & r) && (r = n & -n, s = t & -t, r >= s || r === 16 && (s & 4194240) !== 0)) return t; if (n & 4 && (n |= i & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= n; 0 < t;)i = 31 - At(t), r = 1 << i, n |= e[i], t &= ~r; return n } function od(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function ld(e, t) { for (var i = e.suspendedLanes, n = e.pingedLanes, r = e.expirationTimes, s = e.pendingLanes; 0 < s;) { var g = 31 - At(s), j = 1 << g, D = r[g]; D === -1 ? (!(j & i) || j & n) && (r[g] = od(j, t)) : D <= t && (e.expiredLanes |= j), s &= ~j } } function ao(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Dh() { var e = rr; return rr <<= 1, !(rr & 4194240) && (rr = 64), e } function bs(e) { for (var t = [], i = 0; 31 > i; i++)t.push(e); return t } function Xn(e, t, i) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - At(t), e[t] = i } function ad(e, t) { var i = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var n = e.eventTimes; for (e = e.expirationTimes; 0 < i;) { var r = 31 - At(i), s = 1 << r; t[r] = 0, n[r] = -1, e[r] = -1, i &= ~s } } function el(e, t) { var i = e.entangledLanes |= t; for (e = e.entanglements; i;) { var n = 31 - At(i), r = 1 << n; r & t | e[n] & t && (e[n] |= t), i &= ~r } } var Le = 0; function Nh(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var zh, tl, Ih, Rh, Bh, ho = !1, or = [], ti = null, ii = null, ni = null, Ln = new Map, On = new Map, Qt = [], hd = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Kl(e, t) { switch (e) { case "focusin": case "focusout": ti = null; break; case "dragenter": case "dragleave": ii = null; break; case "mouseover": case "mouseout": ni = null; break; case "pointerover": case "pointerout": Ln.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": On.delete(t.pointerId) } } function an(e, t, i, n, r, s) { return e === null || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: i, eventSystemFlags: n, nativeEvent: s, targetContainers: [r] }, t !== null && (t = Vn(t), t !== null && tl(t)), e) : (e.eventSystemFlags |= n, t = e.targetContainers, r !== null && t.indexOf(r) === -1 && t.push(r), e) } function ud(e, t, i, n, r) { switch (t) { case "focusin": return ti = an(ti, e, t, i, n, r), !0; case "dragenter": return ii = an(ii, e, t, i, n, r), !0; case "mouseover": return ni = an(ni, e, t, i, n, r), !0; case "pointerover": var s = r.pointerId; return Ln.set(s, an(Ln.get(s) || null, e, t, i, n, r)), !0; case "gotpointercapture": return s = r.pointerId, On.set(s, an(On.get(s) || null, e, t, i, n, r)), !0 }return !1 } function Fh(e) { var t = yi(e.target); if (t !== null) { var i = Ai(t); if (i !== null) { if (t = i.tag, t === 13) { if (t = Ph(i), t !== null) { e.blockedOn = t, Bh(e.priority, function () { Ih(i) }); return } } else if (t === 3 && i.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Sr(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var i = uo(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (i === null) { i = e.nativeEvent; var n = new i.constructor(i.type, i); ro = n, i.target.dispatchEvent(n), ro = null } else return t = Vn(i), t !== null && tl(t), e.blockedOn = i, !1; t.shift() } return !0 } function Zl(e, t, i) { Sr(e) && i.delete(t) } function cd() { ho = !1, ti !== null && Sr(ti) && (ti = null), ii !== null && Sr(ii) && (ii = null), ni !== null && Sr(ni) && (ni = null), Ln.forEach(Zl), On.forEach(Zl) } function hn(e, t) { e.blockedOn === t && (e.blockedOn = null, ho || (ho = !0, mt.unstable_scheduleCallback(mt.unstable_NormalPriority, cd))) } function jn(e) { function t(r) { return hn(r, e) } if (0 < or.length) { hn(or[0], e); for (var i = 1; i < or.length; i++) { var n = or[i]; n.blockedOn === e && (n.blockedOn = null) } } for (ti !== null && hn(ti, e), ii !== null && hn(ii, e), ni !== null && hn(ni, e), Ln.forEach(t), On.forEach(t), i = 0; i < Qt.length; i++)n = Qt[i], n.blockedOn === e && (n.blockedOn = null); for (; 0 < Qt.length && (i = Qt[0], i.blockedOn === null);)Fh(i), i.blockedOn === null && Qt.shift() } var Yi = Vt.ReactCurrentBatchConfig, zr = !0; function dd(e, t, i, n) { var r = Le, s = Yi.transition; Yi.transition = null; try { Le = 1, il(e, t, i, n) } finally { Le = r, Yi.transition = s } } function pd(e, t, i, n) { var r = Le, s = Yi.transition; Yi.transition = null; try { Le = 4, il(e, t, i, n) } finally { Le = r, Yi.transition = s } } function il(e, t, i, n) { if (zr) { var r = uo(e, t, i, n); if (r === null) Ns(e, t, n, Ir, i), Kl(e, n); else if (ud(r, e, t, i, n)) n.stopPropagation(); else if (Kl(e, n), t & 4 && -1 < hd.indexOf(e)) { for (; r !== null;) { var s = Vn(r); if (s !== null && zh(s), s = uo(e, t, i, n), s === null && Ns(e, t, n, Ir, i), s === r) break; r = s } r !== null && n.stopPropagation() } else Ns(e, t, n, null, i) } } var Ir = null; function uo(e, t, i, n) { if (Ir = null, e = qo(n), e = yi(e), e !== null) if (t = Ai(e), t === null) e = null; else if (i = t.tag, i === 13) { if (e = Ph(t), e !== null) return e; e = null } else if (i === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Ir = e, null } function Wh(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (ed()) { case Jo: return 1; case Oh: return 4; case Dr: case td: return 16; case jh: return 536870912; default: return 16 }default: return 16 } } var Jt = null, nl = null, kr = null; function _h() { if (kr) return kr; var e, t = nl, i = t.length, n, r = "value" in Jt ? Jt.value : Jt.textContent, s = r.length; for (e = 0; e < i && t[e] === r[e]; e++); var g = i - e; for (n = 1; n <= g && t[i - n] === r[s - n]; n++); return kr = r.slice(e, 1 < n ? 1 - n : void 0) } function wr(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function lr() { return !0 } function Ql() { return !1 } function xt(e) { function t(i, n, r, s, g) { this._reactName = i, this._targetInst = r, this.type = n, this.nativeEvent = s, this.target = g, this.currentTarget = null; for (var j in e) e.hasOwnProperty(j) && (i = e[j], this[j] = i ? i(s) : s[j]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? lr : Ql, this.isPropagationStopped = Ql, this } return Be(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = lr) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = lr) }, persist: function () { }, isPersistent: lr }), t } var rn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, rl = xt(rn), Yn = Be({}, rn, { view: 0, detail: 0 }), fd = xt(Yn), Ms, Ts, un, ss = Be({}, Yn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: sl, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== un && (un && e.type === "mousemove" ? (Ms = e.screenX - un.screenX, Ts = e.screenY - un.screenY) : Ts = Ms = 0, un = e), Ms) }, movementY: function (e) { return "movementY" in e ? e.movementY : Ts } }), ql = xt(ss), gd = Be({}, ss, { dataTransfer: 0 }), md = xt(gd), yd = Be({}, Yn, { relatedTarget: 0 }), Ps = xt(yd), xd = Be({}, rn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), vd = xt(xd), Sd = Be({}, rn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), kd = xt(Sd), wd = Be({}, rn, { data: 0 }), Jl = xt(wd), Cd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, bd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Md = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Td(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Md[e]) ? !!t[e] : !1 } function sl() { return Td } var Pd = Be({}, Yn, { key: function (e) { if (e.key) { var t = Cd[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = wr(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? bd[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: sl, charCode: function (e) { return e.type === "keypress" ? wr(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? wr(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Ed = xt(Pd), Ad = Be({}, ss, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), ea = xt(Ad), Ld = Be({}, Yn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: sl }), Od = xt(Ld), jd = Be({}, rn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Dd = xt(jd), Nd = Be({}, ss, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), zd = xt(Nd), Id = [9, 13, 27, 32], ol = Ut && "CompositionEvent" in window, Sn = null; Ut && "documentMode" in document && (Sn = document.documentMode); var Rd = Ut && "TextEvent" in window && !Sn, Hh = Ut && (!ol || Sn && 8 < Sn && 11 >= Sn), ta = " ", ia = !1; function Uh(e, t) { switch (e) { case "keyup": return Id.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Gh(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Di = !1; function Bd(e, t) { switch (e) { case "compositionend": return Gh(t); case "keypress": return t.which !== 32 ? null : (ia = !0, ta); case "textInput": return e = t.data, e === ta && ia ? null : e; default: return null } } function Fd(e, t) { if (Di) return e === "compositionend" || !ol && Uh(e, t) ? (e = _h(), kr = nl = Jt = null, Di = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Hh && t.locale !== "ko" ? null : t.data; default: return null } } var Wd = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function na(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!Wd[e.type] : t === "textarea" } function Xh(e, t, i, n) { wh(n), t = Rr(t, "onChange"), 0 < t.length && (i = new rl("onChange", "change", null, i, n), e.push({ event: i, listeners: t })) } var kn = null, Dn = null; function _d(e) { iu(e, 0) } function os(e) { var t = Ii(e); if (gh(t)) return e } function Hd(e, t) { if (e === "change") return t } var Yh = !1; if (Ut) { var Es; if (Ut) { var As = "oninput" in document; if (!As) { var ra = document.createElement("div"); ra.setAttribute("oninput", "return;"), As = typeof ra.oninput == "function" } Es = As } else Es = !1; Yh = Es && (!document.documentMode || 9 < document.documentMode) } function sa() { kn && (kn.detachEvent("onpropertychange", Vh), Dn = kn = null) } function Vh(e) { if (e.propertyName === "value" && os(Dn)) { var t = []; Xh(t, Dn, e, qo(e)), Th(_d, t) } } function Ud(e, t, i) { e === "focusin" ? (sa(), kn = t, Dn = i, kn.attachEvent("onpropertychange", Vh)) : e === "focusout" && sa() } function Gd(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return os(Dn) } function Xd(e, t) { if (e === "click") return os(t) } function Yd(e, t) { if (e === "input" || e === "change") return os(t) } function Vd(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Ot = typeof Object.is == "function" ? Object.is : Vd; function Nn(e, t) { if (Ot(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var i = Object.keys(e), n = Object.keys(t); if (i.length !== n.length) return !1; for (n = 0; n < i.length; n++) { var r = i[n]; if (!Ys.call(t, r) || !Ot(e[r], t[r])) return !1 } return !0 } function oa(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function la(e, t) { var i = oa(e); e = 0; for (var n; i;) { if (i.nodeType === 3) { if (n = e + i.textContent.length, e <= t && n >= t) return { node: i, offset: t - e }; e = n } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = oa(i) } } function $h(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? $h(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Kh() { for (var e = window, t = Lr(); t instanceof e.HTMLIFrameElement;) { try { var i = typeof t.contentWindow.location.href == "string" } catch { i = !1 } if (i) e = t.contentWindow; else break; t = Lr(e.document) } return t } function ll(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function $d(e) { var t = Kh(), i = e.focusedElem, n = e.selectionRange; if (t !== i && i && i.ownerDocument && $h(i.ownerDocument.documentElement, i)) { if (n !== null && ll(i)) { if (t = n.start, e = n.end, e === void 0 && (e = t), "selectionStart" in i) i.selectionStart = t, i.selectionEnd = Math.min(e, i.value.length); else if (e = (t = i.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var r = i.textContent.length, s = Math.min(n.start, r); n = n.end === void 0 ? s : Math.min(n.end, r), !e.extend && s > n && (r = n, n = s, s = r), r = la(i, s); var g = la(i, n); r && g && (e.rangeCount !== 1 || e.anchorNode !== r.node || e.anchorOffset !== r.offset || e.focusNode !== g.node || e.focusOffset !== g.offset) && (t = t.createRange(), t.setStart(r.node, r.offset), e.removeAllRanges(), s > n ? (e.addRange(t), e.extend(g.node, g.offset)) : (t.setEnd(g.node, g.offset), e.addRange(t))) } } for (t = [], e = i; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < t.length; i++)e = t[i], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Kd = Ut && "documentMode" in document && 11 >= document.documentMode, Ni = null, co = null, wn = null, po = !1; function aa(e, t, i) { var n = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; po || Ni == null || Ni !== Lr(n) || (n = Ni, "selectionStart" in n && ll(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = { anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset }), wn && Nn(wn, n) || (wn = n, n = Rr(co, "onSelect"), 0 < n.length && (t = new rl("onSelect", "select", null, t, i), e.push({ event: t, listeners: n }), t.target = Ni))) } function ar(e, t) { var i = {}; return i[e.toLowerCase()] = t.toLowerCase(), i["Webkit" + e] = "webkit" + t, i["Moz" + e] = "moz" + t, i } var zi = { animationend: ar("Animation", "AnimationEnd"), animationiteration: ar("Animation", "AnimationIteration"), animationstart: ar("Animation", "AnimationStart"), transitionend: ar("Transition", "TransitionEnd") }, Ls = {}, Zh = {}; Ut && (Zh = document.createElement("div").style, "AnimationEvent" in window || (delete zi.animationend.animation, delete zi.animationiteration.animation, delete zi.animationstart.animation), "TransitionEvent" in window || delete zi.transitionend.transition); function ls(e) { if (Ls[e]) return Ls[e]; if (!zi[e]) return e; var t = zi[e], i; for (i in t) if (t.hasOwnProperty(i) && i in Zh) return Ls[e] = t[i]; return e } var Qh = ls("animationend"), qh = ls("animationiteration"), Jh = ls("animationstart"), eu = ls("transitionend"), tu = new Map, ha = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ci(e, t) { tu.set(e, t), Ei(t, [e]) } for (var Os = 0; Os < ha.length; Os++) { var js = ha[Os], Zd = js.toLowerCase(), Qd = js[0].toUpperCase() + js.slice(1); ci(Zd, "on" + Qd) } ci(Qh, "onAnimationEnd"); ci(qh, "onAnimationIteration"); ci(Jh, "onAnimationStart"); ci("dblclick", "onDoubleClick"); ci("focusin", "onFocus"); ci("focusout", "onBlur"); ci(eu, "onTransitionEnd"); Ki("onMouseEnter", ["mouseout", "mouseover"]); Ki("onMouseLeave", ["mouseout", "mouseover"]); Ki("onPointerEnter", ["pointerout", "pointerover"]); Ki("onPointerLeave", ["pointerout", "pointerover"]); Ei("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Ei("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Ei("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Ei("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Ei("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Ei("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var yn = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), qd = new Set("cancel close invalid load scroll toggle".split(" ").concat(yn)); function ua(e, t, i) { var n = e.type || "unknown-event"; e.currentTarget = i, Zc(n, t, void 0, e), e.currentTarget = null } function iu(e, t) { t = (t & 4) !== 0; for (var i = 0; i < e.length; i++) { var n = e[i], r = n.event; n = n.listeners; e: { var s = void 0; if (t) for (var g = n.length - 1; 0 <= g; g--) { var j = n[g], D = j.instance, J = j.currentTarget; if (j = j.listener, D !== s && r.isPropagationStopped()) break e; ua(r, j, J), s = D } else for (g = 0; g < n.length; g++) { if (j = n[g], D = j.instance, J = j.currentTarget, j = j.listener, D !== s && r.isPropagationStopped()) break e; ua(r, j, J), s = D } } } if (jr) throw e = lo, jr = !1, lo = null, e } function De(e, t) { var i = t[xo]; i === void 0 && (i = t[xo] = new Set); var n = e + "__bubble"; i.has(n) || (nu(t, e, 2, !1), i.add(n)) } function Ds(e, t, i) { var n = 0; t && (n |= 4), nu(i, e, n, t) } var hr = "_reactListening" + Math.random().toString(36).slice(2); function zn(e) { if (!e[hr]) { e[hr] = !0, uh.forEach(function (i) { i !== "selectionchange" && (qd.has(i) || Ds(i, !1, e), Ds(i, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[hr] || (t[hr] = !0, Ds("selectionchange", !1, t)) } } function nu(e, t, i, n) { switch (Wh(t)) { case 1: var r = dd; break; case 4: r = pd; break; default: r = il }i = r.bind(null, t, i, e), r = void 0, !oo || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (r = !0), n ? r !== void 0 ? e.addEventListener(t, i, { capture: !0, passive: r }) : e.addEventListener(t, i, !0) : r !== void 0 ? e.addEventListener(t, i, { passive: r }) : e.addEventListener(t, i, !1) } function Ns(e, t, i, n, r) { var s = n; if (!(t & 1) && !(t & 2) && n !== null) e: for (; ;) { if (n === null) return; var g = n.tag; if (g === 3 || g === 4) { var j = n.stateNode.containerInfo; if (j === r || j.nodeType === 8 && j.parentNode === r) break; if (g === 4) for (g = n.return; g !== null;) { var D = g.tag; if ((D === 3 || D === 4) && (D = g.stateNode.containerInfo, D === r || D.nodeType === 8 && D.parentNode === r)) return; g = g.return } for (; j !== null;) { if (g = yi(j), g === null) return; if (D = g.tag, D === 5 || D === 6) { n = s = g; continue e } j = j.parentNode } } n = n.return } Th(function () { var J = s, se = qo(i), $ = []; e: { var R = tu.get(e); if (R !== void 0) { var Q = rl, E = e; switch (e) { case "keypress": if (wr(i) === 0) break e; case "keydown": case "keyup": Q = Ed; break; case "focusin": E = "focus", Q = Ps; break; case "focusout": E = "blur", Q = Ps; break; case "beforeblur": case "afterblur": Q = Ps; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Q = ql; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Q = md; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Q = Od; break; case Qh: case qh: case Jh: Q = vd; break; case eu: Q = Dd; break; case "scroll": Q = fd; break; case "wheel": Q = zd; break; case "copy": case "cut": case "paste": Q = kd; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Q = ea }var I = (t & 4) !== 0, W = !I && e === "scroll", y = I ? R !== null ? R + "Capture" : null : R; I = []; for (var a = J, v; a !== null;) { v = a; var k = v.stateNode; if (v.tag === 5 && k !== null && (v = k, y !== null && (k = An(a, y), k != null && I.push(In(a, k, v)))), W) break; a = a.return } 0 < I.length && (R = new Q(R, E, null, i, se), $.push({ event: R, listeners: I })) } } if (!(t & 7)) { e: { if (R = e === "mouseover" || e === "pointerover", Q = e === "mouseout" || e === "pointerout", R && i !== ro && (E = i.relatedTarget || i.fromElement) && (yi(E) || E[Gt])) break e; if ((Q || R) && (R = se.window === se ? se : (R = se.ownerDocument) ? R.defaultView || R.parentWindow : window, Q ? (E = i.relatedTarget || i.toElement, Q = J, E = E ? yi(E) : null, E !== null && (W = Ai(E), E !== W || E.tag !== 5 && E.tag !== 6) && (E = null)) : (Q = null, E = J), Q !== E)) { if (I = ql, k = "onMouseLeave", y = "onMouseEnter", a = "mouse", (e === "pointerout" || e === "pointerover") && (I = ea, k = "onPointerLeave", y = "onPointerEnter", a = "pointer"), W = Q == null ? R : Ii(Q), v = E == null ? R : Ii(E), R = new I(k, a + "leave", Q, i, se), R.target = W, R.relatedTarget = v, k = null, yi(se) === J && (I = new I(y, a + "enter", E, i, se), I.target = v, I.relatedTarget = W, k = I), W = k, Q && E) t: { for (I = Q, y = E, a = 0, v = I; v; v = Li(v))a++; for (v = 0, k = y; k; k = Li(k))v++; for (; 0 < a - v;)I = Li(I), a--; for (; 0 < v - a;)y = Li(y), v--; for (; a--;) { if (I === y || y !== null && I === y.alternate) break t; I = Li(I), y = Li(y) } I = null } else I = null; Q !== null && ca($, R, Q, I, !1), E !== null && W !== null && ca($, W, E, I, !0) } } e: { if (R = J ? Ii(J) : window, Q = R.nodeName && R.nodeName.toLowerCase(), Q === "select" || Q === "input" && R.type === "file") var w = Hd; else if (na(R)) if (Yh) w = Yd; else { w = Gd; var L = Ud } else (Q = R.nodeName) && Q.toLowerCase() === "input" && (R.type === "checkbox" || R.type === "radio") && (w = Xd); if (w && (w = w(e, J))) { Xh($, w, i, se); break e } L && L(e, R, J), e === "focusout" && (L = R._wrapperState) && L.controlled && R.type === "number" && Js(R, "number", R.value) } switch (L = J ? Ii(J) : window, e) { case "focusin": (na(L) || L.contentEditable === "true") && (Ni = L, co = J, wn = null); break; case "focusout": wn = co = Ni = null; break; case "mousedown": po = !0; break; case "contextmenu": case "mouseup": case "dragend": po = !1, aa($, i, se); break; case "selectionchange": if (Kd) break; case "keydown": case "keyup": aa($, i, se) }var G; if (ol) e: { switch (e) { case "compositionstart": var _ = "onCompositionStart"; break e; case "compositionend": _ = "onCompositionEnd"; break e; case "compositionupdate": _ = "onCompositionUpdate"; break e }_ = void 0 } else Di ? Uh(e, i) && (_ = "onCompositionEnd") : e === "keydown" && i.keyCode === 229 && (_ = "onCompositionStart"); _ && (Hh && i.locale !== "ko" && (Di || _ !== "onCompositionStart" ? _ === "onCompositionEnd" && Di && (G = _h()) : (Jt = se, nl = "value" in Jt ? Jt.value : Jt.textContent, Di = !0)), L = Rr(J, _), 0 < L.length && (_ = new Jl(_, e, null, i, se), $.push({ event: _, listeners: L }), G ? _.data = G : (G = Gh(i), G !== null && (_.data = G)))), (G = Rd ? Bd(e, i) : Fd(e, i)) && (J = Rr(J, "onBeforeInput"), 0 < J.length && (se = new Jl("onBeforeInput", "beforeinput", null, i, se), $.push({ event: se, listeners: J }), se.data = G)) } iu($, t) }) } function In(e, t, i) { return { instance: e, listener: t, currentTarget: i } } function Rr(e, t) { for (var i = t + "Capture", n = []; e !== null;) { var r = e, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = An(e, i), s != null && n.unshift(In(e, s, r)), s = An(e, t), s != null && n.push(In(e, s, r))), e = e.return } return n } function Li(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function ca(e, t, i, n, r) { for (var s = t._reactName, g = []; i !== null && i !== n;) { var j = i, D = j.alternate, J = j.stateNode; if (D !== null && D === n) break; j.tag === 5 && J !== null && (j = J, r ? (D = An(i, s), D != null && g.unshift(In(i, D, j))) : r || (D = An(i, s), D != null && g.push(In(i, D, j)))), i = i.return } g.length !== 0 && e.push({ event: t, listeners: g }) } var Jd = /\r\n?/g, ep = /\u0000|\uFFFD/g; function da(e) {
    return (typeof e == "string" ? e : "" + e).replace(Jd, `
`).replace(ep, "")
} function ur(e, t, i) { if (t = da(t), da(e) !== t && i) throw Error(xe(425)) } function Br() { } var fo = null, go = null; function mo(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var yo = typeof setTimeout == "function" ? setTimeout : void 0, tp = typeof clearTimeout == "function" ? clearTimeout : void 0, pa = typeof Promise == "function" ? Promise : void 0, ip = typeof queueMicrotask == "function" ? queueMicrotask : typeof pa < "u" ? function (e) { return pa.resolve(null).then(e).catch(np) } : yo; function np(e) { setTimeout(function () { throw e }) } function zs(e, t) { var i = t, n = 0; do { var r = i.nextSibling; if (e.removeChild(i), r && r.nodeType === 8) if (i = r.data, i === "/$") { if (n === 0) { e.removeChild(r), jn(t); return } n-- } else i !== "$" && i !== "$?" && i !== "$!" || n++; i = r } while (i); jn(t) } function ri(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function fa(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "$" || i === "$!" || i === "$?") { if (t === 0) return e; t-- } else i === "/$" && t++ } e = e.previousSibling } return null } var sn = Math.random().toString(36).slice(2), zt = "__reactFiber$" + sn, Rn = "__reactProps$" + sn, Gt = "__reactContainer$" + sn, xo = "__reactEvents$" + sn, rp = "__reactListeners$" + sn, sp = "__reactHandles$" + sn; function yi(e) { var t = e[zt]; if (t) return t; for (var i = e.parentNode; i;) { if (t = i[Gt] || i[zt]) { if (i = t.alternate, t.child !== null || i !== null && i.child !== null) for (e = fa(e); e !== null;) { if (i = e[zt]) return i; e = fa(e) } return t } e = i, i = e.parentNode } return null } function Vn(e) { return e = e[zt] || e[Gt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Ii(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(xe(33)) } function as(e) { return e[Rn] || null } var vo = [], Ri = -1; function di(e) { return { current: e } } function Ne(e) { 0 > Ri || (e.current = vo[Ri], vo[Ri] = null, Ri--) } function Oe(e, t) { Ri++, vo[Ri] = e.current, e.current = t } var ui = {}, tt = di(ui), at = di(!1), Ci = ui; function Zi(e, t) { var i = e.type.contextTypes; if (!i) return ui; var n = e.stateNode; if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in i) r[s] = t[s]; return n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = r), r } function ht(e) { return e = e.childContextTypes, e != null } function Fr() { Ne(at), Ne(tt) } function ga(e, t, i) { if (tt.current !== ui) throw Error(xe(168)); Oe(tt, t), Oe(at, i) } function ru(e, t, i) { var n = e.stateNode; if (t = t.childContextTypes, typeof n.getChildContext != "function") return i; n = n.getChildContext(); for (var r in n) if (!(r in t)) throw Error(xe(108, Uc(e) || "Unknown", r)); return Be({}, i, n) } function Wr(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ui, Ci = tt.current, Oe(tt, e), Oe(at, at.current), !0 } function ma(e, t, i) { var n = e.stateNode; if (!n) throw Error(xe(169)); i ? (e = ru(e, t, Ci), n.__reactInternalMemoizedMergedChildContext = e, Ne(at), Ne(tt), Oe(tt, e)) : Ne(at), Oe(at, i) } var Ft = null, hs = !1, Is = !1; function su(e) { Ft === null ? Ft = [e] : Ft.push(e) } function op(e) { hs = !0, su(e) } function pi() { if (!Is && Ft !== null) { Is = !0; var e = 0, t = Le; try { var i = Ft; for (Le = 1; e < i.length; e++) { var n = i[e]; do n = n(!0); while (n !== null) } Ft = null, hs = !1 } catch (r) { throw Ft !== null && (Ft = Ft.slice(e + 1)), Lh(Jo, pi), r } finally { Le = t, Is = !1 } } return null } var Bi = [], Fi = 0, _r = null, Hr = 0, vt = [], St = 0, bi = null, Wt = 1, _t = ""; function gi(e, t) { Bi[Fi++] = Hr, Bi[Fi++] = _r, _r = e, Hr = t } function ou(e, t, i) { vt[St++] = Wt, vt[St++] = _t, vt[St++] = bi, bi = e; var n = Wt; e = _t; var r = 32 - At(n) - 1; n &= ~(1 << r), i += 1; var s = 32 - At(t) + r; if (30 < s) { var g = r - r % 5; s = (n & (1 << g) - 1).toString(32), n >>= g, r -= g, Wt = 1 << 32 - At(t) + r | i << r | n, _t = s + e } else Wt = 1 << s | i << r | n, _t = e } function al(e) { e.return !== null && (gi(e, 1), ou(e, 1, 0)) } function hl(e) { for (; e === _r;)_r = Bi[--Fi], Bi[Fi] = null, Hr = Bi[--Fi], Bi[Fi] = null; for (; e === bi;)bi = vt[--St], vt[St] = null, _t = vt[--St], vt[St] = null, Wt = vt[--St], vt[St] = null } var gt = null, ft = null, ze = !1, Et = null; function lu(e, t) { var i = kt(5, null, null, 0); i.elementType = "DELETED", i.stateNode = t, i.return = e, t = e.deletions, t === null ? (e.deletions = [i], e.flags |= 16) : t.push(i) } function ya(e, t) { switch (e.tag) { case 5: var i = e.type; return t = t.nodeType !== 1 || i.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, gt = e, ft = ri(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, gt = e, ft = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (i = bi !== null ? { id: Wt, overflow: _t } : null, e.memoizedState = { dehydrated: t, treeContext: i, retryLane: 1073741824 }, i = kt(18, null, null, 0), i.stateNode = t, i.return = e, e.child = i, gt = e, ft = null, !0) : !1; default: return !1 } } function So(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function ko(e) { if (ze) { var t = ft; if (t) { var i = t; if (!ya(e, t)) { if (So(e)) throw Error(xe(418)); t = ri(i.nextSibling); var n = gt; t && ya(e, t) ? lu(n, i) : (e.flags = e.flags & -4097 | 2, ze = !1, gt = e) } } else { if (So(e)) throw Error(xe(418)); e.flags = e.flags & -4097 | 2, ze = !1, gt = e } } } function xa(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; gt = e } function cr(e) { if (e !== gt) return !1; if (!ze) return xa(e), ze = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !mo(e.type, e.memoizedProps)), t && (t = ft)) { if (So(e)) throw au(), Error(xe(418)); for (; t;)lu(e, t), t = ri(t.nextSibling) } if (xa(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(xe(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "/$") { if (t === 0) { ft = ri(e.nextSibling); break e } t-- } else i !== "$" && i !== "$!" && i !== "$?" || t++ } e = e.nextSibling } ft = null } } else ft = gt ? ri(e.stateNode.nextSibling) : null; return !0 } function au() { for (var e = ft; e;)e = ri(e.nextSibling) } function Qi() { ft = gt = null, ze = !1 } function ul(e) { Et === null ? Et = [e] : Et.push(e) } var lp = Vt.ReactCurrentBatchConfig; function Tt(e, t) { if (e && e.defaultProps) { t = Be({}, t), e = e.defaultProps; for (var i in e) t[i] === void 0 && (t[i] = e[i]); return t } return t } var Ur = di(null), Gr = null, Wi = null, cl = null; function dl() { cl = Wi = Gr = null } function pl(e) { var t = Ur.current; Ne(Ur), e._currentValue = t } function wo(e, t, i) { for (; e !== null;) { var n = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t), e === i) break; e = e.return } } function Vi(e, t) { Gr = e, cl = Wi = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (lt = !0), e.firstContext = null) } function Ct(e) { var t = e._currentValue; if (cl !== e) if (e = { context: e, memoizedValue: t, next: null }, Wi === null) { if (Gr === null) throw Error(xe(308)); Wi = e, Gr.dependencies = { lanes: 0, firstContext: e } } else Wi = Wi.next = e; return t } var xi = null; function fl(e) { xi === null ? xi = [e] : xi.push(e) } function hu(e, t, i, n) { var r = t.interleaved; return r === null ? (i.next = i, fl(t)) : (i.next = r.next, r.next = i), t.interleaved = i, Xt(e, n) } function Xt(e, t) { e.lanes |= t; var i = e.alternate; for (i !== null && (i.lanes |= t), i = e, e = e.return; e !== null;)e.childLanes |= t, i = e.alternate, i !== null && (i.childLanes |= t), i = e, e = e.return; return i.tag === 3 ? i.stateNode : null } var Zt = !1; function gl(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function uu(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Ht(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function si(e, t, i) { var n = e.updateQueue; if (n === null) return null; if (n = n.shared, Ae & 2) { var r = n.pending; return r === null ? t.next = t : (t.next = r.next, r.next = t), n.pending = t, Xt(e, i) } return r = n.interleaved, r === null ? (t.next = t, fl(n)) : (t.next = r.next, r.next = t), n.interleaved = t, Xt(e, i) } function Cr(e, t, i) { if (t = t.updateQueue, t !== null && (t = t.shared, (i & 4194240) !== 0)) { var n = t.lanes; n &= e.pendingLanes, i |= n, t.lanes = i, el(e, i) } } function va(e, t) { var i = e.updateQueue, n = e.alternate; if (n !== null && (n = n.updateQueue, i === n)) { var r = null, s = null; if (i = i.firstBaseUpdate, i !== null) { do { var g = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; s === null ? r = s = g : s = s.next = g, i = i.next } while (i !== null); s === null ? r = s = t : s = s.next = t } else r = s = t; i = { baseState: n.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: n.shared, effects: n.effects }, e.updateQueue = i; return } e = i.lastBaseUpdate, e === null ? i.firstBaseUpdate = t : e.next = t, i.lastBaseUpdate = t } function Xr(e, t, i, n) { var r = e.updateQueue; Zt = !1; var s = r.firstBaseUpdate, g = r.lastBaseUpdate, j = r.shared.pending; if (j !== null) { r.shared.pending = null; var D = j, J = D.next; D.next = null, g === null ? s = J : g.next = J, g = D; var se = e.alternate; se !== null && (se = se.updateQueue, j = se.lastBaseUpdate, j !== g && (j === null ? se.firstBaseUpdate = J : j.next = J, se.lastBaseUpdate = D)) } if (s !== null) { var $ = r.baseState; g = 0, se = J = D = null, j = s; do { var R = j.lane, Q = j.eventTime; if ((n & R) === R) { se !== null && (se = se.next = { eventTime: Q, lane: 0, tag: j.tag, payload: j.payload, callback: j.callback, next: null }); e: { var E = e, I = j; switch (R = t, Q = i, I.tag) { case 1: if (E = I.payload, typeof E == "function") { $ = E.call(Q, $, R); break e } $ = E; break e; case 3: E.flags = E.flags & -65537 | 128; case 0: if (E = I.payload, R = typeof E == "function" ? E.call(Q, $, R) : E, R == null) break e; $ = Be({}, $, R); break e; case 2: Zt = !0 } } j.callback !== null && j.lane !== 0 && (e.flags |= 64, R = r.effects, R === null ? r.effects = [j] : R.push(j)) } else Q = { eventTime: Q, lane: R, tag: j.tag, payload: j.payload, callback: j.callback, next: null }, se === null ? (J = se = Q, D = $) : se = se.next = Q, g |= R; if (j = j.next, j === null) { if (j = r.shared.pending, j === null) break; R = j, j = R.next, R.next = null, r.lastBaseUpdate = R, r.shared.pending = null } } while (!0); if (se === null && (D = $), r.baseState = D, r.firstBaseUpdate = J, r.lastBaseUpdate = se, t = r.shared.interleaved, t !== null) { r = t; do g |= r.lane, r = r.next; while (r !== t) } else s === null && (r.shared.lanes = 0); Ti |= g, e.lanes = g, e.memoizedState = $ } } function Sa(e, t, i) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var n = e[t], r = n.callback; if (r !== null) { if (n.callback = null, n = i, typeof r != "function") throw Error(xe(191, r)); r.call(n) } } } var cu = new hh.Component().refs; function Co(e, t, i, n) { t = e.memoizedState, i = i(n, t), i = i == null ? t : Be({}, t, i), e.memoizedState = i, e.lanes === 0 && (e.updateQueue.baseState = i) } var us = { isMounted: function (e) { return (e = e._reactInternals) ? Ai(e) === e : !1 }, enqueueSetState: function (e, t, i) { e = e._reactInternals; var n = nt(), r = li(e), s = Ht(n, r); s.payload = t, i != null && (s.callback = i), t = si(e, s, r), t !== null && (Lt(t, e, r, n), Cr(t, e, r)) }, enqueueReplaceState: function (e, t, i) { e = e._reactInternals; var n = nt(), r = li(e), s = Ht(n, r); s.tag = 1, s.payload = t, i != null && (s.callback = i), t = si(e, s, r), t !== null && (Lt(t, e, r, n), Cr(t, e, r)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var i = nt(), n = li(e), r = Ht(i, n); r.tag = 2, t != null && (r.callback = t), t = si(e, r, n), t !== null && (Lt(t, e, n, i), Cr(t, e, n)) } }; function ka(e, t, i, n, r, s, g) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(n, s, g) : t.prototype && t.prototype.isPureReactComponent ? !Nn(i, n) || !Nn(r, s) : !0 } function du(e, t, i) { var n = !1, r = ui, s = t.contextType; return typeof s == "object" && s !== null ? s = Ct(s) : (r = ht(t) ? Ci : tt.current, n = t.contextTypes, s = (n = n != null) ? Zi(e, r) : ui), t = new t(i, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = us, e.stateNode = t, t._reactInternals = e, n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = r, e.__reactInternalMemoizedMaskedChildContext = s), t } function wa(e, t, i, n) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(i, n), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(i, n), t.state !== e && us.enqueueReplaceState(t, t.state, null) } function bo(e, t, i, n) { var r = e.stateNode; r.props = i, r.state = e.memoizedState, r.refs = cu, gl(e); var s = t.contextType; typeof s == "object" && s !== null ? r.context = Ct(s) : (s = ht(t) ? Ci : tt.current, r.context = Zi(e, s)), r.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (Co(e, t, s, i), r.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (t = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), t !== r.state && us.enqueueReplaceState(r, r.state, null), Xr(e, i, r, n), r.state = e.memoizedState), typeof r.componentDidMount == "function" && (e.flags |= 4194308) } function cn(e, t, i) { if (e = i.ref, e !== null && typeof e != "function" && typeof e != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(xe(309)); var n = i.stateNode } if (!n) throw Error(xe(147, e)); var r = n, s = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function (g) { var j = r.refs; j === cu && (j = r.refs = {}), g === null ? delete j[s] : j[s] = g }, t._stringRef = s, t) } if (typeof e != "string") throw Error(xe(284)); if (!i._owner) throw Error(xe(290, e)) } return e } function dr(e, t) { throw e = Object.prototype.toString.call(t), Error(xe(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Ca(e) { var t = e._init; return t(e._payload) } function pu(e) { function t(y, a) { if (e) { var v = y.deletions; v === null ? (y.deletions = [a], y.flags |= 16) : v.push(a) } } function i(y, a) { if (!e) return null; for (; a !== null;)t(y, a), a = a.sibling; return null } function n(y, a) { for (y = new Map; a !== null;)a.key !== null ? y.set(a.key, a) : y.set(a.index, a), a = a.sibling; return y } function r(y, a) { return y = ai(y, a), y.index = 0, y.sibling = null, y } function s(y, a, v) { return y.index = v, e ? (v = y.alternate, v !== null ? (v = v.index, v < a ? (y.flags |= 2, a) : v) : (y.flags |= 2, a)) : (y.flags |= 1048576, a) } function g(y) { return e && y.alternate === null && (y.flags |= 2), y } function j(y, a, v, k) { return a === null || a.tag !== 6 ? (a = Us(v, y.mode, k), a.return = y, a) : (a = r(a, v), a.return = y, a) } function D(y, a, v, k) { var w = v.type; return w === ji ? se(y, a, v.props.children, k, v.key) : a !== null && (a.elementType === w || typeof w == "object" && w !== null && w.$$typeof === Kt && Ca(w) === a.type) ? (k = r(a, v.props), k.ref = cn(y, a, v), k.return = y, k) : (k = Ar(v.type, v.key, v.props, null, y.mode, k), k.ref = cn(y, a, v), k.return = y, k) } function J(y, a, v, k) { return a === null || a.tag !== 4 || a.stateNode.containerInfo !== v.containerInfo || a.stateNode.implementation !== v.implementation ? (a = Gs(v, y.mode, k), a.return = y, a) : (a = r(a, v.children || []), a.return = y, a) } function se(y, a, v, k, w) { return a === null || a.tag !== 7 ? (a = wi(v, y.mode, k, w), a.return = y, a) : (a = r(a, v), a.return = y, a) } function $(y, a, v) { if (typeof a == "string" && a !== "" || typeof a == "number") return a = Us("" + a, y.mode, v), a.return = y, a; if (typeof a == "object" && a !== null) { switch (a.$$typeof) { case tr: return v = Ar(a.type, a.key, a.props, null, y.mode, v), v.ref = cn(y, null, a), v.return = y, v; case Oi: return a = Gs(a, y.mode, v), a.return = y, a; case Kt: var k = a._init; return $(y, k(a._payload), v) }if (gn(a) || on(a)) return a = wi(a, y.mode, v, null), a.return = y, a; dr(y, a) } return null } function R(y, a, v, k) { var w = a !== null ? a.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return w !== null ? null : j(y, a, "" + v, k); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case tr: return v.key === w ? D(y, a, v, k) : null; case Oi: return v.key === w ? J(y, a, v, k) : null; case Kt: return w = v._init, R(y, a, w(v._payload), k) }if (gn(v) || on(v)) return w !== null ? null : se(y, a, v, k, null); dr(y, v) } return null } function Q(y, a, v, k, w) { if (typeof k == "string" && k !== "" || typeof k == "number") return y = y.get(v) || null, j(a, y, "" + k, w); if (typeof k == "object" && k !== null) { switch (k.$$typeof) { case tr: return y = y.get(k.key === null ? v : k.key) || null, D(a, y, k, w); case Oi: return y = y.get(k.key === null ? v : k.key) || null, J(a, y, k, w); case Kt: var L = k._init; return Q(y, a, v, L(k._payload), w) }if (gn(k) || on(k)) return y = y.get(v) || null, se(a, y, k, w, null); dr(a, k) } return null } function E(y, a, v, k) { for (var w = null, L = null, G = a, _ = a = 0, N = null; G !== null && _ < v.length; _++) { G.index > _ ? (N = G, G = null) : N = G.sibling; var F = R(y, G, v[_], k); if (F === null) { G === null && (G = N); break } e && G && F.alternate === null && t(y, G), a = s(F, a, _), L === null ? w = F : L.sibling = F, L = F, G = N } if (_ === v.length) return i(y, G), ze && gi(y, _), w; if (G === null) { for (; _ < v.length; _++)G = $(y, v[_], k), G !== null && (a = s(G, a, _), L === null ? w = G : L.sibling = G, L = G); return ze && gi(y, _), w } for (G = n(y, G); _ < v.length; _++)N = Q(G, y, _, v[_], k), N !== null && (e && N.alternate !== null && G.delete(N.key === null ? _ : N.key), a = s(N, a, _), L === null ? w = N : L.sibling = N, L = N); return e && G.forEach(function (C) { return t(y, C) }), ze && gi(y, _), w } function I(y, a, v, k) { var w = on(v); if (typeof w != "function") throw Error(xe(150)); if (v = w.call(v), v == null) throw Error(xe(151)); for (var L = w = null, G = a, _ = a = 0, N = null, F = v.next(); G !== null && !F.done; _++, F = v.next()) { G.index > _ ? (N = G, G = null) : N = G.sibling; var C = R(y, G, F.value, k); if (C === null) { G === null && (G = N); break } e && G && C.alternate === null && t(y, G), a = s(C, a, _), L === null ? w = C : L.sibling = C, L = C, G = N } if (F.done) return i(y, G), ze && gi(y, _), w; if (G === null) { for (; !F.done; _++, F = v.next())F = $(y, F.value, k), F !== null && (a = s(F, a, _), L === null ? w = F : L.sibling = F, L = F); return ze && gi(y, _), w } for (G = n(y, G); !F.done; _++, F = v.next())F = Q(G, y, _, F.value, k), F !== null && (e && F.alternate !== null && G.delete(F.key === null ? _ : F.key), a = s(F, a, _), L === null ? w = F : L.sibling = F, L = F); return e && G.forEach(function (x) { return t(y, x) }), ze && gi(y, _), w } function W(y, a, v, k) { if (typeof v == "object" && v !== null && v.type === ji && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case tr: e: { for (var w = v.key, L = a; L !== null;) { if (L.key === w) { if (w = v.type, w === ji) { if (L.tag === 7) { i(y, L.sibling), a = r(L, v.props.children), a.return = y, y = a; break e } } else if (L.elementType === w || typeof w == "object" && w !== null && w.$$typeof === Kt && Ca(w) === L.type) { i(y, L.sibling), a = r(L, v.props), a.ref = cn(y, L, v), a.return = y, y = a; break e } i(y, L); break } else t(y, L); L = L.sibling } v.type === ji ? (a = wi(v.props.children, y.mode, k, v.key), a.return = y, y = a) : (k = Ar(v.type, v.key, v.props, null, y.mode, k), k.ref = cn(y, a, v), k.return = y, y = k) } return g(y); case Oi: e: { for (L = v.key; a !== null;) { if (a.key === L) if (a.tag === 4 && a.stateNode.containerInfo === v.containerInfo && a.stateNode.implementation === v.implementation) { i(y, a.sibling), a = r(a, v.children || []), a.return = y, y = a; break e } else { i(y, a); break } else t(y, a); a = a.sibling } a = Gs(v, y.mode, k), a.return = y, y = a } return g(y); case Kt: return L = v._init, W(y, a, L(v._payload), k) }if (gn(v)) return E(y, a, v, k); if (on(v)) return I(y, a, v, k); dr(y, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, a !== null && a.tag === 6 ? (i(y, a.sibling), a = r(a, v), a.return = y, y = a) : (i(y, a), a = Us(v, y.mode, k), a.return = y, y = a), g(y)) : i(y, a) } return W } var qi = pu(!0), fu = pu(!1), $n = {}, Rt = di($n), Bn = di($n), Fn = di($n); function vi(e) { if (e === $n) throw Error(xe(174)); return e } function ml(e, t) { switch (Oe(Fn, t), Oe(Bn, e), Oe(Rt, $n), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : to(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = to(t, e) }Ne(Rt), Oe(Rt, t) } function Ji() { Ne(Rt), Ne(Bn), Ne(Fn) } function gu(e) { vi(Fn.current); var t = vi(Rt.current), i = to(t, e.type); t !== i && (Oe(Bn, e), Oe(Rt, i)) } function yl(e) { Bn.current === e && (Ne(Rt), Ne(Bn)) } var Ie = di(0); function Yr(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var i = t.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Rs = []; function xl() { for (var e = 0; e < Rs.length; e++)Rs[e]._workInProgressVersionPrimary = null; Rs.length = 0 } var br = Vt.ReactCurrentDispatcher, Bs = Vt.ReactCurrentBatchConfig, Mi = 0, Re = null, Ge = null, Ye = null, Vr = !1, Cn = !1, Wn = 0, ap = 0; function qe() { throw Error(xe(321)) } function vl(e, t) { if (t === null) return !1; for (var i = 0; i < t.length && i < e.length; i++)if (!Ot(e[i], t[i])) return !1; return !0 } function Sl(e, t, i, n, r, s) { if (Mi = s, Re = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, br.current = e === null || e.memoizedState === null ? dp : pp, e = i(n, r), Cn) { s = 0; do { if (Cn = !1, Wn = 0, 25 <= s) throw Error(xe(301)); s += 1, Ye = Ge = null, t.updateQueue = null, br.current = fp, e = i(n, r) } while (Cn) } if (br.current = $r, t = Ge !== null && Ge.next !== null, Mi = 0, Ye = Ge = Re = null, Vr = !1, t) throw Error(xe(300)); return e } function kl() { var e = Wn !== 0; return Wn = 0, e } function Nt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ye === null ? Re.memoizedState = Ye = e : Ye = Ye.next = e, Ye } function bt() { if (Ge === null) { var e = Re.alternate; e = e !== null ? e.memoizedState : null } else e = Ge.next; var t = Ye === null ? Re.memoizedState : Ye.next; if (t !== null) Ye = t, Ge = e; else { if (e === null) throw Error(xe(310)); Ge = e, e = { memoizedState: Ge.memoizedState, baseState: Ge.baseState, baseQueue: Ge.baseQueue, queue: Ge.queue, next: null }, Ye === null ? Re.memoizedState = Ye = e : Ye = Ye.next = e } return Ye } function _n(e, t) { return typeof t == "function" ? t(e) : t } function Fs(e) { var t = bt(), i = t.queue; if (i === null) throw Error(xe(311)); i.lastRenderedReducer = e; var n = Ge, r = n.baseQueue, s = i.pending; if (s !== null) { if (r !== null) { var g = r.next; r.next = s.next, s.next = g } n.baseQueue = r = s, i.pending = null } if (r !== null) { s = r.next, n = n.baseState; var j = g = null, D = null, J = s; do { var se = J.lane; if ((Mi & se) === se) D !== null && (D = D.next = { lane: 0, action: J.action, hasEagerState: J.hasEagerState, eagerState: J.eagerState, next: null }), n = J.hasEagerState ? J.eagerState : e(n, J.action); else { var $ = { lane: se, action: J.action, hasEagerState: J.hasEagerState, eagerState: J.eagerState, next: null }; D === null ? (j = D = $, g = n) : D = D.next = $, Re.lanes |= se, Ti |= se } J = J.next } while (J !== null && J !== s); D === null ? g = n : D.next = j, Ot(n, t.memoizedState) || (lt = !0), t.memoizedState = n, t.baseState = g, t.baseQueue = D, i.lastRenderedState = n } if (e = i.interleaved, e !== null) { r = e; do s = r.lane, Re.lanes |= s, Ti |= s, r = r.next; while (r !== e) } else r === null && (i.lanes = 0); return [t.memoizedState, i.dispatch] } function Ws(e) { var t = bt(), i = t.queue; if (i === null) throw Error(xe(311)); i.lastRenderedReducer = e; var n = i.dispatch, r = i.pending, s = t.memoizedState; if (r !== null) { i.pending = null; var g = r = r.next; do s = e(s, g.action), g = g.next; while (g !== r); Ot(s, t.memoizedState) || (lt = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), i.lastRenderedState = s } return [s, n] } function mu() { } function yu(e, t) { var i = Re, n = bt(), r = t(), s = !Ot(n.memoizedState, r); if (s && (n.memoizedState = r, lt = !0), n = n.queue, wl(Su.bind(null, i, n, e), [e]), n.getSnapshot !== t || s || Ye !== null && Ye.memoizedState.tag & 1) { if (i.flags |= 2048, Hn(9, vu.bind(null, i, n, r, t), void 0, null), Ve === null) throw Error(xe(349)); Mi & 30 || xu(i, t, r) } return r } function xu(e, t, i) { e.flags |= 16384, e = { getSnapshot: t, value: i }, t = Re.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Re.updateQueue = t, t.stores = [e]) : (i = t.stores, i === null ? t.stores = [e] : i.push(e)) } function vu(e, t, i, n) { t.value = i, t.getSnapshot = n, ku(t) && wu(e) } function Su(e, t, i) { return i(function () { ku(t) && wu(e) }) } function ku(e) { var t = e.getSnapshot; e = e.value; try { var i = t(); return !Ot(e, i) } catch { return !0 } } function wu(e) { var t = Xt(e, 1); t !== null && Lt(t, e, 1, -1) } function ba(e) { var t = Nt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: _n, lastRenderedState: e }, t.queue = e, e = e.dispatch = cp.bind(null, Re, e), [t.memoizedState, e] } function Hn(e, t, i, n) { return e = { tag: e, create: t, destroy: i, deps: n, next: null }, t = Re.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Re.updateQueue = t, t.lastEffect = e.next = e) : (i = t.lastEffect, i === null ? t.lastEffect = e.next = e : (n = i.next, i.next = e, e.next = n, t.lastEffect = e)), e } function Cu() { return bt().memoizedState } function Mr(e, t, i, n) { var r = Nt(); Re.flags |= e, r.memoizedState = Hn(1 | t, i, void 0, n === void 0 ? null : n) } function cs(e, t, i, n) { var r = bt(); n = n === void 0 ? null : n; var s = void 0; if (Ge !== null) { var g = Ge.memoizedState; if (s = g.destroy, n !== null && vl(n, g.deps)) { r.memoizedState = Hn(t, i, s, n); return } } Re.flags |= e, r.memoizedState = Hn(1 | t, i, s, n) } function Ma(e, t) { return Mr(8390656, 8, e, t) } function wl(e, t) { return cs(2048, 8, e, t) } function bu(e, t) { return cs(4, 2, e, t) } function Mu(e, t) { return cs(4, 4, e, t) } function Tu(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Pu(e, t, i) { return i = i != null ? i.concat([e]) : null, cs(4, 4, Tu.bind(null, t, e), i) } function Cl() { } function Eu(e, t) { var i = bt(); t = t === void 0 ? null : t; var n = i.memoizedState; return n !== null && t !== null && vl(t, n[1]) ? n[0] : (i.memoizedState = [e, t], e) } function Au(e, t) { var i = bt(); t = t === void 0 ? null : t; var n = i.memoizedState; return n !== null && t !== null && vl(t, n[1]) ? n[0] : (e = e(), i.memoizedState = [e, t], e) } function Lu(e, t, i) { return Mi & 21 ? (Ot(i, t) || (i = Dh(), Re.lanes |= i, Ti |= i, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, lt = !0), e.memoizedState = i) } function hp(e, t) { var i = Le; Le = i !== 0 && 4 > i ? i : 4, e(!0); var n = Bs.transition; Bs.transition = {}; try { e(!1), t() } finally { Le = i, Bs.transition = n } } function Ou() { return bt().memoizedState } function up(e, t, i) { var n = li(e); if (i = { lane: n, action: i, hasEagerState: !1, eagerState: null, next: null }, ju(e)) Du(t, i); else if (i = hu(e, t, i, n), i !== null) { var r = nt(); Lt(i, e, n, r), Nu(i, t, n) } } function cp(e, t, i) { var n = li(e), r = { lane: n, action: i, hasEagerState: !1, eagerState: null, next: null }; if (ju(e)) Du(t, r); else { var s = e.alternate; if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try { var g = t.lastRenderedState, j = s(g, i); if (r.hasEagerState = !0, r.eagerState = j, Ot(j, g)) { var D = t.interleaved; D === null ? (r.next = r, fl(t)) : (r.next = D.next, D.next = r), t.interleaved = r; return } } catch { } finally { } i = hu(e, t, r, n), i !== null && (r = nt(), Lt(i, e, n, r), Nu(i, t, n)) } } function ju(e) { var t = e.alternate; return e === Re || t !== null && t === Re } function Du(e, t) { Cn = Vr = !0; var i = e.pending; i === null ? t.next = t : (t.next = i.next, i.next = t), e.pending = t } function Nu(e, t, i) { if (i & 4194240) { var n = t.lanes; n &= e.pendingLanes, i |= n, t.lanes = i, el(e, i) } } var $r = { readContext: Ct, useCallback: qe, useContext: qe, useEffect: qe, useImperativeHandle: qe, useInsertionEffect: qe, useLayoutEffect: qe, useMemo: qe, useReducer: qe, useRef: qe, useState: qe, useDebugValue: qe, useDeferredValue: qe, useTransition: qe, useMutableSource: qe, useSyncExternalStore: qe, useId: qe, unstable_isNewReconciler: !1 }, dp = { readContext: Ct, useCallback: function (e, t) { return Nt().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Ct, useEffect: Ma, useImperativeHandle: function (e, t, i) { return i = i != null ? i.concat([e]) : null, Mr(4194308, 4, Tu.bind(null, t, e), i) }, useLayoutEffect: function (e, t) { return Mr(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Mr(4, 2, e, t) }, useMemo: function (e, t) { var i = Nt(); return t = t === void 0 ? null : t, e = e(), i.memoizedState = [e, t], e }, useReducer: function (e, t, i) { var n = Nt(); return t = i !== void 0 ? i(t) : t, n.memoizedState = n.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, n.queue = e, e = e.dispatch = up.bind(null, Re, e), [n.memoizedState, e] }, useRef: function (e) { var t = Nt(); return e = { current: e }, t.memoizedState = e }, useState: ba, useDebugValue: Cl, useDeferredValue: function (e) { return Nt().memoizedState = e }, useTransition: function () { var e = ba(!1), t = e[0]; return e = hp.bind(null, e[1]), Nt().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, i) { var n = Re, r = Nt(); if (ze) { if (i === void 0) throw Error(xe(407)); i = i() } else { if (i = t(), Ve === null) throw Error(xe(349)); Mi & 30 || xu(n, t, i) } r.memoizedState = i; var s = { value: i, getSnapshot: t }; return r.queue = s, Ma(Su.bind(null, n, s, e), [e]), n.flags |= 2048, Hn(9, vu.bind(null, n, s, i, t), void 0, null), i }, useId: function () { var e = Nt(), t = Ve.identifierPrefix; if (ze) { var i = _t, n = Wt; i = (n & ~(1 << 32 - At(n) - 1)).toString(32) + i, t = ":" + t + "R" + i, i = Wn++, 0 < i && (t += "H" + i.toString(32)), t += ":" } else i = ap++, t = ":" + t + "r" + i.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, pp = { readContext: Ct, useCallback: Eu, useContext: Ct, useEffect: wl, useImperativeHandle: Pu, useInsertionEffect: bu, useLayoutEffect: Mu, useMemo: Au, useReducer: Fs, useRef: Cu, useState: function () { return Fs(_n) }, useDebugValue: Cl, useDeferredValue: function (e) { var t = bt(); return Lu(t, Ge.memoizedState, e) }, useTransition: function () { var e = Fs(_n)[0], t = bt().memoizedState; return [e, t] }, useMutableSource: mu, useSyncExternalStore: yu, useId: Ou, unstable_isNewReconciler: !1 }, fp = { readContext: Ct, useCallback: Eu, useContext: Ct, useEffect: wl, useImperativeHandle: Pu, useInsertionEffect: bu, useLayoutEffect: Mu, useMemo: Au, useReducer: Ws, useRef: Cu, useState: function () { return Ws(_n) }, useDebugValue: Cl, useDeferredValue: function (e) { var t = bt(); return Ge === null ? t.memoizedState = e : Lu(t, Ge.memoizedState, e) }, useTransition: function () { var e = Ws(_n)[0], t = bt().memoizedState; return [e, t] }, useMutableSource: mu, useSyncExternalStore: yu, useId: Ou, unstable_isNewReconciler: !1 }; function en(e, t) {
    try { var i = "", n = t; do i += Hc(n), n = n.return; while (n); var r = i } catch (s) {
        r = `
Error generating stack: `+ s.message + `
`+ s.stack
    } return { value: e, source: t, stack: r, digest: null }
} function _s(e, t, i) { return { value: e, source: null, stack: i ?? null, digest: t ?? null } } function Mo(e, t) { try { console.error(t.value) } catch (i) { setTimeout(function () { throw i }) } } var gp = typeof WeakMap == "function" ? WeakMap : Map; function zu(e, t, i) { i = Ht(-1, i), i.tag = 3, i.payload = { element: null }; var n = t.value; return i.callback = function () { Zr || (Zr = !0, zo = n), Mo(e, t) }, i } function Iu(e, t, i) { i = Ht(-1, i), i.tag = 3; var n = e.type.getDerivedStateFromError; if (typeof n == "function") { var r = t.value; i.payload = function () { return n(r) }, i.callback = function () { Mo(e, t) } } var s = e.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (i.callback = function () { Mo(e, t), typeof n != "function" && (oi === null ? oi = new Set([this]) : oi.add(this)); var g = t.stack; this.componentDidCatch(t.value, { componentStack: g !== null ? g : "" }) }), i } function Ta(e, t, i) { var n = e.pingCache; if (n === null) { n = e.pingCache = new gp; var r = new Set; n.set(t, r) } else r = n.get(t), r === void 0 && (r = new Set, n.set(t, r)); r.has(i) || (r.add(i), e = Ap.bind(null, e, t, i), t.then(e, e)) } function Pa(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function Ea(e, t, i, n, r) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = r, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (t = Ht(-1, 1), t.tag = 2, si(i, t, 1))), i.lanes |= 1), e) } var mp = Vt.ReactCurrentOwner, lt = !1; function it(e, t, i, n) { t.child = e === null ? fu(t, null, i, n) : qi(t, e.child, i, n) } function Aa(e, t, i, n, r) { i = i.render; var s = t.ref; return Vi(t, r), n = Sl(e, t, i, n, s, r), i = kl(), e !== null && !lt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~r, Yt(e, t, r)) : (ze && i && al(t), t.flags |= 1, it(e, t, n, r), t.child) } function La(e, t, i, n, r) { if (e === null) { var s = i.type; return typeof s == "function" && !Ol(s) && s.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (t.tag = 15, t.type = s, Ru(e, t, s, n, r)) : (e = Ar(i.type, null, n, t, t.mode, r), e.ref = t.ref, e.return = t, t.child = e) } if (s = e.child, !(e.lanes & r)) { var g = s.memoizedProps; if (i = i.compare, i = i !== null ? i : Nn, i(g, n) && e.ref === t.ref) return Yt(e, t, r) } return t.flags |= 1, e = ai(s, n), e.ref = t.ref, e.return = t, t.child = e } function Ru(e, t, i, n, r) { if (e !== null) { var s = e.memoizedProps; if (Nn(s, n) && e.ref === t.ref) if (lt = !1, t.pendingProps = n = s, (e.lanes & r) !== 0) e.flags & 131072 && (lt = !0); else return t.lanes = e.lanes, Yt(e, t, r) } return To(e, t, i, n, r) } function Bu(e, t, i) { var n = t.pendingProps, r = n.children, s = e !== null ? e.memoizedState : null; if (n.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Oe(Hi, pt), pt |= i; else { if (!(i & 1073741824)) return e = s !== null ? s.baseLanes | i : i, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Oe(Hi, pt), pt |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = s !== null ? s.baseLanes : i, Oe(Hi, pt), pt |= n } else s !== null ? (n = s.baseLanes | i, t.memoizedState = null) : n = i, Oe(Hi, pt), pt |= n; return it(e, t, r, i), t.child } function Fu(e, t) { var i = t.ref; (e === null && i !== null || e !== null && e.ref !== i) && (t.flags |= 512, t.flags |= 2097152) } function To(e, t, i, n, r) { var s = ht(i) ? Ci : tt.current; return s = Zi(t, s), Vi(t, r), i = Sl(e, t, i, n, s, r), n = kl(), e !== null && !lt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~r, Yt(e, t, r)) : (ze && n && al(t), t.flags |= 1, it(e, t, i, r), t.child) } function Oa(e, t, i, n, r) { if (ht(i)) { var s = !0; Wr(t) } else s = !1; if (Vi(t, r), t.stateNode === null) Tr(e, t), du(t, i, n), bo(t, i, n, r), n = !0; else if (e === null) { var g = t.stateNode, j = t.memoizedProps; g.props = j; var D = g.context, J = i.contextType; typeof J == "object" && J !== null ? J = Ct(J) : (J = ht(i) ? Ci : tt.current, J = Zi(t, J)); var se = i.getDerivedStateFromProps, $ = typeof se == "function" || typeof g.getSnapshotBeforeUpdate == "function"; $ || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (j !== n || D !== J) && wa(t, g, n, J), Zt = !1; var R = t.memoizedState; g.state = R, Xr(t, n, g, r), D = t.memoizedState, j !== n || R !== D || at.current || Zt ? (typeof se == "function" && (Co(t, i, se, n), D = t.memoizedState), (j = Zt || ka(t, i, j, n, R, D, J)) ? ($ || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = n, t.memoizedState = D), g.props = n, g.state = D, g.context = J, n = j) : (typeof g.componentDidMount == "function" && (t.flags |= 4194308), n = !1) } else { g = t.stateNode, uu(e, t), j = t.memoizedProps, J = t.type === t.elementType ? j : Tt(t.type, j), g.props = J, $ = t.pendingProps, R = g.context, D = i.contextType, typeof D == "object" && D !== null ? D = Ct(D) : (D = ht(i) ? Ci : tt.current, D = Zi(t, D)); var Q = i.getDerivedStateFromProps; (se = typeof Q == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (j !== $ || R !== D) && wa(t, g, n, D), Zt = !1, R = t.memoizedState, g.state = R, Xr(t, n, g, r); var E = t.memoizedState; j !== $ || R !== E || at.current || Zt ? (typeof Q == "function" && (Co(t, i, Q, n), E = t.memoizedState), (J = Zt || ka(t, i, J, n, R, E, D) || !1) ? (se || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(n, E, D), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(n, E, D)), typeof g.componentDidUpdate == "function" && (t.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || j === e.memoizedProps && R === e.memoizedState || (t.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || j === e.memoizedProps && R === e.memoizedState || (t.flags |= 1024), t.memoizedProps = n, t.memoizedState = E), g.props = n, g.state = E, g.context = D, n = J) : (typeof g.componentDidUpdate != "function" || j === e.memoizedProps && R === e.memoizedState || (t.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || j === e.memoizedProps && R === e.memoizedState || (t.flags |= 1024), n = !1) } return Po(e, t, i, n, s, r) } function Po(e, t, i, n, r, s) { Fu(e, t); var g = (t.flags & 128) !== 0; if (!n && !g) return r && ma(t, i, !1), Yt(e, t, s); n = t.stateNode, mp.current = t; var j = g && typeof i.getDerivedStateFromError != "function" ? null : n.render(); return t.flags |= 1, e !== null && g ? (t.child = qi(t, e.child, null, s), t.child = qi(t, null, j, s)) : it(e, t, j, s), t.memoizedState = n.state, r && ma(t, i, !0), t.child } function Wu(e) { var t = e.stateNode; t.pendingContext ? ga(e, t.pendingContext, t.pendingContext !== t.context) : t.context && ga(e, t.context, !1), ml(e, t.containerInfo) } function ja(e, t, i, n, r) { return Qi(), ul(r), t.flags |= 256, it(e, t, i, n), t.child } var Eo = { dehydrated: null, treeContext: null, retryLane: 0 }; function Ao(e) { return { baseLanes: e, cachePool: null, transitions: null } } function _u(e, t, i) { var n = t.pendingProps, r = Ie.current, s = !1, g = (t.flags & 128) !== 0, j; if ((j = g) || (j = e !== null && e.memoizedState === null ? !1 : (r & 2) !== 0), j ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (r |= 1), Oe(Ie, r & 1), e === null) return ko(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (g = n.children, e = n.fallback, s ? (n = t.mode, s = t.child, g = { mode: "hidden", children: g }, !(n & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = g) : s = fs(g, n, 0, null), e = wi(e, n, i, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Ao(i), t.memoizedState = Eo, e) : bl(t, g)); if (r = e.memoizedState, r !== null && (j = r.dehydrated, j !== null)) return yp(e, t, g, n, j, r, i); if (s) { s = n.fallback, g = t.mode, r = e.child, j = r.sibling; var D = { mode: "hidden", children: n.children }; return !(g & 1) && t.child !== r ? (n = t.child, n.childLanes = 0, n.pendingProps = D, t.deletions = null) : (n = ai(r, D), n.subtreeFlags = r.subtreeFlags & 14680064), j !== null ? s = ai(j, s) : (s = wi(s, g, i, null), s.flags |= 2), s.return = t, n.return = t, n.sibling = s, t.child = n, n = s, s = t.child, g = e.child.memoizedState, g = g === null ? Ao(i) : { baseLanes: g.baseLanes | i, cachePool: null, transitions: g.transitions }, s.memoizedState = g, s.childLanes = e.childLanes & ~i, t.memoizedState = Eo, n } return s = e.child, e = s.sibling, n = ai(s, { mode: "visible", children: n.children }), !(t.mode & 1) && (n.lanes = i), n.return = t, n.sibling = null, e !== null && (i = t.deletions, i === null ? (t.deletions = [e], t.flags |= 16) : i.push(e)), t.child = n, t.memoizedState = null, n } function bl(e, t) { return t = fs({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function pr(e, t, i, n) { return n !== null && ul(n), qi(t, e.child, null, i), e = bl(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function yp(e, t, i, n, r, s, g) { if (i) return t.flags & 256 ? (t.flags &= -257, n = _s(Error(xe(422))), pr(e, t, g, n)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = n.fallback, r = t.mode, n = fs({ mode: "visible", children: n.children }, r, 0, null), s = wi(s, r, g, null), s.flags |= 2, n.return = t, s.return = t, n.sibling = s, t.child = n, t.mode & 1 && qi(t, e.child, null, g), t.child.memoizedState = Ao(g), t.memoizedState = Eo, s); if (!(t.mode & 1)) return pr(e, t, g, null); if (r.data === "$!") { if (n = r.nextSibling && r.nextSibling.dataset, n) var j = n.dgst; return n = j, s = Error(xe(419)), n = _s(s, n, void 0), pr(e, t, g, n) } if (j = (g & e.childLanes) !== 0, lt || j) { if (n = Ve, n !== null) { switch (g & -g) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (n.suspendedLanes | g) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Xt(e, r), Lt(n, e, r, -1)) } return Ll(), n = _s(Error(xe(421))), pr(e, t, g, n) } return r.data === "$?" ? (t.flags |= 128, t.child = e.child, t = Lp.bind(null, e), r._reactRetry = t, null) : (e = s.treeContext, ft = ri(r.nextSibling), gt = t, ze = !0, Et = null, e !== null && (vt[St++] = Wt, vt[St++] = _t, vt[St++] = bi, Wt = e.id, _t = e.overflow, bi = t), t = bl(t, n.children), t.flags |= 4096, t) } function Da(e, t, i) { e.lanes |= t; var n = e.alternate; n !== null && (n.lanes |= t), wo(e.return, t, i) } function Hs(e, t, i, n, r) { var s = e.memoizedState; s === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: n, tail: i, tailMode: r } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = i, s.tailMode = r) } function Hu(e, t, i) { var n = t.pendingProps, r = n.revealOrder, s = n.tail; if (it(e, t, n.children, i), n = Ie.current, n & 2) n = n & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Da(e, i, t); else if (e.tag === 19) Da(e, i, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } n &= 1 } if (Oe(Ie, n), !(t.mode & 1)) t.memoizedState = null; else switch (r) { case "forwards": for (i = t.child, r = null; i !== null;)e = i.alternate, e !== null && Yr(e) === null && (r = i), i = i.sibling; i = r, i === null ? (r = t.child, t.child = null) : (r = i.sibling, i.sibling = null), Hs(t, !1, r, i, s); break; case "backwards": for (i = null, r = t.child, t.child = null; r !== null;) { if (e = r.alternate, e !== null && Yr(e) === null) { t.child = r; break } e = r.sibling, r.sibling = i, i = r, r = e } Hs(t, !0, i, null, s); break; case "together": Hs(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Tr(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Yt(e, t, i) { if (e !== null && (t.dependencies = e.dependencies), Ti |= t.lanes, !(i & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(xe(153)); if (t.child !== null) { for (e = t.child, i = ai(e, e.pendingProps), t.child = i, i.return = t; e.sibling !== null;)e = e.sibling, i = i.sibling = ai(e, e.pendingProps), i.return = t; i.sibling = null } return t.child } function xp(e, t, i) { switch (t.tag) { case 3: Wu(t), Qi(); break; case 5: gu(t); break; case 1: ht(t.type) && Wr(t); break; case 4: ml(t, t.stateNode.containerInfo); break; case 10: var n = t.type._context, r = t.memoizedProps.value; Oe(Ur, n._currentValue), n._currentValue = r; break; case 13: if (n = t.memoizedState, n !== null) return n.dehydrated !== null ? (Oe(Ie, Ie.current & 1), t.flags |= 128, null) : i & t.child.childLanes ? _u(e, t, i) : (Oe(Ie, Ie.current & 1), e = Yt(e, t, i), e !== null ? e.sibling : null); Oe(Ie, Ie.current & 1); break; case 19: if (n = (i & t.childLanes) !== 0, e.flags & 128) { if (n) return Hu(e, t, i); t.flags |= 128 } if (r = t.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Oe(Ie, Ie.current), n) break; return null; case 22: case 23: return t.lanes = 0, Bu(e, t, i) }return Yt(e, t, i) } var Uu, Lo, Gu, Xu; Uu = function (e, t) { for (var i = t.child; i !== null;) { if (i.tag === 5 || i.tag === 6) e.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === t) break; for (; i.sibling === null;) { if (i.return === null || i.return === t) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }; Lo = function () { }; Gu = function (e, t, i, n) { var r = e.memoizedProps; if (r !== n) { e = t.stateNode, vi(Rt.current); var s = null; switch (i) { case "input": r = Qs(e, r), n = Qs(e, n), s = []; break; case "select": r = Be({}, r, { value: void 0 }), n = Be({}, n, { value: void 0 }), s = []; break; case "textarea": r = eo(e, r), n = eo(e, n), s = []; break; default: typeof r.onClick != "function" && typeof n.onClick == "function" && (e.onclick = Br) }io(i, n); var g; i = null; for (J in r) if (!n.hasOwnProperty(J) && r.hasOwnProperty(J) && r[J] != null) if (J === "style") { var j = r[J]; for (g in j) j.hasOwnProperty(g) && (i || (i = {}), i[g] = "") } else J !== "dangerouslySetInnerHTML" && J !== "children" && J !== "suppressContentEditableWarning" && J !== "suppressHydrationWarning" && J !== "autoFocus" && (Pn.hasOwnProperty(J) ? s || (s = []) : (s = s || []).push(J, null)); for (J in n) { var D = n[J]; if (j = r != null ? r[J] : void 0, n.hasOwnProperty(J) && D !== j && (D != null || j != null)) if (J === "style") if (j) { for (g in j) !j.hasOwnProperty(g) || D && D.hasOwnProperty(g) || (i || (i = {}), i[g] = ""); for (g in D) D.hasOwnProperty(g) && j[g] !== D[g] && (i || (i = {}), i[g] = D[g]) } else i || (s || (s = []), s.push(J, i)), i = D; else J === "dangerouslySetInnerHTML" ? (D = D ? D.__html : void 0, j = j ? j.__html : void 0, D != null && j !== D && (s = s || []).push(J, D)) : J === "children" ? typeof D != "string" && typeof D != "number" || (s = s || []).push(J, "" + D) : J !== "suppressContentEditableWarning" && J !== "suppressHydrationWarning" && (Pn.hasOwnProperty(J) ? (D != null && J === "onScroll" && De("scroll", e), s || j === D || (s = [])) : (s = s || []).push(J, D)) } i && (s = s || []).push("style", i); var J = s; (t.updateQueue = J) && (t.flags |= 4) } }; Xu = function (e, t, i, n) { i !== n && (t.flags |= 4) }; function dn(e, t) { if (!ze) switch (e.tailMode) { case "hidden": t = e.tail; for (var i = null; t !== null;)t.alternate !== null && (i = t), t = t.sibling; i === null ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var n = null; i !== null;)i.alternate !== null && (n = i), i = i.sibling; n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null } } function Je(e) { var t = e.alternate !== null && e.alternate.child === e.child, i = 0, n = 0; if (t) for (var r = e.child; r !== null;)i |= r.lanes | r.childLanes, n |= r.subtreeFlags & 14680064, n |= r.flags & 14680064, r.return = e, r = r.sibling; else for (r = e.child; r !== null;)i |= r.lanes | r.childLanes, n |= r.subtreeFlags, n |= r.flags, r.return = e, r = r.sibling; return e.subtreeFlags |= n, e.childLanes = i, t } function vp(e, t, i) { var n = t.pendingProps; switch (hl(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Je(t), null; case 1: return ht(t.type) && Fr(), Je(t), null; case 3: return n = t.stateNode, Ji(), Ne(at), Ne(tt), xl(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (cr(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Et !== null && (Bo(Et), Et = null))), Lo(e, t), Je(t), null; case 5: yl(t); var r = vi(Fn.current); if (i = t.type, e !== null && t.stateNode != null) Gu(e, t, i, n, r), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!n) { if (t.stateNode === null) throw Error(xe(166)); return Je(t), null } if (e = vi(Rt.current), cr(t)) { n = t.stateNode, i = t.type; var s = t.memoizedProps; switch (n[zt] = t, n[Rn] = s, e = (t.mode & 1) !== 0, i) { case "dialog": De("cancel", n), De("close", n); break; case "iframe": case "object": case "embed": De("load", n); break; case "video": case "audio": for (r = 0; r < yn.length; r++)De(yn[r], n); break; case "source": De("error", n); break; case "img": case "image": case "link": De("error", n), De("load", n); break; case "details": De("toggle", n); break; case "input": Hl(n, s), De("invalid", n); break; case "select": n._wrapperState = { wasMultiple: !!s.multiple }, De("invalid", n); break; case "textarea": Gl(n, s), De("invalid", n) }io(i, s), r = null; for (var g in s) if (s.hasOwnProperty(g)) { var j = s[g]; g === "children" ? typeof j == "string" ? n.textContent !== j && (s.suppressHydrationWarning !== !0 && ur(n.textContent, j, e), r = ["children", j]) : typeof j == "number" && n.textContent !== "" + j && (s.suppressHydrationWarning !== !0 && ur(n.textContent, j, e), r = ["children", "" + j]) : Pn.hasOwnProperty(g) && j != null && g === "onScroll" && De("scroll", n) } switch (i) { case "input": ir(n), Ul(n, s, !0); break; case "textarea": ir(n), Xl(n); break; case "select": case "option": break; default: typeof s.onClick == "function" && (n.onclick = Br) }n = r, t.updateQueue = n, n !== null && (t.flags |= 4) } else { g = r.nodeType === 9 ? r : r.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = xh(i)), e === "http://www.w3.org/1999/xhtml" ? i === "script" ? (e = g.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof n.is == "string" ? e = g.createElement(i, { is: n.is }) : (e = g.createElement(i), i === "select" && (g = e, n.multiple ? g.multiple = !0 : n.size && (g.size = n.size))) : e = g.createElementNS(e, i), e[zt] = t, e[Rn] = n, Uu(e, t, !1, !1), t.stateNode = e; e: { switch (g = no(i, n), i) { case "dialog": De("cancel", e), De("close", e), r = n; break; case "iframe": case "object": case "embed": De("load", e), r = n; break; case "video": case "audio": for (r = 0; r < yn.length; r++)De(yn[r], e); r = n; break; case "source": De("error", e), r = n; break; case "img": case "image": case "link": De("error", e), De("load", e), r = n; break; case "details": De("toggle", e), r = n; break; case "input": Hl(e, n), r = Qs(e, n), De("invalid", e); break; case "option": r = n; break; case "select": e._wrapperState = { wasMultiple: !!n.multiple }, r = Be({}, n, { value: void 0 }), De("invalid", e); break; case "textarea": Gl(e, n), r = eo(e, n), De("invalid", e); break; default: r = n }io(i, r), j = r; for (s in j) if (j.hasOwnProperty(s)) { var D = j[s]; s === "style" ? kh(e, D) : s === "dangerouslySetInnerHTML" ? (D = D ? D.__html : void 0, D != null && vh(e, D)) : s === "children" ? typeof D == "string" ? (i !== "textarea" || D !== "") && En(e, D) : typeof D == "number" && En(e, "" + D) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Pn.hasOwnProperty(s) ? D != null && s === "onScroll" && De("scroll", e) : D != null && $o(e, s, D, g)) } switch (i) { case "input": ir(e), Ul(e, n, !1); break; case "textarea": ir(e), Xl(e); break; case "option": n.value != null && e.setAttribute("value", "" + hi(n.value)); break; case "select": e.multiple = !!n.multiple, s = n.value, s != null ? Ui(e, !!n.multiple, s, !1) : n.defaultValue != null && Ui(e, !!n.multiple, n.defaultValue, !0); break; default: typeof r.onClick == "function" && (e.onclick = Br) }switch (i) { case "button": case "input": case "select": case "textarea": n = !!n.autoFocus; break e; case "img": n = !0; break e; default: n = !1 } } n && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Je(t), null; case 6: if (e && t.stateNode != null) Xu(e, t, e.memoizedProps, n); else { if (typeof n != "string" && t.stateNode === null) throw Error(xe(166)); if (i = vi(Fn.current), vi(Rt.current), cr(t)) { if (n = t.stateNode, i = t.memoizedProps, n[zt] = t, (s = n.nodeValue !== i) && (e = gt, e !== null)) switch (e.tag) { case 3: ur(n.nodeValue, i, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && ur(n.nodeValue, i, (e.mode & 1) !== 0) }s && (t.flags |= 4) } else n = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(n), n[zt] = t, t.stateNode = n } return Je(t), null; case 13: if (Ne(Ie), n = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (ze && ft !== null && t.mode & 1 && !(t.flags & 128)) au(), Qi(), t.flags |= 98560, s = !1; else if (s = cr(t), n !== null && n.dehydrated !== null) { if (e === null) { if (!s) throw Error(xe(318)); if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(xe(317)); s[zt] = t } else Qi(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Je(t), s = !1 } else Et !== null && (Bo(Et), Et = null), s = !0; if (!s) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = i, t) : (n = n !== null, n !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192, t.mode & 1 && (e === null || Ie.current & 1 ? Xe === 0 && (Xe = 3) : Ll())), t.updateQueue !== null && (t.flags |= 4), Je(t), null); case 4: return Ji(), Lo(e, t), e === null && zn(t.stateNode.containerInfo), Je(t), null; case 10: return pl(t.type._context), Je(t), null; case 17: return ht(t.type) && Fr(), Je(t), null; case 19: if (Ne(Ie), s = t.memoizedState, s === null) return Je(t), null; if (n = (t.flags & 128) !== 0, g = s.rendering, g === null) if (n) dn(s, !1); else { if (Xe !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (g = Yr(e), g !== null) { for (t.flags |= 128, dn(s, !1), n = g.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), t.subtreeFlags = 0, n = i, i = t.child; i !== null;)s = i, e = n, s.flags &= 14680066, g = s.alternate, g === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = g.childLanes, s.lanes = g.lanes, s.child = g.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = g.memoizedProps, s.memoizedState = g.memoizedState, s.updateQueue = g.updateQueue, s.type = g.type, e = g.dependencies, s.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), i = i.sibling; return Oe(Ie, Ie.current & 1 | 2), t.child } e = e.sibling } s.tail !== null && _e() > tn && (t.flags |= 128, n = !0, dn(s, !1), t.lanes = 4194304) } else { if (!n) if (e = Yr(g), e !== null) { if (t.flags |= 128, n = !0, i = e.updateQueue, i !== null && (t.updateQueue = i, t.flags |= 4), dn(s, !0), s.tail === null && s.tailMode === "hidden" && !g.alternate && !ze) return Je(t), null } else 2 * _e() - s.renderingStartTime > tn && i !== 1073741824 && (t.flags |= 128, n = !0, dn(s, !1), t.lanes = 4194304); s.isBackwards ? (g.sibling = t.child, t.child = g) : (i = s.last, i !== null ? i.sibling = g : t.child = g, s.last = g) } return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = _e(), t.sibling = null, i = Ie.current, Oe(Ie, n ? i & 1 | 2 : i & 1), t) : (Je(t), null); case 22: case 23: return Al(), n = t.memoizedState !== null, e !== null && e.memoizedState !== null !== n && (t.flags |= 8192), n && t.mode & 1 ? pt & 1073741824 && (Je(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Je(t), null; case 24: return null; case 25: return null }throw Error(xe(156, t.tag)) } function Sp(e, t) { switch (hl(t), t.tag) { case 1: return ht(t.type) && Fr(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return Ji(), Ne(at), Ne(tt), xl(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return yl(t), null; case 13: if (Ne(Ie), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(xe(340)); Qi() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return Ne(Ie), null; case 4: return Ji(), null; case 10: return pl(t.type._context), null; case 22: case 23: return Al(), null; case 24: return null; default: return null } } var fr = !1, et = !1, kp = typeof WeakSet == "function" ? WeakSet : Set, Ce = null; function _i(e, t) { var i = e.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (n) { Fe(e, t, n) } else i.current = null } function Oo(e, t, i) { try { i() } catch (n) { Fe(e, t, n) } } var Na = !1; function wp(e, t) { if (fo = zr, e = Kh(), ll(e)) { if ("selectionStart" in e) var i = { start: e.selectionStart, end: e.selectionEnd }; else e: { i = (i = e.ownerDocument) && i.defaultView || window; var n = i.getSelection && i.getSelection(); if (n && n.rangeCount !== 0) { i = n.anchorNode; var r = n.anchorOffset, s = n.focusNode; n = n.focusOffset; try { i.nodeType, s.nodeType } catch { i = null; break e } var g = 0, j = -1, D = -1, J = 0, se = 0, $ = e, R = null; t: for (; ;) { for (var Q; $ !== i || r !== 0 && $.nodeType !== 3 || (j = g + r), $ !== s || n !== 0 && $.nodeType !== 3 || (D = g + n), $.nodeType === 3 && (g += $.nodeValue.length), (Q = $.firstChild) !== null;)R = $, $ = Q; for (; ;) { if ($ === e) break t; if (R === i && ++J === r && (j = g), R === s && ++se === n && (D = g), (Q = $.nextSibling) !== null) break; $ = R, R = $.parentNode } $ = Q } i = j === -1 || D === -1 ? null : { start: j, end: D } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (go = { focusedElem: e, selectionRange: i }, zr = !1, Ce = t; Ce !== null;)if (t = Ce, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, Ce = e; else for (; Ce !== null;) { t = Ce; try { var E = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (E !== null) { var I = E.memoizedProps, W = E.memoizedState, y = t.stateNode, a = y.getSnapshotBeforeUpdate(t.elementType === t.type ? I : Tt(t.type, I), W); y.__reactInternalSnapshotBeforeUpdate = a } break; case 3: var v = t.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(xe(163)) } } catch (k) { Fe(t, t.return, k) } if (e = t.sibling, e !== null) { e.return = t.return, Ce = e; break } Ce = t.return } return E = Na, Na = !1, E } function bn(e, t, i) { var n = t.updateQueue; if (n = n !== null ? n.lastEffect : null, n !== null) { var r = n = n.next; do { if ((r.tag & e) === e) { var s = r.destroy; r.destroy = void 0, s !== void 0 && Oo(t, i, s) } r = r.next } while (r !== n) } } function ds(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var i = t = t.next; do { if ((i.tag & e) === e) { var n = i.create; i.destroy = n() } i = i.next } while (i !== t) } } function jo(e) { var t = e.ref; if (t !== null) { var i = e.stateNode; switch (e.tag) { case 5: e = i; break; default: e = i }typeof t == "function" ? t(e) : t.current = e } } function Yu(e) { var t = e.alternate; t !== null && (e.alternate = null, Yu(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[zt], delete t[Rn], delete t[xo], delete t[rp], delete t[sp])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Vu(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function za(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Vu(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Do(e, t, i) { var n = e.tag; if (n === 5 || n === 6) e = e.stateNode, t ? i.nodeType === 8 ? i.parentNode.insertBefore(e, t) : i.insertBefore(e, t) : (i.nodeType === 8 ? (t = i.parentNode, t.insertBefore(e, i)) : (t = i, t.appendChild(e)), i = i._reactRootContainer, i != null || t.onclick !== null || (t.onclick = Br)); else if (n !== 4 && (e = e.child, e !== null)) for (Do(e, t, i), e = e.sibling; e !== null;)Do(e, t, i), e = e.sibling } function No(e, t, i) { var n = e.tag; if (n === 5 || n === 6) e = e.stateNode, t ? i.insertBefore(e, t) : i.appendChild(e); else if (n !== 4 && (e = e.child, e !== null)) for (No(e, t, i), e = e.sibling; e !== null;)No(e, t, i), e = e.sibling } var Ke = null, Pt = !1; function $t(e, t, i) { for (i = i.child; i !== null;)$u(e, t, i), i = i.sibling } function $u(e, t, i) { if (It && typeof It.onCommitFiberUnmount == "function") try { It.onCommitFiberUnmount(rs, i) } catch { } switch (i.tag) { case 5: et || _i(i, t); case 6: var n = Ke, r = Pt; Ke = null, $t(e, t, i), Ke = n, Pt = r, Ke !== null && (Pt ? (e = Ke, i = i.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i)) : Ke.removeChild(i.stateNode)); break; case 18: Ke !== null && (Pt ? (e = Ke, i = i.stateNode, e.nodeType === 8 ? zs(e.parentNode, i) : e.nodeType === 1 && zs(e, i), jn(e)) : zs(Ke, i.stateNode)); break; case 4: n = Ke, r = Pt, Ke = i.stateNode.containerInfo, Pt = !0, $t(e, t, i), Ke = n, Pt = r; break; case 0: case 11: case 14: case 15: if (!et && (n = i.updateQueue, n !== null && (n = n.lastEffect, n !== null))) { r = n = n.next; do { var s = r, g = s.destroy; s = s.tag, g !== void 0 && (s & 2 || s & 4) && Oo(i, t, g), r = r.next } while (r !== n) } $t(e, t, i); break; case 1: if (!et && (_i(i, t), n = i.stateNode, typeof n.componentWillUnmount == "function")) try { n.props = i.memoizedProps, n.state = i.memoizedState, n.componentWillUnmount() } catch (j) { Fe(i, t, j) } $t(e, t, i); break; case 21: $t(e, t, i); break; case 22: i.mode & 1 ? (et = (n = et) || i.memoizedState !== null, $t(e, t, i), et = n) : $t(e, t, i); break; default: $t(e, t, i) } } function Ia(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var i = e.stateNode; i === null && (i = e.stateNode = new kp), t.forEach(function (n) { var r = Op.bind(null, e, n); i.has(n) || (i.add(n), n.then(r, r)) }) } } function Mt(e, t) { var i = t.deletions; if (i !== null) for (var n = 0; n < i.length; n++) { var r = i[n]; try { var s = e, g = t, j = g; e: for (; j !== null;) { switch (j.tag) { case 5: Ke = j.stateNode, Pt = !1; break e; case 3: Ke = j.stateNode.containerInfo, Pt = !0; break e; case 4: Ke = j.stateNode.containerInfo, Pt = !0; break e }j = j.return } if (Ke === null) throw Error(xe(160)); $u(s, g, r), Ke = null, Pt = !1; var D = r.alternate; D !== null && (D.return = null), r.return = null } catch (J) { Fe(r, t, J) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)Ku(t, e), t = t.sibling } function Ku(e, t) { var i = e.alternate, n = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Mt(t, e), Dt(e), n & 4) { try { bn(3, e, e.return), ds(3, e) } catch (I) { Fe(e, e.return, I) } try { bn(5, e, e.return) } catch (I) { Fe(e, e.return, I) } } break; case 1: Mt(t, e), Dt(e), n & 512 && i !== null && _i(i, i.return); break; case 5: if (Mt(t, e), Dt(e), n & 512 && i !== null && _i(i, i.return), e.flags & 32) { var r = e.stateNode; try { En(r, "") } catch (I) { Fe(e, e.return, I) } } if (n & 4 && (r = e.stateNode, r != null)) { var s = e.memoizedProps, g = i !== null ? i.memoizedProps : s, j = e.type, D = e.updateQueue; if (e.updateQueue = null, D !== null) try { j === "input" && s.type === "radio" && s.name != null && mh(r, s), no(j, g); var J = no(j, s); for (g = 0; g < D.length; g += 2) { var se = D[g], $ = D[g + 1]; se === "style" ? kh(r, $) : se === "dangerouslySetInnerHTML" ? vh(r, $) : se === "children" ? En(r, $) : $o(r, se, $, J) } switch (j) { case "input": qs(r, s); break; case "textarea": yh(r, s); break; case "select": var R = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var Q = s.value; Q != null ? Ui(r, !!s.multiple, Q, !1) : R !== !!s.multiple && (s.defaultValue != null ? Ui(r, !!s.multiple, s.defaultValue, !0) : Ui(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[Rn] = s } catch (I) { Fe(e, e.return, I) } } break; case 6: if (Mt(t, e), Dt(e), n & 4) { if (e.stateNode === null) throw Error(xe(162)); r = e.stateNode, s = e.memoizedProps; try { r.nodeValue = s } catch (I) { Fe(e, e.return, I) } } break; case 3: if (Mt(t, e), Dt(e), n & 4 && i !== null && i.memoizedState.isDehydrated) try { jn(t.containerInfo) } catch (I) { Fe(e, e.return, I) } break; case 4: Mt(t, e), Dt(e); break; case 13: Mt(t, e), Dt(e), r = e.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (Pl = _e())), n & 4 && Ia(e); break; case 22: if (se = i !== null && i.memoizedState !== null, e.mode & 1 ? (et = (J = et) || se, Mt(t, e), et = J) : Mt(t, e), Dt(e), n & 8192) { if (J = e.memoizedState !== null, (e.stateNode.isHidden = J) && !se && e.mode & 1) for (Ce = e, se = e.child; se !== null;) { for ($ = Ce = se; Ce !== null;) { switch (R = Ce, Q = R.child, R.tag) { case 0: case 11: case 14: case 15: bn(4, R, R.return); break; case 1: _i(R, R.return); var E = R.stateNode; if (typeof E.componentWillUnmount == "function") { n = R, i = R.return; try { t = n, E.props = t.memoizedProps, E.state = t.memoizedState, E.componentWillUnmount() } catch (I) { Fe(n, i, I) } } break; case 5: _i(R, R.return); break; case 22: if (R.memoizedState !== null) { Ba($); continue } }Q !== null ? (Q.return = R, Ce = Q) : Ba($) } se = se.sibling } e: for (se = null, $ = e; ;) { if ($.tag === 5) { if (se === null) { se = $; try { r = $.stateNode, J ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (j = $.stateNode, D = $.memoizedProps.style, g = D != null && D.hasOwnProperty("display") ? D.display : null, j.style.display = Sh("display", g)) } catch (I) { Fe(e, e.return, I) } } } else if ($.tag === 6) { if (se === null) try { $.stateNode.nodeValue = J ? "" : $.memoizedProps } catch (I) { Fe(e, e.return, I) } } else if (($.tag !== 22 && $.tag !== 23 || $.memoizedState === null || $ === e) && $.child !== null) { $.child.return = $, $ = $.child; continue } if ($ === e) break e; for (; $.sibling === null;) { if ($.return === null || $.return === e) break e; se === $ && (se = null), $ = $.return } se === $ && (se = null), $.sibling.return = $.return, $ = $.sibling } } break; case 19: Mt(t, e), Dt(e), n & 4 && Ia(e); break; case 21: break; default: Mt(t, e), Dt(e) } } function Dt(e) { var t = e.flags; if (t & 2) { try { e: { for (var i = e.return; i !== null;) { if (Vu(i)) { var n = i; break e } i = i.return } throw Error(xe(160)) } switch (n.tag) { case 5: var r = n.stateNode; n.flags & 32 && (En(r, ""), n.flags &= -33); var s = za(e); No(e, s, r); break; case 3: case 4: var g = n.stateNode.containerInfo, j = za(e); Do(e, j, g); break; default: throw Error(xe(161)) } } catch (D) { Fe(e, e.return, D) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function Cp(e, t, i) { Ce = e, Zu(e) } function Zu(e, t, i) { for (var n = (e.mode & 1) !== 0; Ce !== null;) { var r = Ce, s = r.child; if (r.tag === 22 && n) { var g = r.memoizedState !== null || fr; if (!g) { var j = r.alternate, D = j !== null && j.memoizedState !== null || et; j = fr; var J = et; if (fr = g, (et = D) && !J) for (Ce = r; Ce !== null;)g = Ce, D = g.child, g.tag === 22 && g.memoizedState !== null ? Fa(r) : D !== null ? (D.return = g, Ce = D) : Fa(r); for (; s !== null;)Ce = s, Zu(s), s = s.sibling; Ce = r, fr = j, et = J } Ra(e) } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, Ce = s) : Ra(e) } } function Ra(e) { for (; Ce !== null;) { var t = Ce; if (t.flags & 8772) { var i = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: et || ds(5, t); break; case 1: var n = t.stateNode; if (t.flags & 4 && !et) if (i === null) n.componentDidMount(); else { var r = t.elementType === t.type ? i.memoizedProps : Tt(t.type, i.memoizedProps); n.componentDidUpdate(r, i.memoizedState, n.__reactInternalSnapshotBeforeUpdate) } var s = t.updateQueue; s !== null && Sa(t, s, n); break; case 3: var g = t.updateQueue; if (g !== null) { if (i = null, t.child !== null) switch (t.child.tag) { case 5: i = t.child.stateNode; break; case 1: i = t.child.stateNode }Sa(t, g, i) } break; case 5: var j = t.stateNode; if (i === null && t.flags & 4) { i = j; var D = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": D.autoFocus && i.focus(); break; case "img": D.src && (i.src = D.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var J = t.alternate; if (J !== null) { var se = J.memoizedState; if (se !== null) { var $ = se.dehydrated; $ !== null && jn($) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(xe(163)) }et || t.flags & 512 && jo(t) } catch (R) { Fe(t, t.return, R) } } if (t === e) { Ce = null; break } if (i = t.sibling, i !== null) { i.return = t.return, Ce = i; break } Ce = t.return } } function Ba(e) { for (; Ce !== null;) { var t = Ce; if (t === e) { Ce = null; break } var i = t.sibling; if (i !== null) { i.return = t.return, Ce = i; break } Ce = t.return } } function Fa(e) { for (; Ce !== null;) { var t = Ce; try { switch (t.tag) { case 0: case 11: case 15: var i = t.return; try { ds(4, t) } catch (D) { Fe(t, i, D) } break; case 1: var n = t.stateNode; if (typeof n.componentDidMount == "function") { var r = t.return; try { n.componentDidMount() } catch (D) { Fe(t, r, D) } } var s = t.return; try { jo(t) } catch (D) { Fe(t, s, D) } break; case 5: var g = t.return; try { jo(t) } catch (D) { Fe(t, g, D) } } } catch (D) { Fe(t, t.return, D) } if (t === e) { Ce = null; break } var j = t.sibling; if (j !== null) { j.return = t.return, Ce = j; break } Ce = t.return } } var bp = Math.ceil, Kr = Vt.ReactCurrentDispatcher, Ml = Vt.ReactCurrentOwner, wt = Vt.ReactCurrentBatchConfig, Ae = 0, Ve = null, He = null, Ze = 0, pt = 0, Hi = di(0), Xe = 0, Un = null, Ti = 0, ps = 0, Tl = 0, Mn = null, ot = null, Pl = 0, tn = 1 / 0, Bt = null, Zr = !1, zo = null, oi = null, gr = !1, ei = null, Qr = 0, Tn = 0, Io = null, Pr = -1, Er = 0; function nt() { return Ae & 6 ? _e() : Pr !== -1 ? Pr : Pr = _e() } function li(e) { return e.mode & 1 ? Ae & 2 && Ze !== 0 ? Ze & -Ze : lp.transition !== null ? (Er === 0 && (Er = Dh()), Er) : (e = Le, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Wh(e.type)), e) : 1 } function Lt(e, t, i, n) { if (50 < Tn) throw Tn = 0, Io = null, Error(xe(185)); Xn(e, i, n), (!(Ae & 2) || e !== Ve) && (e === Ve && (!(Ae & 2) && (ps |= i), Xe === 4 && qt(e, Ze)), ut(e, n), i === 1 && Ae === 0 && !(t.mode & 1) && (tn = _e() + 500, hs && pi())) } function ut(e, t) { var i = e.callbackNode; ld(e, t); var n = Nr(e, e === Ve ? Ze : 0); if (n === 0) i !== null && $l(i), e.callbackNode = null, e.callbackPriority = 0; else if (t = n & -n, e.callbackPriority !== t) { if (i != null && $l(i), t === 1) e.tag === 0 ? op(Wa.bind(null, e)) : su(Wa.bind(null, e)), ip(function () { !(Ae & 6) && pi() }), i = null; else { switch (Nh(n)) { case 1: i = Jo; break; case 4: i = Oh; break; case 16: i = Dr; break; case 536870912: i = jh; break; default: i = Dr }i = rc(i, Qu.bind(null, e)) } e.callbackPriority = t, e.callbackNode = i } } function Qu(e, t) { if (Pr = -1, Er = 0, Ae & 6) throw Error(xe(327)); var i = e.callbackNode; if ($i() && e.callbackNode !== i) return null; var n = Nr(e, e === Ve ? Ze : 0); if (n === 0) return null; if (n & 30 || n & e.expiredLanes || t) t = qr(e, n); else { t = n; var r = Ae; Ae |= 2; var s = Ju(); (Ve !== e || Ze !== t) && (Bt = null, tn = _e() + 500, ki(e, t)); do try { Pp(); break } catch (j) { qu(e, j) } while (!0); dl(), Kr.current = s, Ae = r, He !== null ? t = 0 : (Ve = null, Ze = 0, t = Xe) } if (t !== 0) { if (t === 2 && (r = ao(e), r !== 0 && (n = r, t = Ro(e, r))), t === 1) throw i = Un, ki(e, 0), qt(e, n), ut(e, _e()), i; if (t === 6) qt(e, n); else { if (r = e.current.alternate, !(n & 30) && !Mp(r) && (t = qr(e, n), t === 2 && (s = ao(e), s !== 0 && (n = s, t = Ro(e, s))), t === 1)) throw i = Un, ki(e, 0), qt(e, n), ut(e, _e()), i; switch (e.finishedWork = r, e.finishedLanes = n, t) { case 0: case 1: throw Error(xe(345)); case 2: mi(e, ot, Bt); break; case 3: if (qt(e, n), (n & 130023424) === n && (t = Pl + 500 - _e(), 10 < t)) { if (Nr(e, 0) !== 0) break; if (r = e.suspendedLanes, (r & n) !== n) { nt(), e.pingedLanes |= e.suspendedLanes & r; break } e.timeoutHandle = yo(mi.bind(null, e, ot, Bt), t); break } mi(e, ot, Bt); break; case 4: if (qt(e, n), (n & 4194240) === n) break; for (t = e.eventTimes, r = -1; 0 < n;) { var g = 31 - At(n); s = 1 << g, g = t[g], g > r && (r = g), n &= ~s } if (n = r, n = _e() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * bp(n / 1960)) - n, 10 < n) { e.timeoutHandle = yo(mi.bind(null, e, ot, Bt), n); break } mi(e, ot, Bt); break; case 5: mi(e, ot, Bt); break; default: throw Error(xe(329)) } } } return ut(e, _e()), e.callbackNode === i ? Qu.bind(null, e) : null } function Ro(e, t) { var i = Mn; return e.current.memoizedState.isDehydrated && (ki(e, t).flags |= 256), e = qr(e, t), e !== 2 && (t = ot, ot = i, t !== null && Bo(t)), e } function Bo(e) { ot === null ? ot = e : ot.push.apply(ot, e) } function Mp(e) { for (var t = e; ;) { if (t.flags & 16384) { var i = t.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var n = 0; n < i.length; n++) { var r = i[n], s = r.getSnapshot; r = r.value; try { if (!Ot(s(), r)) return !1 } catch { return !1 } } } if (i = t.child, t.subtreeFlags & 16384 && i !== null) i.return = t, t = i; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function qt(e, t) { for (t &= ~Tl, t &= ~ps, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var i = 31 - At(t), n = 1 << i; e[i] = -1, t &= ~n } } function Wa(e) { if (Ae & 6) throw Error(xe(327)); $i(); var t = Nr(e, 0); if (!(t & 1)) return ut(e, _e()), null; var i = qr(e, t); if (e.tag !== 0 && i === 2) { var n = ao(e); n !== 0 && (t = n, i = Ro(e, n)) } if (i === 1) throw i = Un, ki(e, 0), qt(e, t), ut(e, _e()), i; if (i === 6) throw Error(xe(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, mi(e, ot, Bt), ut(e, _e()), null } function El(e, t) { var i = Ae; Ae |= 1; try { return e(t) } finally { Ae = i, Ae === 0 && (tn = _e() + 500, hs && pi()) } } function Pi(e) { ei !== null && ei.tag === 0 && !(Ae & 6) && $i(); var t = Ae; Ae |= 1; var i = wt.transition, n = Le; try { if (wt.transition = null, Le = 1, e) return e() } finally { Le = n, wt.transition = i, Ae = t, !(Ae & 6) && pi() } } function Al() { pt = Hi.current, Ne(Hi) } function ki(e, t) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; if (i !== -1 && (e.timeoutHandle = -1, tp(i)), He !== null) for (i = He.return; i !== null;) { var n = i; switch (hl(n), n.tag) { case 1: n = n.type.childContextTypes, n != null && Fr(); break; case 3: Ji(), Ne(at), Ne(tt), xl(); break; case 5: yl(n); break; case 4: Ji(); break; case 13: Ne(Ie); break; case 19: Ne(Ie); break; case 10: pl(n.type._context); break; case 22: case 23: Al() }i = i.return } if (Ve = e, He = e = ai(e.current, null), Ze = pt = t, Xe = 0, Un = null, Tl = ps = Ti = 0, ot = Mn = null, xi !== null) { for (t = 0; t < xi.length; t++)if (i = xi[t], n = i.interleaved, n !== null) { i.interleaved = null; var r = n.next, s = i.pending; if (s !== null) { var g = s.next; s.next = r, n.next = g } i.pending = n } xi = null } return e } function qu(e, t) { do { var i = He; try { if (dl(), br.current = $r, Vr) { for (var n = Re.memoizedState; n !== null;) { var r = n.queue; r !== null && (r.pending = null), n = n.next } Vr = !1 } if (Mi = 0, Ye = Ge = Re = null, Cn = !1, Wn = 0, Ml.current = null, i === null || i.return === null) { Xe = 1, Un = t, He = null; break } e: { var s = e, g = i.return, j = i, D = t; if (t = Ze, j.flags |= 32768, D !== null && typeof D == "object" && typeof D.then == "function") { var J = D, se = j, $ = se.tag; if (!(se.mode & 1) && ($ === 0 || $ === 11 || $ === 15)) { var R = se.alternate; R ? (se.updateQueue = R.updateQueue, se.memoizedState = R.memoizedState, se.lanes = R.lanes) : (se.updateQueue = null, se.memoizedState = null) } var Q = Pa(g); if (Q !== null) { Q.flags &= -257, Ea(Q, g, j, s, t), Q.mode & 1 && Ta(s, J, t), t = Q, D = J; var E = t.updateQueue; if (E === null) { var I = new Set; I.add(D), t.updateQueue = I } else E.add(D); break e } else { if (!(t & 1)) { Ta(s, J, t), Ll(); break e } D = Error(xe(426)) } } else if (ze && j.mode & 1) { var W = Pa(g); if (W !== null) { !(W.flags & 65536) && (W.flags |= 256), Ea(W, g, j, s, t), ul(en(D, j)); break e } } s = D = en(D, j), Xe !== 4 && (Xe = 2), Mn === null ? Mn = [s] : Mn.push(s), s = g; do { switch (s.tag) { case 3: s.flags |= 65536, t &= -t, s.lanes |= t; var y = zu(s, D, t); va(s, y); break e; case 1: j = D; var a = s.type, v = s.stateNode; if (!(s.flags & 128) && (typeof a.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (oi === null || !oi.has(v)))) { s.flags |= 65536, t &= -t, s.lanes |= t; var k = Iu(s, j, t); va(s, k); break e } }s = s.return } while (s !== null) } tc(i) } catch (w) { t = w, He === i && i !== null && (He = i = i.return); continue } break } while (!0) } function Ju() { var e = Kr.current; return Kr.current = $r, e === null ? $r : e } function Ll() { (Xe === 0 || Xe === 3 || Xe === 2) && (Xe = 4), Ve === null || !(Ti & 268435455) && !(ps & 268435455) || qt(Ve, Ze) } function qr(e, t) { var i = Ae; Ae |= 2; var n = Ju(); (Ve !== e || Ze !== t) && (Bt = null, ki(e, t)); do try { Tp(); break } catch (r) { qu(e, r) } while (!0); if (dl(), Ae = i, Kr.current = n, He !== null) throw Error(xe(261)); return Ve = null, Ze = 0, Xe } function Tp() { for (; He !== null;)ec(He) } function Pp() { for (; He !== null && !qc();)ec(He) } function ec(e) { var t = nc(e.alternate, e, pt); e.memoizedProps = e.pendingProps, t === null ? tc(e) : He = t, Ml.current = null } function tc(e) { var t = e; do { var i = t.alternate; if (e = t.return, t.flags & 32768) { if (i = Sp(i, t), i !== null) { i.flags &= 32767, He = i; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Xe = 6, He = null; return } } else if (i = vp(i, t, pt), i !== null) { He = i; return } if (t = t.sibling, t !== null) { He = t; return } He = t = e } while (t !== null); Xe === 0 && (Xe = 5) } function mi(e, t, i) { var n = Le, r = wt.transition; try { wt.transition = null, Le = 1, Ep(e, t, i, n) } finally { wt.transition = r, Le = n } return null } function Ep(e, t, i, n) { do $i(); while (ei !== null); if (Ae & 6) throw Error(xe(327)); i = e.finishedWork; var r = e.finishedLanes; if (i === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, i === e.current) throw Error(xe(177)); e.callbackNode = null, e.callbackPriority = 0; var s = i.lanes | i.childLanes; if (ad(e, s), e === Ve && (He = Ve = null, Ze = 0), !(i.subtreeFlags & 2064) && !(i.flags & 2064) || gr || (gr = !0, rc(Dr, function () { return $i(), null })), s = (i.flags & 15990) !== 0, i.subtreeFlags & 15990 || s) { s = wt.transition, wt.transition = null; var g = Le; Le = 1; var j = Ae; Ae |= 4, Ml.current = null, wp(e, i), Ku(i, e), $d(go), zr = !!fo, go = fo = null, e.current = i, Cp(i), Jc(), Ae = j, Le = g, wt.transition = s } else e.current = i; if (gr && (gr = !1, ei = e, Qr = r), s = e.pendingLanes, s === 0 && (oi = null), id(i.stateNode), ut(e, _e()), t !== null) for (n = e.onRecoverableError, i = 0; i < t.length; i++)r = t[i], n(r.value, { componentStack: r.stack, digest: r.digest }); if (Zr) throw Zr = !1, e = zo, zo = null, e; return Qr & 1 && e.tag !== 0 && $i(), s = e.pendingLanes, s & 1 ? e === Io ? Tn++ : (Tn = 0, Io = e) : Tn = 0, pi(), null } function $i() { if (ei !== null) { var e = Nh(Qr), t = wt.transition, i = Le; try { if (wt.transition = null, Le = 16 > e ? 16 : e, ei === null) var n = !1; else { if (e = ei, ei = null, Qr = 0, Ae & 6) throw Error(xe(331)); var r = Ae; for (Ae |= 4, Ce = e.current; Ce !== null;) { var s = Ce, g = s.child; if (Ce.flags & 16) { var j = s.deletions; if (j !== null) { for (var D = 0; D < j.length; D++) { var J = j[D]; for (Ce = J; Ce !== null;) { var se = Ce; switch (se.tag) { case 0: case 11: case 15: bn(8, se, s) }var $ = se.child; if ($ !== null) $.return = se, Ce = $; else for (; Ce !== null;) { se = Ce; var R = se.sibling, Q = se.return; if (Yu(se), se === J) { Ce = null; break } if (R !== null) { R.return = Q, Ce = R; break } Ce = Q } } } var E = s.alternate; if (E !== null) { var I = E.child; if (I !== null) { E.child = null; do { var W = I.sibling; I.sibling = null, I = W } while (I !== null) } } Ce = s } } if (s.subtreeFlags & 2064 && g !== null) g.return = s, Ce = g; else e: for (; Ce !== null;) { if (s = Ce, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: bn(9, s, s.return) }var y = s.sibling; if (y !== null) { y.return = s.return, Ce = y; break e } Ce = s.return } } var a = e.current; for (Ce = a; Ce !== null;) { g = Ce; var v = g.child; if (g.subtreeFlags & 2064 && v !== null) v.return = g, Ce = v; else e: for (g = a; Ce !== null;) { if (j = Ce, j.flags & 2048) try { switch (j.tag) { case 0: case 11: case 15: ds(9, j) } } catch (w) { Fe(j, j.return, w) } if (j === g) { Ce = null; break e } var k = j.sibling; if (k !== null) { k.return = j.return, Ce = k; break e } Ce = j.return } } if (Ae = r, pi(), It && typeof It.onPostCommitFiberRoot == "function") try { It.onPostCommitFiberRoot(rs, e) } catch { } n = !0 } return n } finally { Le = i, wt.transition = t } } return !1 } function _a(e, t, i) { t = en(i, t), t = zu(e, t, 1), e = si(e, t, 1), t = nt(), e !== null && (Xn(e, 1, t), ut(e, t)) } function Fe(e, t, i) { if (e.tag === 3) _a(e, e, i); else for (; t !== null;) { if (t.tag === 3) { _a(t, e, i); break } else if (t.tag === 1) { var n = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (oi === null || !oi.has(n))) { e = en(i, e), e = Iu(t, e, 1), t = si(t, e, 1), e = nt(), t !== null && (Xn(t, 1, e), ut(t, e)); break } } t = t.return } } function Ap(e, t, i) { var n = e.pingCache; n !== null && n.delete(t), t = nt(), e.pingedLanes |= e.suspendedLanes & i, Ve === e && (Ze & i) === i && (Xe === 4 || Xe === 3 && (Ze & 130023424) === Ze && 500 > _e() - Pl ? ki(e, 0) : Tl |= i), ut(e, t) } function ic(e, t) { t === 0 && (e.mode & 1 ? (t = sr, sr <<= 1, !(sr & 130023424) && (sr = 4194304)) : t = 1); var i = nt(); e = Xt(e, t), e !== null && (Xn(e, t, i), ut(e, i)) } function Lp(e) { var t = e.memoizedState, i = 0; t !== null && (i = t.retryLane), ic(e, i) } function Op(e, t) { var i = 0; switch (e.tag) { case 13: var n = e.stateNode, r = e.memoizedState; r !== null && (i = r.retryLane); break; case 19: n = e.stateNode; break; default: throw Error(xe(314)) }n !== null && n.delete(t), ic(e, i) } var nc; nc = function (e, t, i) { if (e !== null) if (e.memoizedProps !== t.pendingProps || at.current) lt = !0; else { if (!(e.lanes & i) && !(t.flags & 128)) return lt = !1, xp(e, t, i); lt = !!(e.flags & 131072) } else lt = !1, ze && t.flags & 1048576 && ou(t, Hr, t.index); switch (t.lanes = 0, t.tag) { case 2: var n = t.type; Tr(e, t), e = t.pendingProps; var r = Zi(t, tt.current); Vi(t, i), r = Sl(null, t, n, e, r, i); var s = kl(); return t.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ht(n) ? (s = !0, Wr(t)) : s = !1, t.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, gl(t), r.updater = us, t.stateNode = r, r._reactInternals = t, bo(t, n, e, i), t = Po(null, t, n, !0, s, i)) : (t.tag = 0, ze && s && al(t), it(null, t, r, i), t = t.child), t; case 16: n = t.elementType; e: { switch (Tr(e, t), e = t.pendingProps, r = n._init, n = r(n._payload), t.type = n, r = t.tag = Dp(n), e = Tt(n, e), r) { case 0: t = To(null, t, n, e, i); break e; case 1: t = Oa(null, t, n, e, i); break e; case 11: t = Aa(null, t, n, e, i); break e; case 14: t = La(null, t, n, Tt(n.type, e), i); break e }throw Error(xe(306, n, "")) } return t; case 0: return n = t.type, r = t.pendingProps, r = t.elementType === n ? r : Tt(n, r), To(e, t, n, r, i); case 1: return n = t.type, r = t.pendingProps, r = t.elementType === n ? r : Tt(n, r), Oa(e, t, n, r, i); case 3: e: { if (Wu(t), e === null) throw Error(xe(387)); n = t.pendingProps, s = t.memoizedState, r = s.element, uu(e, t), Xr(t, n, null, i); var g = t.memoizedState; if (n = g.element, s.isDehydrated) if (s = { element: n, isDehydrated: !1, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) { r = en(Error(xe(423)), t), t = ja(e, t, n, i, r); break e } else if (n !== r) { r = en(Error(xe(424)), t), t = ja(e, t, n, i, r); break e } else for (ft = ri(t.stateNode.containerInfo.firstChild), gt = t, ze = !0, Et = null, i = fu(t, null, n, i), t.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (Qi(), n === r) { t = Yt(e, t, i); break e } it(e, t, n, i) } t = t.child } return t; case 5: return gu(t), e === null && ko(t), n = t.type, r = t.pendingProps, s = e !== null ? e.memoizedProps : null, g = r.children, mo(n, r) ? g = null : s !== null && mo(n, s) && (t.flags |= 32), Fu(e, t), it(e, t, g, i), t.child; case 6: return e === null && ko(t), null; case 13: return _u(e, t, i); case 4: return ml(t, t.stateNode.containerInfo), n = t.pendingProps, e === null ? t.child = qi(t, null, n, i) : it(e, t, n, i), t.child; case 11: return n = t.type, r = t.pendingProps, r = t.elementType === n ? r : Tt(n, r), Aa(e, t, n, r, i); case 7: return it(e, t, t.pendingProps, i), t.child; case 8: return it(e, t, t.pendingProps.children, i), t.child; case 12: return it(e, t, t.pendingProps.children, i), t.child; case 10: e: { if (n = t.type._context, r = t.pendingProps, s = t.memoizedProps, g = r.value, Oe(Ur, n._currentValue), n._currentValue = g, s !== null) if (Ot(s.value, g)) { if (s.children === r.children && !at.current) { t = Yt(e, t, i); break e } } else for (s = t.child, s !== null && (s.return = t); s !== null;) { var j = s.dependencies; if (j !== null) { g = s.child; for (var D = j.firstContext; D !== null;) { if (D.context === n) { if (s.tag === 1) { D = Ht(-1, i & -i), D.tag = 2; var J = s.updateQueue; if (J !== null) { J = J.shared; var se = J.pending; se === null ? D.next = D : (D.next = se.next, se.next = D), J.pending = D } } s.lanes |= i, D = s.alternate, D !== null && (D.lanes |= i), wo(s.return, i, t), j.lanes |= i; break } D = D.next } } else if (s.tag === 10) g = s.type === t.type ? null : s.child; else if (s.tag === 18) { if (g = s.return, g === null) throw Error(xe(341)); g.lanes |= i, j = g.alternate, j !== null && (j.lanes |= i), wo(g, i, t), g = s.sibling } else g = s.child; if (g !== null) g.return = s; else for (g = s; g !== null;) { if (g === t) { g = null; break } if (s = g.sibling, s !== null) { s.return = g.return, g = s; break } g = g.return } s = g } it(e, t, r.children, i), t = t.child } return t; case 9: return r = t.type, n = t.pendingProps.children, Vi(t, i), r = Ct(r), n = n(r), t.flags |= 1, it(e, t, n, i), t.child; case 14: return n = t.type, r = Tt(n, t.pendingProps), r = Tt(n.type, r), La(e, t, n, r, i); case 15: return Ru(e, t, t.type, t.pendingProps, i); case 17: return n = t.type, r = t.pendingProps, r = t.elementType === n ? r : Tt(n, r), Tr(e, t), t.tag = 1, ht(n) ? (e = !0, Wr(t)) : e = !1, Vi(t, i), du(t, n, r), bo(t, n, r, i), Po(null, t, n, !0, e, i); case 19: return Hu(e, t, i); case 22: return Bu(e, t, i) }throw Error(xe(156, t.tag)) }; function rc(e, t) { return Lh(e, t) } function jp(e, t, i, n) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function kt(e, t, i, n) { return new jp(e, t, i, n) } function Ol(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Dp(e) { if (typeof e == "function") return Ol(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Zo) return 11; if (e === Qo) return 14 } return 2 } function ai(e, t) { var i = e.alternate; return i === null ? (i = kt(e.tag, t, e.key, e.mode), i.elementType = e.elementType, i.type = e.type, i.stateNode = e.stateNode, i.alternate = e, e.alternate = i) : (i.pendingProps = t, i.type = e.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = e.flags & 14680064, i.childLanes = e.childLanes, i.lanes = e.lanes, i.child = e.child, i.memoizedProps = e.memoizedProps, i.memoizedState = e.memoizedState, i.updateQueue = e.updateQueue, t = e.dependencies, i.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, i.sibling = e.sibling, i.index = e.index, i.ref = e.ref, i } function Ar(e, t, i, n, r, s) { var g = 2; if (n = e, typeof e == "function") Ol(e) && (g = 1); else if (typeof e == "string") g = 5; else e: switch (e) { case ji: return wi(i.children, r, s, t); case Ko: g = 8, r |= 8; break; case Vs: return e = kt(12, i, t, r | 2), e.elementType = Vs, e.lanes = s, e; case $s: return e = kt(13, i, t, r), e.elementType = $s, e.lanes = s, e; case Ks: return e = kt(19, i, t, r), e.elementType = Ks, e.lanes = s, e; case ph: return fs(i, r, s, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case ch: g = 10; break e; case dh: g = 9; break e; case Zo: g = 11; break e; case Qo: g = 14; break e; case Kt: g = 16, n = null; break e }throw Error(xe(130, e == null ? e : typeof e, "")) }return t = kt(g, i, t, r), t.elementType = e, t.type = n, t.lanes = s, t } function wi(e, t, i, n) { return e = kt(7, e, n, t), e.lanes = i, e } function fs(e, t, i, n) { return e = kt(22, e, n, t), e.elementType = ph, e.lanes = i, e.stateNode = { isHidden: !1 }, e } function Us(e, t, i) { return e = kt(6, e, null, t), e.lanes = i, e } function Gs(e, t, i) { return t = kt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = i, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Np(e, t, i, n, r) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = bs(0), this.expirationTimes = bs(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = bs(0), this.identifierPrefix = n, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function jl(e, t, i, n, r, s, g, j, D) { return e = new Np(e, t, i, j, D), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = kt(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: n, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, gl(s), e } function zp(e, t, i) { var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Oi, key: n == null ? null : "" + n, children: e, containerInfo: t, implementation: i } } function sc(e) { if (!e) return ui; e = e._reactInternals; e: { if (Ai(e) !== e || e.tag !== 1) throw Error(xe(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (ht(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(xe(171)) } if (e.tag === 1) { var i = e.type; if (ht(i)) return ru(e, i, t) } return t } function oc(e, t, i, n, r, s, g, j, D) { return e = jl(i, n, !0, e, r, s, g, j, D), e.context = sc(null), i = e.current, n = nt(), r = li(i), s = Ht(n, r), s.callback = t ?? null, si(i, s, r), e.current.lanes = r, Xn(e, r, n), ut(e, n), e } function gs(e, t, i, n) { var r = t.current, s = nt(), g = li(r); return i = sc(i), t.context === null ? t.context = i : t.pendingContext = i, t = Ht(s, g), t.payload = { element: e }, n = n === void 0 ? null : n, n !== null && (t.callback = n), e = si(r, t, g), e !== null && (Lt(e, r, g, s), Cr(e, r, g)), g } function Jr(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Ha(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var i = e.retryLane; e.retryLane = i !== 0 && i < t ? i : t } } function Dl(e, t) { Ha(e, t), (e = e.alternate) && Ha(e, t) } function Ip() { return null } var lc = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Nl(e) { this._internalRoot = e } ms.prototype.render = Nl.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(xe(409)); gs(e, t, null, null) }; ms.prototype.unmount = Nl.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Pi(function () { gs(null, e, null, null) }), t[Gt] = null } }; function ms(e) { this._internalRoot = e } ms.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Rh(); e = { blockedOn: null, target: e, priority: t }; for (var i = 0; i < Qt.length && t !== 0 && t < Qt[i].priority; i++); Qt.splice(i, 0, e), i === 0 && Fh(e) } }; function zl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function ys(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Ua() { } function Rp(e, t, i, n, r) { if (r) { if (typeof n == "function") { var s = n; n = function () { var J = Jr(g); s.call(J) } } var g = oc(t, n, e, 0, null, !1, !1, "", Ua); return e._reactRootContainer = g, e[Gt] = g.current, zn(e.nodeType === 8 ? e.parentNode : e), Pi(), g } for (; r = e.lastChild;)e.removeChild(r); if (typeof n == "function") { var j = n; n = function () { var J = Jr(D); j.call(J) } } var D = jl(e, 0, !1, null, null, !1, !1, "", Ua); return e._reactRootContainer = D, e[Gt] = D.current, zn(e.nodeType === 8 ? e.parentNode : e), Pi(function () { gs(t, D, i, n) }), D } function xs(e, t, i, n, r) { var s = i._reactRootContainer; if (s) { var g = s; if (typeof r == "function") { var j = r; r = function () { var D = Jr(g); j.call(D) } } gs(t, g, e, r) } else g = Rp(i, t, e, r, n); return Jr(g) } zh = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var i = mn(t.pendingLanes); i !== 0 && (el(t, i | 1), ut(t, _e()), !(Ae & 6) && (tn = _e() + 500, pi())) } break; case 13: Pi(function () { var n = Xt(e, 1); if (n !== null) { var r = nt(); Lt(n, e, 1, r) } }), Dl(e, 1) } }; tl = function (e) { if (e.tag === 13) { var t = Xt(e, 134217728); if (t !== null) { var i = nt(); Lt(t, e, 134217728, i) } Dl(e, 134217728) } }; Ih = function (e) { if (e.tag === 13) { var t = li(e), i = Xt(e, t); if (i !== null) { var n = nt(); Lt(i, e, t, n) } Dl(e, t) } }; Rh = function () { return Le }; Bh = function (e, t) { var i = Le; try { return Le = e, t() } finally { Le = i } }; so = function (e, t, i) { switch (t) { case "input": if (qs(e, i), t = i.name, i.type === "radio" && t != null) { for (i = e; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < i.length; t++) { var n = i[t]; if (n !== e && n.form === e.form) { var r = as(n); if (!r) throw Error(xe(90)); gh(n), qs(n, r) } } } break; case "textarea": yh(e, i); break; case "select": t = i.value, t != null && Ui(e, !!i.multiple, t, !1) } }; bh = El; Mh = Pi; var Bp = { usingClientEntryPoint: !1, Events: [Vn, Ii, as, wh, Ch, El] }, pn = { findFiberByHostInstance: yi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Fp = { bundleType: pn.bundleType, version: pn.version, rendererPackageName: pn.rendererPackageName, rendererConfig: pn.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Vt.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Eh(e), e === null ? null : e.stateNode }, findFiberByHostInstance: pn.findFiberByHostInstance || Ip, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var mr = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!mr.isDisabled && mr.supportsFiber) try { rs = mr.inject(Fp), It = mr } catch { } } yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Bp; yt.createPortal = function (e, t) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!zl(t)) throw Error(xe(200)); return zp(e, t, null, i) }; yt.createRoot = function (e, t) { if (!zl(e)) throw Error(xe(299)); var i = !1, n = "", r = lc; return t != null && (t.unstable_strictMode === !0 && (i = !0), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onRecoverableError !== void 0 && (r = t.onRecoverableError)), t = jl(e, 1, !1, null, null, i, !1, n, r), e[Gt] = t.current, zn(e.nodeType === 8 ? e.parentNode : e), new Nl(t) }; yt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(xe(188)) : (e = Object.keys(e).join(","), Error(xe(268, e))); return e = Eh(t), e = e === null ? null : e.stateNode, e }; yt.flushSync = function (e) { return Pi(e) }; yt.hydrate = function (e, t, i) { if (!ys(t)) throw Error(xe(200)); return xs(null, e, t, !0, i) }; yt.hydrateRoot = function (e, t, i) { if (!zl(e)) throw Error(xe(405)); var n = i != null && i.hydratedSources || null, r = !1, s = "", g = lc; if (i != null && (i.unstable_strictMode === !0 && (r = !0), i.identifierPrefix !== void 0 && (s = i.identifierPrefix), i.onRecoverableError !== void 0 && (g = i.onRecoverableError)), t = oc(t, null, e, 1, i ?? null, r, !1, s, g), e[Gt] = t.current, zn(e), n) for (e = 0; e < n.length; e++)i = n[e], r = i._getVersion, r = r(i._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [i, r] : t.mutableSourceEagerHydrationData.push(i, r); return new ms(t) }; yt.render = function (e, t, i) { if (!ys(t)) throw Error(xe(200)); return xs(null, e, t, !1, i) }; yt.unmountComponentAtNode = function (e) { if (!ys(e)) throw Error(xe(40)); return e._reactRootContainer ? (Pi(function () { xs(null, null, e, !1, function () { e._reactRootContainer = null, e[Gt] = null }) }), !0) : !1 }; yt.unstable_batchedUpdates = El; yt.unstable_renderSubtreeIntoContainer = function (e, t, i, n) { if (!ys(i)) throw Error(xe(200)); if (e == null || e._reactInternals === void 0) throw Error(xe(38)); return xs(e, t, i, !1, n) }; yt.version = "18.2.0-next-9e3b772b8-20220608"; function ac() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ac) } catch (e) { console.error(e) } } ac(), oh.exports = yt; var Wp = oh.exports, hc, Ga = Wp; hc = Ga.createRoot, Ga.hydrateRoot; var uc = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, Xa = Si.createContext && Si.createContext(uc), _p = ["attr", "size", "title"]; function Hp(e, t) { if (e == null) return {}; var i = Up(e, t), n, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)n = s[r], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } function Up(e, t) { if (e == null) return {}; var i = {}, n = Object.keys(e), r, s; for (s = 0; s < n.length; s++)r = n[s], !(t.indexOf(r) >= 0) && (i[r] = e[r]); return i } function es() { return es = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]) } return e }, es.apply(this, arguments) } function Ya(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable })), i.push.apply(i, n) } return i } function ts(e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t] != null ? arguments[t] : {}; t % 2 ? Ya(Object(i), !0).forEach(function (n) { Gp(e, n, i[n]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Ya(Object(i)).forEach(function (n) { Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(i, n)) }) } return e } function Gp(e, t, i) { return t = Xp(t), t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function Xp(e) { var t = Yp(e, "string"); return typeof t == "symbol" ? t : String(t) } function Yp(e, t) { if (typeof e != "object" || e === null) return e; var i = e[Symbol.toPrimitive]; if (i !== void 0) { var n = i.call(e, t || "default"); if (typeof n != "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } function cc(e) { return e && e.map((t, i) => Si.createElement(t.tag, ts({ key: i }, t.attr), cc(t.child))) } function fi(e) { return t => Si.createElement(Vp, es({ attr: ts({}, e.attr) }, t), cc(e.child)) } function Vp(e) { var t = i => { var { attr: n, size: r, title: s } = e, g = Hp(e, _p), j = r || i.size || "1em", D; return i.className && (D = i.className), e.className && (D = (D ? D + " " : "") + e.className), Si.createElement("svg", es({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, i.attr, n, g, { className: D, style: ts(ts({ color: e.color || i.color }, i.style), e.style), height: j, width: j, xmlns: "http://www.w3.org/2000/svg" }), s && Si.createElement("title", null, s), e.children) }; return Xa !== void 0 ? Si.createElement(Xa.Consumer, null, i => t(i)) : t(uc) } function $p(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z" }, child: [] }] })(e) } function Kp(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M12.97 2.59a1.5 1.5 0 0 0-1.94 0l-7.5 6.363A1.5 1.5 0 0 0 3 10.097V19.5A1.5 1.5 0 0 0 4.5 21h4.75a.75.75 0 0 0 .75-.75V14h4v6.25c0 .414.336.75.75.75h4.75a1.5 1.5 0 0 0 1.5-1.5v-9.403a1.5 1.5 0 0 0-.53-1.144l-7.5-6.363Z" }, child: [] }] })(e) } function Zp(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M200,152a31.84,31.84,0,0,0-19.53,6.68l-23.11-18A31.65,31.65,0,0,0,160,128c0-.74,0-1.48-.08-2.21l13.23-4.41A32,32,0,1,0,168,104c0,.74,0,1.48.08,2.21l-13.23,4.41A32,32,0,0,0,128,96a32.59,32.59,0,0,0-5.27.44L115.89,81A32,32,0,1,0,96,88a32.59,32.59,0,0,0,5.27-.44l6.84,15.4a31.92,31.92,0,0,0-8.57,39.64L73.83,165.44a32.06,32.06,0,1,0,10.63,12l25.71-22.84a31.91,31.91,0,0,0,37.36-1.24l23.11,18A31.65,31.65,0,0,0,168,184a32,32,0,1,0,32-32Zm0-64a16,16,0,1,1-16,16A16,16,0,0,1,200,88ZM80,56A16,16,0,1,1,96,72,16,16,0,0,1,80,56ZM56,208a16,16,0,1,1,16-16A16,16,0,0,1,56,208Zm144-8a16,16,0,1,1,16-16A16,16,0,0,1,200,200Z" }, child: [] }] })(e) } function Qp(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M200,152a31.84,31.84,0,0,0-19.53,6.68l-23.11-18A31.65,31.65,0,0,0,160,128c0-.74,0-1.48-.08-2.21l13.23-4.41A32,32,0,1,0,168,104c0,.74,0,1.48.08,2.21l-13.23,4.41A32,32,0,0,0,128,96a32.59,32.59,0,0,0-5.27.44L115.89,81A32,32,0,1,0,96,88a32.59,32.59,0,0,0,5.27-.44l6.84,15.4a31.92,31.92,0,0,0-8.57,39.64L73.83,165.44a32.06,32.06,0,1,0,10.63,12l25.71-22.84a31.91,31.91,0,0,0,37.36-1.24l23.11,18A31.65,31.65,0,0,0,168,184a32,32,0,1,0,32-32Zm0-64a16,16,0,1,1-16,16A16,16,0,0,1,200,88ZM80,56A16,16,0,1,1,96,72,16,16,0,0,1,80,56ZM56,208a16,16,0,1,1,16-16A16,16,0,0,1,56,208Zm56-80a16,16,0,1,1,16,16A16,16,0,0,1,112,128Zm88,72a16,16,0,1,1,16-16A16,16,0,0,1,200,200Z" }, child: [] }] })(e) } function qp(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "rect", attr: { width: "176", height: "176", x: "48", y: "48", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", rx: "20", ry: "20" }, child: [] }, { tag: "rect", attr: { width: "176", height: "176", x: "288", y: "48", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", rx: "20", ry: "20" }, child: [] }, { tag: "rect", attr: { width: "176", height: "176", x: "48", y: "288", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", rx: "20", ry: "20" }, child: [] }, { tag: "rect", attr: { width: "176", height: "176", x: "288", y: "288", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", rx: "20", ry: "20" }, child: [] }] })(e) } function Jp(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M204 240H68a36 36 0 0 1-36-36V68a36 36 0 0 1 36-36h136a36 36 0 0 1 36 36v136a36 36 0 0 1-36 36zm240 0H308a36 36 0 0 1-36-36V68a36 36 0 0 1 36-36h136a36 36 0 0 1 36 36v136a36 36 0 0 1-36 36zM204 480H68a36 36 0 0 1-36-36V308a36 36 0 0 1 36-36h136a36 36 0 0 1 36 36v136a36 36 0 0 1-36 36zm240 0H308a36 36 0 0 1-36-36V308a36 36 0 0 1 36-36h136a36 36 0 0 1 36 36v136a36 36 0 0 1-36 36z" }, child: [] }] })(e) } function ef(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M262.29 192.31a64 64 0 1 0 57.4 57.4 64.13 64.13 0 0 0-57.4-57.4zM416.39 256a154.34 154.34 0 0 1-1.53 20.79l45.21 35.46a10.81 10.81 0 0 1 2.45 13.75l-42.77 74a10.81 10.81 0 0 1-13.14 4.59l-44.9-18.08a16.11 16.11 0 0 0-15.17 1.75A164.48 164.48 0 0 1 325 400.8a15.94 15.94 0 0 0-8.82 12.14l-6.73 47.89a11.08 11.08 0 0 1-10.68 9.17h-85.54a11.11 11.11 0 0 1-10.69-8.87l-6.72-47.82a16.07 16.07 0 0 0-9-12.22 155.3 155.3 0 0 1-21.46-12.57 16 16 0 0 0-15.11-1.71l-44.89 18.07a10.81 10.81 0 0 1-13.14-4.58l-42.77-74a10.8 10.8 0 0 1 2.45-13.75l38.21-30a16.05 16.05 0 0 0 6-14.08c-.36-4.17-.58-8.33-.58-12.5s.21-8.27.58-12.35a16 16 0 0 0-6.07-13.94l-38.19-30A10.81 10.81 0 0 1 49.48 186l42.77-74a10.81 10.81 0 0 1 13.14-4.59l44.9 18.08a16.11 16.11 0 0 0 15.17-1.75A164.48 164.48 0 0 1 187 111.2a15.94 15.94 0 0 0 8.82-12.14l6.73-47.89A11.08 11.08 0 0 1 213.23 42h85.54a11.11 11.11 0 0 1 10.69 8.87l6.72 47.82a16.07 16.07 0 0 0 9 12.22 155.3 155.3 0 0 1 21.46 12.57 16 16 0 0 0 15.11 1.71l44.89-18.07a10.81 10.81 0 0 1 13.14 4.58l42.77 74a10.8 10.8 0 0 1-2.45 13.75l-38.21 30a16.05 16.05 0 0 0-6.05 14.08c.33 4.14.55 8.3.55 12.47z" }, child: [] }] })(e) } function tf(e) { return fi({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 176a80 80 0 1 0 80 80 80.24 80.24 0 0 0-80-80zm172.72 80a165.53 165.53 0 0 1-1.64 22.34l48.69 38.12a11.59 11.59 0 0 1 2.63 14.78l-46.06 79.52a11.64 11.64 0 0 1-14.14 4.93l-57.25-23a176.56 176.56 0 0 1-38.82 22.67l-8.56 60.78a11.93 11.93 0 0 1-11.51 9.86h-92.12a12 12 0 0 1-11.51-9.53l-8.56-60.78A169.3 169.3 0 0 1 151.05 393L93.8 416a11.64 11.64 0 0 1-14.14-4.92L33.6 331.57a11.59 11.59 0 0 1 2.63-14.78l48.69-38.12A174.58 174.58 0 0 1 83.28 256a165.53 165.53 0 0 1 1.64-22.34l-48.69-38.12a11.59 11.59 0 0 1-2.63-14.78l46.06-79.52a11.64 11.64 0 0 1 14.14-4.93l57.25 23a176.56 176.56 0 0 1 38.82-22.67l8.56-60.78A11.93 11.93 0 0 1 209.94 26h92.12a12 12 0 0 1 11.51 9.53l8.56 60.78A169.3 169.3 0 0 1 361 119l57.2-23a11.64 11.64 0 0 1 14.14 4.92l46.06 79.52a11.59 11.59 0 0 1-2.63 14.78l-48.69 38.12a174.58 174.58 0 0 1 1.64 22.66z" }, child: [] }] })(e) } function Fo(...e) { return e.filter(Boolean).join(" ") } const is = ({ className: e, children: t }) => ve.jsx("div", { className: Fo("bg-foreground rounded-2xl shadow-card p-8", e), children: t }), nf = "" + new URL("../images/final_assem_top.png", import.meta.url).href, rf = "" + new URL("../images/final_assem_top_trans.png", import.meta.url).href, sf = ({ type: e, id: t, value: i, color: n, position: r }) => { const [s, g] = We.useState(!1); return ve.jsxs("div", { className: "z-[100] py-2 px-3 h-10 absolute cursor-default rounded-full font-semibold transition-all duration-200", style: { top: `${r.y}%`, left: `${r.x}%` }, onMouseEnter: () => g(!0), onMouseLeave: () => g(!1), children: [ve.jsx("div", { className: "z-[1] top-0 absolute rounded-full", style: { width: "40px", height: "100%", background: n ?? "#000" } }), ve.jsx("div", { className: "z-[0] bg-foreground-3 top-0 absolute rounded-full transition-all duration-200", style: { width: s ? "125px" : "40px", height: "100%" } }), ve.jsxs("span", { className: "z-[2] absolute left-7 top-0 w-[125px] h-full flex gap-6 items-center justify-start text-white", children: [t, ve.jsxs("span", { className: "relative text-black", style: { opacity: s ? 1 : 0, transition: "opacity 200ms ease-in-out" }, children: [i, " ", e === "flow" ? "l/min" : "kPa"] })] })] }) }; function of(e) { return e.charAt(0).toUpperCase() + e.slice(1) } const yr = { top: { flow: [{ id: 1, value: 42 }, { id: 2, value: 42 }, { id: 3, value: 42 }, { id: 4, value: 42 }], pressure: [{ id: 1, value: 200 }, { id: 2, value: 200 }, { id: 3, value: 200 }, { id: 4, value: 200 }] }, bottom: { flow: [{ id: 1, value: 42 }, { id: 2, value: 42 }, { id: 3, value: 42 }, { id: 4, value: 42 }], pressure: [{ id: 1, value: 200 }, { id: 2, value: 200 }, { id: 3, value: 200 }, { id: 4, value: 200 }] } }, Xs = { top: { flow: { 1: { x: 6.5, y: -15 } }, pressure: { 1: { x: -11.5, y: 16.5 } } }, bottom: { flow: { 1: { x: 15, y: -15 } }, pressure: {} } }, lf = () => { const e = "relative min-w-[600px]", t = "relative my-16 w-[500px] mx-auto", [i, n] = We.useState(window.innerWidth < 655), [r, s] = We.useState(void 0), [g, j] = We.useState(void 0); async function D(R, Q, E, I) { if (!Xs[R][I][E.id]) { console.warn(`No position found for sensor ${E.id} of type ${I}`); return } Q.push({ type: I, id: E.id, value: Number(Object.values(E)[E.id]), color: `hsl(${Math.floor(Math.random() * 360)}, 100%, 50%)`, position: Xs[R][I][E.id] }) } async function J() { const R = [], Q = []; yr.top.flow.forEach(E => D("top", R, E, "flow")), yr.top.pressure.forEach(E => D("top", R, E, "pressure")), yr.bottom.flow.forEach(E => D("bottom", Q, E, "flow")), yr.bottom.pressure.forEach(E => D("bottom", Q, E, "pressure")), s(R), j(Q) } We.useEffect(() => { J(); const R = () => { n(window.innerWidth < 655) }; return window.addEventListener("resize", R), () => { window.removeEventListener("resize", R) } }, []); function se(R) { return R.map(Q => (Xs.top[Q.type][Q.id], ve.jsx(sf, { ...Q }, `${Q.id}_${Q.type}`))) } function $(R) { return R.map(Q => ve.jsxs("p", { className: "flex items-center gap-2", children: [ve.jsx("div", { style: { width: "8px", height: "8px", background: Q.color, borderRadius: "100%" } }), of(Q.type), " Sensor ", Q.id] }, `${Q.id}_${Q.type}`)) } return ve.jsxs(We.Fragment, { children: [ve.jsx("h1", { className: "page-title", children: "Image views" }), ve.jsx("div", { className: "content-container", children: i ? ve.jsx("p", { children: "This content is not available on this resolution." }) : ve.jsxs(ve.Fragment, { children: [ve.jsxs(is, { className: e, children: [ve.jsx("h1", { className: "card-title", children: "Top layer" }), ve.jsxs("div", { className: t, children: [ve.jsx("img", { src: nf, className: "w-full h-full", alt: "Top layer" }), se(r ?? [])] }), ve.jsx("div", { className: "flex flex-col text-sm", children: $(r ?? []) })] }), ve.jsxs(is, { className: e, children: [ve.jsx("h1", { className: "card-title", children: "Bottom layer" }), ve.jsxs("div", { className: t, children: [ve.jsx("img", { src: rf, className: "w-full h-full", alt: "Bottom layer" }), se(g ?? [])] }), ve.jsx("div", { className: "flex flex-col text-sm", children: $(g ?? []) })] })] }) })] }) }; var dc = { exports: {} }; (function (e) {
    (function (t, i) { e.exports ? (i.default = i, e.exports = t && t.document ? i(t) : i) : (t.Highcharts && t.Highcharts.error(16, !0), t.Highcharts = i(t)) })(typeof window < "u" ? window : Ka, function (t) {
        var i = {}; function n(r, s, g, j) { r.hasOwnProperty(s) || (r[s] = j.apply(null, g), typeof CustomEvent == "function" && t.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s, module: r[s] } }))) } return n(i, "Core/Globals.js", [], function () { var r, s; return (s = r || (r = {})).SVG_NS = "http://www.w3.org/2000/svg", s.product = "Highcharts", s.version = "11.3.0", s.win = t !== void 0 ? t : {}, s.doc = s.win.document, s.svg = s.doc && s.doc.createElementNS && !!s.doc.createElementNS(s.SVG_NS, "svg").createSVGRect, s.userAgent = s.win.navigator && s.win.navigator.userAgent || "", s.isChrome = s.userAgent.indexOf("Chrome") !== -1, s.isFirefox = s.userAgent.indexOf("Firefox") !== -1, s.isMS = /(edge|msie|trident)/i.test(s.userAgent) && !s.win.opera, s.isSafari = !s.isChrome && s.userAgent.indexOf("Safari") !== -1, s.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(s.userAgent), s.isWebKit = s.userAgent.indexOf("AppleWebKit") !== -1, s.deg2rad = 2 * Math.PI / 360, s.hasBidiBug = s.isFirefox && 4 > parseInt(s.userAgent.split("Firefox/")[1], 10), s.hasTouch = !!s.win.TouchEvent, s.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], s.noop = function () { }, s.supportsPassiveEvents = function () { let g = !1; if (!s.isMS) { let j = Object.defineProperty({}, "passive", { get: function () { g = !0 } }); s.win.addEventListener && s.win.removeEventListener && (s.win.addEventListener("testPassive", s.noop, j), s.win.removeEventListener("testPassive", s.noop, j)) } return g }(), s.charts = [], s.composed = [], s.dateFormats = {}, s.seriesTypes = {}, s.symbolSizes = {}, s.chartCount = 0, r }), n(i, "Core/Utilities.js", [i["Core/Globals.js"]], function (r) {
            let s, { charts: g, doc: j, win: D } = r; function J(o, u, l, h) {
                let d = u ? "Highcharts error" : "Highcharts warning"; o === 32 && (o = `${d}: Deprecated member`); let m = W(o), p = m ? `${d} #${o}: www.highcharts.com/errors/${o}/` : o.toString(); if (h !== void 0) {
                    let T = ""; m && (p += "?"), F(h, function (U, ee) {
                        T += `
 - ${ee}: ${U}`, m && (p += encodeURI(ee) + "=" + encodeURI(U))
                    }), p += T
                } x(r, "displayError", { chart: l, code: o, message: p, params: h }, function () { if (u) throw Error(p); D.console && J.messages.indexOf(p) === -1 && console.warn(p) }), J.messages.push(p)
            } function se(o, u) { return parseInt(o, u || 10) } function $(o) { return typeof o == "string" } function R(o) { let u = Object.prototype.toString.call(o); return u === "[object Array]" || u === "[object Array Iterator]" } function Q(o, u) { return !!o && typeof o == "object" && (!u || !R(o)) } function E(o) { return Q(o) && typeof o.nodeType == "number" } function I(o) { let u = o && o.constructor; return !!(Q(o, !0) && !E(o) && u && u.name && u.name !== "Object") } function W(o) { return typeof o == "number" && !isNaN(o) && o < 1 / 0 && o > -1 / 0 } function y(o) { return o != null } function a(o, u, l) { let h, d = $(u) && !y(l), m = (p, T) => { y(p) ? o.setAttribute(T, p) : d ? (h = o.getAttribute(T)) || T !== "class" || (h = o.getAttribute(T + "Name")) : o.removeAttribute(T) }; return $(u) ? m(l, u) : F(u, m), h } function v(o) { return R(o) ? o : [o] } function k(o, u) { let l; for (l in o || (o = {}), u) o[l] = u[l]; return o } function w() { let o = arguments, u = o.length; for (let l = 0; l < u; l++) { let h = o[l]; if (h != null) return h } } function L(o, u) { r.isMS && !r.svg && u && y(u.opacity) && (u.filter = `alpha(opacity=${100 * u.opacity})`), k(o.style, u) } function G(o) { return Math.pow(10, Math.floor(Math.log(o) / Math.LN10)) } function _(o, u) { return o > 1e14 ? o : parseFloat(o.toPrecision(u || 14)) } (J || (J = {})).messages = [], Math.easeInOutSine = function (o) { return -.5 * (Math.cos(Math.PI * o) - 1) }; let N = Array.prototype.find ? function (o, u) { return o.find(u) } : function (o, u) { let l, h = o.length; for (l = 0; l < h; l++)if (u(o[l], l)) return o[l] }; function F(o, u, l) { for (let h in o) Object.hasOwnProperty.call(o, h) && u.call(l || o[h], o[h], h, o) } function C(o, u, l) { function h(p, T) { let U = o.removeEventListener; U && U.call(o, p, T, !1) } function d(p) { let T, U; o.nodeName && (u ? (T = {})[u] = !0 : T = p, F(T, function (ee, Z) { if (p[Z]) for (U = p[Z].length; U--;)h(Z, p[Z][U].fn) })) } let m = typeof o == "function" && o.prototype || o; if (Object.hasOwnProperty.call(m, "hcEvents")) { let p = m.hcEvents; if (u) { let T = p[u] || []; l ? (p[u] = T.filter(function (U) { return l !== U.fn }), h(u, l)) : (d(p), p[u] = []) } else d(p), delete m.hcEvents } } function x(o, u, l, h) { let d; if (l = l || {}, j.createEvent && (o.dispatchEvent || o.fireEvent && o !== r)) (d = j.createEvent("Events")).initEvent(u, !0, !0), l = k(d, l), o.dispatchEvent ? o.dispatchEvent(l) : o.fireEvent(u, l); else if (o.hcEvents) { l.target || k(l, { preventDefault: function () { l.defaultPrevented = !0 }, target: o, type: u }); let m = [], p = o, T = !1; for (; p.hcEvents;)Object.hasOwnProperty.call(p, "hcEvents") && p.hcEvents[u] && (m.length && (T = !0), m.unshift.apply(m, p.hcEvents[u])), p = Object.getPrototypeOf(p); T && m.sort((U, ee) => U.order - ee.order), m.forEach(U => { U.fn.call(o, l) === !1 && l.preventDefault() }) } h && !l.defaultPrevented && h.call(o, l) } F({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function (o, u) { r[u] = function (l) { return J(32, !1, void 0, { [`Highcharts.${u}`]: `use Array.${o}` }), Array.prototype[o].apply(l, [].slice.call(arguments, 1)) } }); let P = function () { let o = Math.random().toString(36).substring(2, 9) + "-", u = 0; return function () { return "highcharts-" + (s ? "" : o) + u++ } }(); return D.jQuery && (D.jQuery.fn.highcharts = function () { let o = [].slice.call(arguments); if (this[0]) return o[0] ? (new r[$(o[0]) ? o.shift() : "Chart"](this[0], o[0], o[1]), this) : g[a(this[0], "data-highcharts-chart")] }), { addEvent: function (o, u, l, h = {}) { let d = typeof o == "function" && o.prototype || o; Object.hasOwnProperty.call(d, "hcEvents") || (d.hcEvents = {}); let m = d.hcEvents; r.Point && o instanceof r.Point && o.series && o.series.chart && (o.series.chart.runTrackerClick = !0); let p = o.addEventListener; p && p.call(o, u, l, !!r.supportsPassiveEvents && { passive: h.passive === void 0 ? u.indexOf("touch") !== -1 : h.passive, capture: !1 }), m[u] || (m[u] = []); let T = { fn: l, order: typeof h.order == "number" ? h.order : 1 / 0 }; return m[u].push(T), m[u].sort((U, ee) => U.order - ee.order), function () { C(o, u, l) } }, arrayMax: function (o) { let u = o.length, l = o[0]; for (; u--;)o[u] > l && (l = o[u]); return l }, arrayMin: function (o) { let u = o.length, l = o[0]; for (; u--;)o[u] < l && (l = o[u]); return l }, attr: a, clamp: function (o, u, l) { return o > u ? o < l ? o : l : u }, clearTimeout: function (o) { y(o) && clearTimeout(o) }, correctFloat: _, createElement: function (o, u, l, h, d) { let m = j.createElement(o); return u && k(m, u), d && L(m, { padding: "0", border: "none", margin: "0" }), l && L(m, l), h && h.appendChild(m), m }, css: L, defined: y, destroyObjectProperties: function (o, u) { F(o, function (l, h) { l && l !== u && l.destroy && l.destroy(), delete o[h] }) }, diffObjects: function (o, u, l, h) { let d = {}; return function m(p, T, U, ee) { let Z = l ? T : p; F(p, function (H, Y) { if (!ee && h && h.indexOf(Y) > -1 && T[Y]) { H = v(H), U[Y] = []; for (let S = 0; S < Math.max(H.length, T[Y].length); S++)T[Y][S] && (H[S] === void 0 ? U[Y][S] = T[Y][S] : (U[Y][S] = {}, m(H[S], T[Y][S], U[Y][S], ee + 1))) } else Q(H, !0) && !H.nodeType ? (U[Y] = R(H) ? [] : {}, m(H, T[Y] || {}, U[Y], ee + 1), Object.keys(U[Y]).length !== 0 || Y === "colorAxis" && ee === 0 || delete U[Y]) : (p[Y] !== T[Y] || Y in p && !(Y in T)) && (U[Y] = Z[Y]) }) }(o, u, d, 0), d }, discardElement: function (o) { o && o.parentElement && o.parentElement.removeChild(o) }, erase: function (o, u) { let l = o.length; for (; l--;)if (o[l] === u) { o.splice(l, 1); break } }, error: J, extend: k, extendClass: function (o, u) { let l = function () { }; return l.prototype = new o, k(l.prototype, u), l }, find: N, fireEvent: x, getClosestDistance: function (o, u) { let l, h, d, m = !u; return o.forEach(p => { if (p.length > 1) for (d = p.length - 1; d > 0; d--)(h = p[d] - p[d - 1]) < 0 && !m ? (u == null || u(), u = void 0) : h && (l === void 0 || h < l) && (l = h) }), l }, getMagnitude: G, getNestedProperty: function (o, u) { let l = o.split("."); for (; l.length && y(u);) { let h = l.shift(); if (h === void 0 || h === "__proto__") return; if (h === "this") { let m; return Q(u) && (m = u["@this"]), m ?? u } let d = u[h]; if (!y(d) || typeof d == "function" || typeof d.nodeType == "number" || d === D) return; u = d } return u }, getStyle: function o(u, l, h) { let d; if (l === "width") { let p = Math.min(u.offsetWidth, u.scrollWidth), T = u.getBoundingClientRect && u.getBoundingClientRect().width; return T < p && T >= p - 1 && (p = Math.floor(T)), Math.max(0, p - (o(u, "padding-left", !0) || 0) - (o(u, "padding-right", !0) || 0)) } if (l === "height") return Math.max(0, Math.min(u.offsetHeight, u.scrollHeight) - (o(u, "padding-top", !0) || 0) - (o(u, "padding-bottom", !0) || 0)); let m = D.getComputedStyle(u, void 0); return m && (d = m.getPropertyValue(l), w(h, l !== "opacity") && (d = se(d))), d }, inArray: function (o, u, l) { return J(32, !1, void 0, { "Highcharts.inArray": "use Array.indexOf" }), u.indexOf(o, l) }, insertItem: function (o, u) { let l, h = o.options.index, d = u.length; for (l = o.options.isInternal ? d : 0; l < d + 1; l++)if (!u[l] || W(h) && h < w(u[l].options.index, u[l]._i) || u[l].options.isInternal) { u.splice(l, 0, o); break } return l }, isArray: R, isClass: I, isDOMElement: E, isFunction: function (o) { return typeof o == "function" }, isNumber: W, isObject: Q, isString: $, keys: function (o) { return J(32, !1, void 0, { "Highcharts.keys": "use Object.keys" }), Object.keys(o) }, merge: function () { let o, u = arguments, l = {}, h = function (m, p) { return typeof m != "object" && (m = {}), F(p, function (T, U) { U !== "__proto__" && U !== "constructor" && (!Q(T, !0) || I(T) || E(T) ? m[U] = p[U] : m[U] = h(m[U] || {}, T)) }), m }; u[0] === !0 && (l = u[1], u = Array.prototype.slice.call(u, 2)); let d = u.length; for (o = 0; o < d; o++)l = h(l, u[o]); return l }, normalizeTickInterval: function (o, u, l, h, d) { let m, p = o; l = w(l, G(o)); let T = o / l; for (!u && (u = d ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], h === !1 && (l === 1 ? u = u.filter(function (U) { return U % 1 == 0 }) : l <= .1 && (u = [1 / l]))), m = 0; m < u.length && (p = u[m], (!d || !(p * l >= o)) && (d || !(T <= (u[m] + (u[m + 1] || u[m])) / 2))); m++); return _(p * l, -Math.round(Math.log(.001) / Math.LN10)) }, objectEach: F, offset: function (o) { let u = j.documentElement, l = o.parentElement || o.parentNode ? o.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 }; return { top: l.top + (D.pageYOffset || u.scrollTop) - (u.clientTop || 0), left: l.left + (D.pageXOffset || u.scrollLeft) - (u.clientLeft || 0), width: l.width, height: l.height } }, pad: function (o, u, l) { return Array((u || 2) + 1 - String(o).replace("-", "").length).join(l || "0") + o }, pick: w, pInt: se, pushUnique: function (o, u) { return 0 > o.indexOf(u) && !!o.push(u) }, relativeLength: function (o, u, l) { return /%$/.test(o) ? u * parseFloat(o) / 100 + (l || 0) : parseFloat(o) }, removeEvent: C, splat: v, stableSort: function (o, u) { let l, h, d = o.length; for (h = 0; h < d; h++)o[h].safeI = h; for (o.sort(function (m, p) { return (l = u(m, p)) === 0 ? m.safeI - p.safeI : l }), h = 0; h < d; h++)delete o[h].safeI }, syncTimeout: function (o, u, l) { return u > 0 ? setTimeout(o, u, l) : (o.call(0, l), -1) }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: P, useSerialIds: function (o) { return s = w(o, s) }, wrap: function (o, u, l) { let h = o[u]; o[u] = function () { let d = arguments, m = this; return l.apply(this, [function () { return h.apply(m, arguments.length ? arguments : d) }].concat([].slice.call(arguments))) } } }
        }), n(i, "Core/Chart/ChartDefaults.js", [], function () { return { alignThresholds: !1, panning: { enabled: !1, type: "x" }, styledMode: !1, borderRadius: 0, colorCount: 10, allowMutatingData: !0, ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], resetZoomButton: { theme: {}, position: {} }, reflow: !0, type: "line", zooming: { singleTouch: !1, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } }, width: null, height: null, borderColor: "#334eff", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" } }), n(i, "Core/Color/Palettes.js", [], function () { return { colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"] } }), n(i, "Core/Time.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { let { win: g } = r, { defined: j, error: D, extend: J, isNumber: se, isObject: $, merge: R, objectEach: Q, pad: E, pick: I, splat: W, timeUnits: y } = s, a = r.isSafari && g.Intl && g.Intl.DateTimeFormat.prototype.formatRange, v = r.isSafari && g.Intl && !g.Intl.DateTimeFormat.prototype.formatRange; return class { constructor(k) { this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = g.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(k) } get(k, w) { if (this.variableTimezone || this.timezoneOffset) { let L = w.getTime(), G = L - this.getTimezoneOffset(w); w.setTime(G); let _ = w["getUTC" + k](); return w.setTime(L), _ } return this.useUTC ? w["getUTC" + k]() : w["get" + k]() } set(k, w, L) { if (this.variableTimezone || this.timezoneOffset) { if (k === "Milliseconds" || k === "Seconds" || k === "Minutes" && this.getTimezoneOffset(w) % 36e5 == 0) return w["setUTC" + k](L); let G = this.getTimezoneOffset(w), _ = w.getTime() - G; w.setTime(_), w["setUTC" + k](L); let N = this.getTimezoneOffset(w); return _ = w.getTime() + N, w.setTime(_) } return this.useUTC || a && k === "FullYear" ? w["setUTC" + k](L) : w["set" + k](L) } update(k = {}) { let w = I(k.useUTC, !0); this.options = k = R(!0, this.options, k), this.Date = k.Date || g.Date || Date, this.useUTC = w, this.timezoneOffset = w && k.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = w && !!(k.getTimezoneOffset || k.timezone) } makeTime(k, w, L, G, _, N) { let F, C, x; return this.useUTC ? (F = this.Date.UTC.apply(0, arguments), C = this.getTimezoneOffset(F), F += C, C !== (x = this.getTimezoneOffset(F)) ? F += x - C : C - 36e5 !== this.getTimezoneOffset(F - 36e5) || v || (F -= 36e5)) : F = new this.Date(k, w, I(L, 1), I(G, 0), I(_, 0), I(N, 0)).getTime(), F } timezoneOffsetFunction() { let k = this, w = this.options, L = w.getTimezoneOffset; return this.useUTC ? w.timezone ? G => { try { let [_, N, F, C, x = 0] = Intl.DateTimeFormat("en", { timeZone: w.timezone, timeZoneName: "shortOffset" }).format(G).split(/(GMT|:)/).map(Number), P = -(36e5 * (F + x / 60)); if (se(P)) return P } catch { D(34) } return 0 } : this.useUTC && L ? G => 6e4 * L(G.valueOf()) : () => 6e4 * (k.timezoneOffset || 0) : G => 6e4 * new Date(G.toString()).getTimezoneOffset() } dateFormat(k, w, L) { if (!j(w) || isNaN(w)) return r.defaultOptions.lang && r.defaultOptions.lang.invalidDate || ""; k = I(k, "%Y-%m-%d %H:%M:%S"); let G = this, _ = new this.Date(w), N = this.get("Hours", _), F = this.get("Day", _), C = this.get("Date", _), x = this.get("Month", _), P = this.get("FullYear", _), f = r.defaultOptions.lang, o = f && f.weekdays, u = f && f.shortWeekdays, l = J({ a: u ? u[F] : o[F].substr(0, 3), A: o[F], d: E(C), e: E(C, 2, " "), w: F, b: f.shortMonths[x], B: f.months[x], m: E(x + 1), o: x + 1, y: P.toString().substr(2, 2), Y: P, H: E(N), k: N, I: E(N % 12 || 12), l: N % 12 || 12, M: E(this.get("Minutes", _)), p: N < 12 ? "AM" : "PM", P: N < 12 ? "am" : "pm", S: E(this.get("Seconds", _)), L: E(Math.floor(w % 1e3), 3) }, r.dateFormats); return Q(l, function (h, d) { for (; k.indexOf("%" + d) !== -1;)k = k.replace("%" + d, typeof h == "function" ? h.call(G, w) : h) }), L ? k.substr(0, 1).toUpperCase() + k.substr(1) : k } resolveDTLFormat(k) { return $(k, !0) ? k : { main: (k = W(k))[0], from: k[1], to: k[2] } } getTimeTicks(k, w, L, G) { let _, N, F, C, x = this, P = x.Date, f = [], o = {}, u = new P(w), l = k.unitRange, h = k.count || 1; if (G = I(G, 1), j(w)) { x.set("Milliseconds", u, l >= y.second ? 0 : h * Math.floor(x.get("Milliseconds", u) / h)), l >= y.second && x.set("Seconds", u, l >= y.minute ? 0 : h * Math.floor(x.get("Seconds", u) / h)), l >= y.minute && x.set("Minutes", u, l >= y.hour ? 0 : h * Math.floor(x.get("Minutes", u) / h)), l >= y.hour && x.set("Hours", u, l >= y.day ? 0 : h * Math.floor(x.get("Hours", u) / h)), l >= y.day && x.set("Date", u, l >= y.month ? 1 : Math.max(1, h * Math.floor(x.get("Date", u) / h))), l >= y.month && (x.set("Month", u, l >= y.year ? 0 : h * Math.floor(x.get("Month", u) / h)), N = x.get("FullYear", u)), l >= y.year && (N -= N % h, x.set("FullYear", u, N)), l === y.week && (C = x.get("Day", u), x.set("Date", u, x.get("Date", u) - C + G + (C < G ? -7 : 0))), N = x.get("FullYear", u); let d = x.get("Month", u), m = x.get("Date", u), p = x.get("Hours", u); w = u.getTime(), (x.variableTimezone || !x.useUTC) && j(L) && (F = L - w > 4 * y.month || x.getTimezoneOffset(w) !== x.getTimezoneOffset(L)); let T = u.getTime(); for (_ = 1; T < L;)f.push(T), l === y.year ? T = x.makeTime(N + _ * h, 0) : l === y.month ? T = x.makeTime(N, d + _ * h) : F && (l === y.day || l === y.week) ? T = x.makeTime(N, d, m + _ * h * (l === y.day ? 1 : 7)) : F && l === y.hour && h > 1 ? T = x.makeTime(N, d, m, p + _ * h) : T += l * h, _++; f.push(T), l <= y.hour && f.length < 1e4 && f.forEach(function (U) { U % 18e5 == 0 && x.dateFormat("%H%M%S%L", U) === "000000000" && (o[U] = "day") }) } return f.info = J(k, { higherRanks: o, totalRange: l * h }), f } getDateFormat(k, w, L, G) { let _ = this.dateFormat("%m-%d %H:%M:%S.%L", w), N = "01-01 00:00:00.000", F = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, C = "millisecond", x = C; for (C in y) { if (k === y.week && +this.dateFormat("%w", w) === L && _.substr(6) === N.substr(6)) { C = "week"; break } if (y[C] > k) { C = x; break } if (F[C] && _.substr(F[C]) !== N.substr(F[C])) break; C !== "week" && (x = C) } return this.resolveDTLFormat(G[C]).main } } }), n(i, "Core/Defaults.js", [i["Core/Chart/ChartDefaults.js"], i["Core/Globals.js"], i["Core/Color/Palettes.js"], i["Core/Time.js"], i["Core/Utilities.js"]], function (r, s, g, j, D) { let { isTouchDevice: J, svg: se } = s, { merge: $ } = D, R = { colors: g.colors, symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], decimalPoint: ".", numericSymbols: ["k", "M", "G", "T", "P", "E"], resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: {}, time: { Date: void 0, getTimezoneOffset: void 0, timezone: void 0, timezoneOffset: 0, useUTC: !0 }, chart: r, title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 }, caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: { enabled: !0, align: "center", alignColumns: !0, className: "highcharts-no-tooltip", layout: "horizontal", itemMarginBottom: 2, itemMarginTop: 2, labelFormatter: function () { return this.name }, borderColor: "#999999", borderRadius: 0, navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#666666", textDecoration: "line-through" }, shadow: !1, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: !0, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontSize: "0.8em", fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: .5, textAlign: "center" } }, tooltip: { enabled: !0, animation: se, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, shape: "callout", shared: !1, snap: J ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>', pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, shadow: !0, stickOnContact: !1, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: !1 }, credits: { enabled: !0, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } }; R.chart.styledMode = !1; let Q = new j(R.time); return { defaultOptions: R, defaultTime: Q, getOptions: function () { return R }, setOptions: function (E) { return $(!0, R, E), (E.time || E.global) && (s.time ? s.time.update($(R.global, R.time, E.global, E.time)) : s.time = Q), R } } }), n(i, "Core/Color/Color.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { let { isNumber: g, merge: j, pInt: D } = s; class J { static parse($) { return $ ? new J($) : J.None } constructor($) { let R, Q, E, I; this.rgba = [NaN, NaN, NaN, NaN], this.input = $; let W = r.Color; if (W && W !== J) return new W($); if (typeof $ == "object" && $.stops !== void 0) this.stops = $.stops.map(y => new J(y[1])); else if (typeof $ == "string") { if (this.input = $ = J.names[$.toLowerCase()] || $, $.charAt(0) === "#") { let y = $.length, a = parseInt($.substr(1), 16); y === 7 ? Q = [(16711680 & a) >> 16, (65280 & a) >> 8, 255 & a, 1] : y === 4 && (Q = [(3840 & a) >> 4 | (3840 & a) >> 8, (240 & a) >> 4 | 240 & a, (15 & a) << 4 | 15 & a, 1]) } if (!Q) for (E = J.parsers.length; E-- && !Q;)(R = (I = J.parsers[E]).regex.exec($)) && (Q = I.parse(R)) } Q && (this.rgba = Q) } get($) { let R = this.input, Q = this.rgba; if (typeof R == "object" && this.stops !== void 0) { let E = j(R); return E.stops = [].slice.call(E.stops), this.stops.forEach((I, W) => { E.stops[W] = [E.stops[W][0], I.get($)] }), E } return Q && g(Q[0]) ? $ !== "rgb" && ($ || Q[3] !== 1) ? $ === "a" ? `${Q[3]}` : "rgba(" + Q.join(",") + ")" : "rgb(" + Q[0] + "," + Q[1] + "," + Q[2] + ")" : R } brighten($) { let R = this.rgba; if (this.stops) this.stops.forEach(function (Q) { Q.brighten($) }); else if (g($) && $ !== 0) for (let Q = 0; Q < 3; Q++)R[Q] += D(255 * $), R[Q] < 0 && (R[Q] = 0), R[Q] > 255 && (R[Q] = 255); return this } setOpacity($) { return this.rgba[3] = $, this } tweenTo($, R) { let Q = this.rgba, E = $.rgba; if (!g(Q[0]) || !g(E[0])) return $.input || "none"; let I = E[3] !== 1 || Q[3] !== 1; return (I ? "rgba(" : "rgb(") + Math.round(E[0] + (Q[0] - E[0]) * (1 - R)) + "," + Math.round(E[1] + (Q[1] - E[1]) * (1 - R)) + "," + Math.round(E[2] + (Q[2] - E[2]) * (1 - R)) + (I ? "," + (E[3] + (Q[3] - E[3]) * (1 - R)) : "") + ")" } } return J.names = { white: "#ffffff", black: "#000000" }, J.parsers = [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function (se) { return [D(se[1]), D(se[2]), D(se[3]), parseFloat(se[4], 10)] } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function (se) { return [D(se[1]), D(se[2]), D(se[3]), 1] } }], J.None = new J(""), J }), n(i, "Core/Animation/Fx.js", [i["Core/Color/Color.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g) { let { parse: j } = r, { win: D } = s, { isNumber: J, objectEach: se } = g; class $ { constructor(Q, E, I) { this.pos = NaN, this.options = E, this.elem = Q, this.prop = I } dSetter() { let Q = this.paths, E = Q && Q[0], I = Q && Q[1], W = this.now || 0, y = []; if (W !== 1 && E && I) if (E.length === I.length && W < 1) for (let a = 0; a < I.length; a++) { let v = E[a], k = I[a], w = []; for (let L = 0; L < k.length; L++) { let G = v[L], _ = k[L]; J(G) && J(_) && !(k[0] === "A" && (L === 4 || L === 5)) ? w[L] = G + W * (_ - G) : w[L] = _ } y.push(w) } else y = I; else y = this.toD || []; this.elem.attr("d", y, void 0, !0) } update() { let Q = this.elem, E = this.prop, I = this.now, W = this.options.step; this[E + "Setter"] ? this[E + "Setter"]() : Q.attr ? Q.element && Q.attr(E, I, null, !0) : Q.style[E] = I + this.unit, W && W.call(Q, I, this) } run(Q, E, I) { let W = this, y = W.options, a = function (w) { return !a.stopped && W.step(w) }, v = D.requestAnimationFrame || function (w) { setTimeout(w, 13) }, k = function () { for (let w = 0; w < $.timers.length; w++)$.timers[w]() || $.timers.splice(w--, 1); $.timers.length && v(k) }; Q !== E || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date, this.start = Q, this.end = E, this.unit = I, this.now = this.start, this.pos = 0, a.elem = this.elem, a.prop = this.prop, a() && $.timers.push(a) === 1 && v(k)) : (delete y.curAnim[this.prop], y.complete && Object.keys(y.curAnim).length === 0 && y.complete.call(this.elem)) } step(Q) { let E, I, W = +new Date, y = this.options, a = this.elem, v = y.complete, k = y.duration, w = y.curAnim; return a.attr && !a.element ? E = !1 : Q || W >= k + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), w[this.prop] = !0, I = !0, se(w, function (L) { L !== !0 && (I = !1) }), I && v && v.call(a), E = !1) : (this.pos = y.easing((W - this.startTime) / k), this.now = this.start + (this.end - this.start) * this.pos, this.update(), E = !0), E } initPath(Q, E, I) { let W = Q.startX, y = Q.endX, a = I.slice(), v = Q.isArea, k = v ? 2 : 1, w, L, G, _, N = E && E.slice(); if (!N) return [a, a]; function F(x, P) { for (; x.length < L;) { let f = x[0], o = P[L - x.length]; if (o && f[0] === "M" && (o[0] === "C" ? x[0] = ["C", f[1], f[2], f[1], f[2], f[1], f[2]] : x[0] = ["L", f[1], f[2]]), x.unshift(f), v) { let u = x.pop(); x.push(x[x.length - 1], u) } } } function C(x, P) { for (; x.length < L;) { let f = x[Math.floor(x.length / k) - 1].slice(); if (f[0] === "C" && (f[1] = f[5], f[2] = f[6]), v) { let o = x[Math.floor(x.length / k)].slice(); x.splice(x.length / 2, 0, f, o) } else x.push(f) } } if (W && y && y.length) { for (G = 0; G < W.length; G++) { if (W[G] === y[0]) { w = G; break } if (W[0] === y[y.length - W.length + G]) { w = G, _ = !0; break } if (W[W.length - 1] === y[y.length - W.length + G]) { w = W.length - G; break } } w === void 0 && (N = []) } return N.length && J(w) && (L = a.length + w * k, _ ? (F(N, a), C(a)) : (F(a, N), C(N))), [N, a] } fillSetter() { $.prototype.strokeSetter.apply(this, arguments) } strokeSetter() { this.elem.attr(this.prop, j(this.start).tweenTo(j(this.end), this.pos), void 0, !0) } } return $.timers = [], $ }), n(i, "Core/Animation/AnimationUtilities.js", [i["Core/Animation/Fx.js"], i["Core/Utilities.js"]], function (r, s) { let { defined: g, getStyle: j, isArray: D, isNumber: J, isObject: se, merge: $, objectEach: R, pick: Q } = s; function E(W) { return se(W) ? $({ duration: 500, defer: 0 }, W) : { duration: W ? 500 : 0, defer: 0 } } function I(W, y) { let a = r.timers.length; for (; a--;)r.timers[a].elem !== W || y && y !== r.timers[a].prop || (r.timers[a].stopped = !0) } return { animate: function (W, y, a) { let v, k = "", w, L, G; se(a) || (G = arguments, a = { duration: G[2], easing: G[3], complete: G[4] }), J(a.duration) || (a.duration = 400), a.easing = typeof a.easing == "function" ? a.easing : Math[a.easing] || Math.easeInOutSine, a.curAnim = $(y), R(y, function (_, N) { I(W, N), L = new r(W, a, N), w = void 0, N === "d" && D(y.d) ? (L.paths = L.initPath(W, W.pathArray, y.d), L.toD = y.d, v = 0, w = 1) : W.attr ? v = W.attr(N) : (v = parseFloat(j(W, N)) || 0, N !== "opacity" && (k = "px")), w || (w = _), typeof w == "string" && w.match("px") && (w = w.replace(/px/g, "")), L.run(v, w, k) }) }, animObject: E, getDeferredAnimation: function (W, y, a) { let v = E(y), k = a ? [a] : W.series, w = 0, L = 0; return k.forEach(_ => { let N = E(_.options.animation); w = se(y) && g(y.defer) ? v.defer : Math.max(w, N.duration + N.defer), L = Math.min(v.duration, N.duration) }), W.renderer.forExport && (w = 0), { defer: Math.max(0, w - L), duration: Math.min(w, L) } }, setAnimation: function (W, y) { y.renderer.globalAnimation = Q(W, y.options.chart.animation, !0) }, stop: I } }), n(i, "Core/Renderer/HTML/AST.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { let { SVG_NS: g, win: j } = r, { attr: D, createElement: J, css: se, error: $, isFunction: R, isString: Q, objectEach: E, splat: I } = s, { trustedTypes: W } = j, y = W && R(W.createPolicy) && W.createPolicy("highcharts", { createHTML: w => w }), a = y ? y.createHTML("") : "", v = function () { try { return !!new DOMParser().parseFromString(a, "text/html") } catch { return !1 } }(); class k { static filterUserAttributes(L) { return E(L, (G, _) => { let N = !0; k.allowedAttributes.indexOf(_) === -1 && (N = !1), ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(_) !== -1 && (N = Q(G) && k.allowedReferences.some(F => G.indexOf(F) === 0)), N || ($(33, !1, void 0, { "Invalid attribute in config": `${_}` }), delete L[_]), Q(G) && L[_] && (L[_] = G.replace(/</g, "&lt;")) }), L } static parseStyle(L) { return L.split(";").reduce((G, _) => { let N = _.split(":").map(C => C.trim()), F = N.shift(); return F && N.length && (G[F.replace(/-([a-z])/g, C => C[1].toUpperCase())] = N.join(":")), G }, {}) } static setElementHTML(L, G) { L.innerHTML = k.emptyHTML, G && new k(G).addToDOM(L) } constructor(L) { this.nodes = typeof L == "string" ? this.parseMarkup(L) : L } addToDOM(L) { return function G(_, N) { let F; return I(_).forEach(function (C) { let x, P = C.tagName, f = C.textContent ? r.doc.createTextNode(C.textContent) : void 0, o = k.bypassHTMLFiltering; if (P) if (P === "#text") x = f; else if (k.allowedTags.indexOf(P) !== -1 || o) { let u = P === "svg" ? g : N.namespaceURI || g, l = r.doc.createElementNS(u, P), h = C.attributes || {}; E(C, function (d, m) { m !== "tagName" && m !== "attributes" && m !== "children" && m !== "style" && m !== "textContent" && (h[m] = d) }), D(l, o ? h : k.filterUserAttributes(h)), C.style && se(l, C.style), f && l.appendChild(f), G(C.children || [], l), x = l } else $(33, !1, void 0, { "Invalid tagName in config": P }); x && N.appendChild(x), F = x }), F }(this.nodes, L) } parseMarkup(L) { let G, _ = []; if (L = L.trim().replace(/ style=(["'])/g, " data-style=$1"), v) G = new DOMParser().parseFromString(y ? y.createHTML(L) : L, "text/html"); else { let F = J("div"); F.innerHTML = L, G = { body: F } } let N = (F, C) => { let x = F.nodeName.toLowerCase(), P = { tagName: x }; x === "#text" && (P.textContent = F.textContent || ""); let f = F.attributes; if (f) { let o = {};[].forEach.call(f, u => { u.name === "data-style" ? P.style = k.parseStyle(u.value) : o[u.name] = u.value }), P.attributes = o } if (F.childNodes.length) { let o = [];[].forEach.call(F.childNodes, u => { N(u, o) }), o.length && (P.children = o) } C.push(P) }; return [].forEach.call(G.body.childNodes, F => N(F, _)), _ } } return k.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], k.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], k.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], k.emptyHTML = a, k.bypassHTMLFiltering = !1, k }), n(i, "Core/Templating.js", [i["Core/Defaults.js"], i["Core/Utilities.js"]], function (r, s) { let { defaultOptions: g, defaultTime: j } = r, { extend: D, getNestedProperty: J, isArray: se, isNumber: $, isObject: R, isString: Q, pick: E, pInt: I } = s, W = { add: (v, k) => v + k, divide: (v, k) => k !== 0 ? v / k : "", eq: (v, k) => v == k, each: function (v) { let k = arguments[arguments.length - 1]; return !!se(v) && v.map((w, L) => y(k.body, D(R(w) ? w : { "@this": w }, { "@index": L, "@first": L === 0, "@last": L === v.length - 1 }))).join("") }, ge: (v, k) => v >= k, gt: (v, k) => v > k, if: v => !!v, le: (v, k) => v <= k, lt: (v, k) => v < k, multiply: (v, k) => v * k, ne: (v, k) => v != k, subtract: (v, k) => v - k, unless: v => !v }; function y(v = "", k, w) { let L = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g, G = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g, _ = [], N = /f$/, F = /\.([0-9])/, C = g.lang, x = w && w.time || j, P = w && w.numberFormatter || a, f = (d = "") => { let m; return d === "true" || d !== "false" && ((m = Number(d)).toString() === d ? m : J(d, k)) }, o, u, l = 0, h; for (; (o = L.exec(v)) !== null;) { let d = G.exec(o[1]); d && (o = d, h = !0), u && u.isBlock || (u = { ctx: k, expression: o[1], find: o[0], isBlock: o[1].charAt(0) === "#", start: o.index, startInner: o.index + o[0].length, length: o[0].length }); let m = o[1].split(" ")[0].replace("#", ""); W[m] && (u.isBlock && m === u.fn && l++, u.fn || (u.fn = m)); let p = o[1] === "else"; if (u.isBlock && u.fn && (o[1] === `/${u.fn}` || p)) if (l) !p && l--; else { let T = u.startInner, U = v.substr(T, o.index - T); u.body === void 0 ? (u.body = U, u.startInner = o.index + o[0].length) : u.elseBody = U, u.find += U + o[0], p || (_.push(u), u = void 0) } else u.isBlock || _.push(u); if (d && !(u != null && u.isBlock)) break } return _.forEach(d => { let m, p, { body: T, elseBody: U, expression: ee, fn: Z } = d; if (Z) { let H = [d], Y = ee.split(" "); for (p = W[Z].length; p--;)H.unshift(f(Y[p + 1])); m = W[Z].apply(k, H), d.isBlock && typeof m == "boolean" && (m = y(m ? T : U, k)) } else { let H = ee.split(":"); if (m = f(H.shift() || ""), H.length && typeof m == "number") { let Y = H.join(":"); if (N.test(Y)) { let S = parseInt((Y.match(F) || ["", "-1"])[1], 10); m !== null && (m = P(m, S, C.decimalPoint, Y.indexOf(",") > -1 ? C.thousandsSep : "")) } else m = x.dateFormat(Y, m) } } v = v.replace(d.find, E(m, "")) }), h ? y(v, k, w) : v } function a(v, k, w, L) { let G, _; v = +v || 0, k = +k; let N = g.lang, F = (v.toString().split(".")[1] || "").split("e")[0].length, C = v.toString().split("e"), x = k; k === -1 ? k = Math.min(F, 20) : $(k) ? k && C[1] && C[1] < 0 && ((_ = k + +C[1]) >= 0 ? (C[0] = (+C[0]).toExponential(_).split("e")[0], k = _) : (C[0] = C[0].split(".")[0] || 0, v = k < 20 ? (C[0] * Math.pow(10, C[1])).toFixed(k) : 0, C[1] = 0)) : k = 2; let P = (Math.abs(C[1] ? C[0] : v) + Math.pow(10, -Math.max(k, F) - 1)).toFixed(k), f = String(I(P)), o = f.length > 3 ? f.length % 3 : 0; return w = E(w, N.decimalPoint), L = E(L, N.thousandsSep), G = (v < 0 ? "-" : "") + (o ? f.substr(0, o) + L : ""), 0 > +C[1] && !x ? G = "0" : G += f.substr(o).replace(/(\d{3})(?=\d)/g, "$1" + L), k && (G += w + P.slice(-k)), C[1] && +G != 0 && (G += "e" + C[1]), G } return { dateFormat: function (v, k, w) { return j.dateFormat(v, k, w) }, format: y, helpers: W, numberFormat: a } }), n(i, "Core/Renderer/RendererUtilities.js", [i["Core/Utilities.js"]], function (r) { var s; let { clamp: g, pick: j, pushUnique: D, stableSort: J } = r; return (s || (s = {})).distribute = function se($, R, Q) { let E = $, I = E.reducedLen || R, W = (P, f) => P.target - f.target, y = [], a = $.length, v = [], k = y.push, w, L, G, _ = !0, N, F, C = 0, x; for (w = a; w--;)C += $[w].size; if (C > I) { for (J($, (P, f) => (f.rank || 0) - (P.rank || 0)), G = (x = $[0].rank === $[$.length - 1].rank) ? a / 2 : -1, L = x ? G : a - 1; G && C > I;)N = $[w = Math.floor(L)], D(v, w) && (C -= N.size), L += G, x && L >= $.length && (G /= 2, L = G); v.sort((P, f) => f - P).forEach(P => k.apply(y, $.splice(P, 1))) } for (J($, W), $ = $.map(P => ({ size: P.size, targets: [P.target], align: j(P.align, .5) })); _;) { for (w = $.length; w--;)N = $[w], F = (Math.min.apply(0, N.targets) + Math.max.apply(0, N.targets)) / 2, N.pos = g(F - N.size * N.align, 0, R - N.size); for (w = $.length, _ = !1; w--;)w > 0 && $[w - 1].pos + $[w - 1].size > $[w].pos && ($[w - 1].size += $[w].size, $[w - 1].targets = $[w - 1].targets.concat($[w].targets), $[w - 1].align = .5, $[w - 1].pos + $[w - 1].size > R && ($[w - 1].pos = R - $[w - 1].size), $.splice(w, 1), _ = !0) } return k.apply(E, y), w = 0, $.some(P => { let f = 0; return (P.targets || []).some(() => (E[w].pos = P.pos + f, Q !== void 0 && Math.abs(E[w].pos - E[w].target) > Q ? (E.slice(0, w + 1).forEach(o => delete o.pos), E.reducedLen = (E.reducedLen || R) - .1 * R, E.reducedLen > .1 * R && se(E, R, Q), !0) : (f += E[w].size, w++, !1))) }), J(E, W), E }, s }), n(i, "Core/Renderer/SVG/SVGElement.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Color/Color.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g, j) { let { animate: D, animObject: J, stop: se } = r, { deg2rad: $, doc: R, noop: Q, svg: E, SVG_NS: I, win: W } = g, { addEvent: y, attr: a, createElement: v, css: k, defined: w, erase: L, extend: G, fireEvent: _, isArray: N, isFunction: F, isObject: C, isString: x, merge: P, objectEach: f, pick: o, pInt: u, syncTimeout: l, uniqueKey: h } = j; class d { _defaultGetter(p) { let T = o(this[p + "Value"], this[p], this.element ? this.element.getAttribute(p) : null, 0); return /^[\-0-9\.]+$/.test(T) && (T = parseFloat(T)), T } _defaultSetter(p, T, U) { U.setAttribute(T, p) } add(p) { let T, U = this.renderer, ee = this.element; return p && (this.parentGroup = p), this.textStr !== void 0 && this.element.nodeName === "text" && U.buildText(this), this.added = !0, (!p || p.handleZ || this.zIndex) && (T = this.zIndexSetter()), T || (p ? p.element : U.box).appendChild(ee), this.onAdd && this.onAdd(), this } addClass(p, T) { let U = T ? "" : this.attr("class") || ""; return (p = (p || "").split(/ /g).reduce(function (ee, Z) { return U.indexOf(Z) === -1 && ee.push(Z), ee }, U ? [U] : []).join(" ")) !== U && this.attr("class", p), this } afterSetters() { this.doTransform && (this.updateTransform(), this.doTransform = !1) } align(p, T, U) { let ee, Z, H, Y, S, A = {}, B = this.renderer, K = B.alignedObjects; p ? (this.alignOptions = p, this.alignByTranslate = T, (!U || x(U)) && (this.alignTo = H = U || "renderer", L(K, this), K.push(this), U = void 0)) : (p = this.alignOptions, T = this.alignByTranslate, H = this.alignTo), U = o(U, B[H], H === "scrollablePlotBox" ? B.plotBox : void 0, B); let c = p.align, M = p.verticalAlign; return ee = (U.x || 0) + (p.x || 0), Z = (U.y || 0) + (p.y || 0), c === "right" ? Y = 1 : c === "center" && (Y = 2), Y && (ee += (U.width - (p.width || 0)) / Y), A[T ? "translateX" : "x"] = Math.round(ee), M === "bottom" ? S = 1 : M === "middle" && (S = 2), S && (Z += (U.height - (p.height || 0)) / S), A[T ? "translateY" : "y"] = Math.round(Z), this[this.placed ? "animate" : "attr"](A), this.placed = !0, this.alignAttr = A, this } alignSetter(p) { let T = { left: "start", center: "middle", right: "end" }; T[p] && (this.alignValue = p, this.element.setAttribute("text-anchor", T[p])) } animate(p, T, U) { let ee = J(o(T, this.renderer.globalAnimation, !0)), Z = ee.defer; return R.hidden && (ee.duration = 0), ee.duration !== 0 ? (U && (ee.complete = U), l(() => { this.element && D(this, p, ee) }, Z)) : (this.attr(p, void 0, U || ee.complete), f(p, function (H, Y) { ee.step && ee.step.call(this, H, { prop: Y, pos: 1, elem: this }) }, this)), this } applyTextOutline(p) { let T = this.element; p.indexOf("contrast") !== -1 && (p = p.replace(/contrast/g, this.renderer.getContrast(T.style.fill))); let ee = p.split(" "), Z = ee[ee.length - 1], H = ee[0]; if (H && H !== "none" && g.svg) { this.fakeTS = !0, H = H.replace(/(^[\d\.]+)(.*?)$/g, function (K, c, M) { return 2 * Number(c) + M }), this.removeTextOutline(); let Y = R.createElementNS(I, "tspan"); a(Y, { class: "highcharts-text-outline", fill: Z, stroke: Z, "stroke-width": H, "stroke-linejoin": "round" }); let S = T.querySelector("textPath") || T;[].forEach.call(S.childNodes, K => { let c = K.cloneNode(!0); c.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(M => c.removeAttribute(M)), Y.appendChild(c) }); let A = 0;[].forEach.call(S.querySelectorAll("text tspan"), K => { A += Number(K.getAttribute("dy")) }); let B = R.createElementNS(I, "tspan"); B.textContent = "​", a(B, { x: Number(T.getAttribute("x")), dy: -A }), Y.appendChild(B), S.insertBefore(Y, S.firstChild) } } attr(p, T, U, ee) { let Z = this.element, H = d.symbolCustomAttribs, Y, S, A = this, B; return typeof p == "string" && T !== void 0 && (Y = p, (p = {})[Y] = T), typeof p == "string" ? A = (this[p + "Getter"] || this._defaultGetter).call(this, p, Z) : (f(p, function (K, c) { B = !1, ee || se(this, c), this.symbolName && H.indexOf(c) !== -1 && (S || (this.symbolAttr(p), S = !0), B = !0), this.rotation && (c === "x" || c === "y") && (this.doTransform = !0), B || (this[c + "Setter"] || this._defaultSetter).call(this, K, c, Z) }, this), this.afterSetters()), U && U.call(this), A } clip(p) { if (p && !p.clipPath) { let T = h() + "-", U = this.renderer.createElement("clipPath").attr({ id: T }).add(this.renderer.defs); G(p, { clipPath: U, id: T, count: 0 }), p.add(U) } return this.attr("clip-path", p ? `url(${this.renderer.url}#${p.id})` : "none") } crisp(p, T) { T = T || p.strokeWidth || 0; let U = Math.round(T) % 2 / 2; return p.x = Math.floor(p.x || this.x || 0) + U, p.y = Math.floor(p.y || this.y || 0) + U, p.width = Math.floor((p.width || this.width || 0) - 2 * U), p.height = Math.floor((p.height || this.height || 0) - 2 * U), w(p.strokeWidth) && (p.strokeWidth = T), p } complexColor(p, T, U) { let ee = this.renderer, Z, H, Y, S, A, B, K, c, M, b, z = [], O; _(this.renderer, "complexColor", { args: arguments }, function () { if (p.radialGradient ? H = "radialGradient" : p.linearGradient && (H = "linearGradient"), H) { if (Y = p[H], A = ee.gradients, B = p.stops, M = U.radialReference, N(Y) && (p[H] = Y = { x1: Y[0], y1: Y[1], x2: Y[2], y2: Y[3], gradientUnits: "userSpaceOnUse" }), H === "radialGradient" && M && !w(Y.gradientUnits) && (S = Y, Y = P(Y, ee.getRadialAttr(M, S), { gradientUnits: "userSpaceOnUse" })), f(Y, function (q, ie) { ie !== "id" && z.push(ie, q) }), f(B, function (q) { z.push(q) }), A[z = z.join(",")]) b = A[z].attr("id"); else { Y.id = b = h(); let q = A[z] = ee.createElement(H).attr(Y).add(ee.defs); q.radAttr = S, q.stops = [], B.forEach(function (ie) { ie[1].indexOf("rgba") === 0 ? (K = (Z = s.parse(ie[1])).get("rgb"), c = Z.get("a")) : (K = ie[1], c = 1); let re = ee.createElement("stop").attr({ offset: ie[0], "stop-color": K, "stop-opacity": c }).add(q); q.stops.push(re) }) } O = "url(" + ee.url + "#" + b + ")", U.setAttribute(T, O), U.gradient = z, p.toString = function () { return O } } }) } css(p) { let T = this.styles, U = {}, ee = this.element, Z, H = !T; if (T && f(p, function (Y, S) { T && T[S] !== Y && (U[S] = Y, H = !0) }), H) { T && (p = G(T, U)), p.width === null || p.width === "auto" ? delete this.textWidth : ee.nodeName.toLowerCase() === "text" && p.width && (Z = this.textWidth = u(p.width)), this.styles = p, Z && !E && this.renderer.forExport && delete p.width; let Y = P(p); ee.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach(S => Y && delete Y[S]), Y.color && (Y.fill = Y.color)), k(ee, Y) } return this.added && (this.element.nodeName === "text" && this.renderer.buildText(this), p.textOutline && this.applyTextOutline(p.textOutline)), this } dashstyleSetter(p) { let T, U = this["stroke-width"]; if (U === "inherit" && (U = 1), p = p && p.toLowerCase()) { let ee = p.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); for (T = ee.length; T--;)ee[T] = "" + u(ee[T]) * o(U, NaN); p = ee.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", p) } } destroy() { var S; let p = this, T = p.element || {}, U = p.renderer, ee = T.ownerSVGElement, Z = T.nodeName === "SPAN" && p.parentGroup || void 0, H, Y; if (T.onclick = T.onmouseout = T.onmouseover = T.onmousemove = T.point = null, se(p), p.clipPath && ee) { let A = p.clipPath;[].forEach.call(ee.querySelectorAll("[clip-path],[CLIP-PATH]"), function (B) { B.getAttribute("clip-path").indexOf(A.element.id) > -1 && B.removeAttribute("clip-path") }), p.clipPath = A.destroy() } if (p.connector = (S = p.connector) == null ? void 0 : S.destroy(), p.stops) { for (Y = 0; Y < p.stops.length; Y++)p.stops[Y].destroy(); p.stops.length = 0, p.stops = void 0 } for (p.safeRemoveChild(T); Z && Z.div && Z.div.childNodes.length === 0;)H = Z.parentGroup, p.safeRemoveChild(Z.div), delete Z.div, Z = H; p.alignTo && L(U.alignedObjects, p), f(p, function (A, B) { p[B] && p[B].parentGroup === p && p[B].destroy && p[B].destroy(), delete p[B] }) } dSetter(p, T, U) { N(p) && (typeof p[0] == "string" && (p = this.renderer.pathToSegments(p)), this.pathArray = p, p = p.reduce((ee, Z, H) => Z && Z.join ? (H ? ee + " " : "") + Z.join(" ") : (Z || "").toString(), "")), /(NaN| {2}|^$)/.test(p) && (p = "M 0 0"), this[T] !== p && (U.setAttribute(T, p), this[T] = p) } fillSetter(p, T, U) { typeof p == "string" ? U.setAttribute(T, p) : p && this.complexColor(p, T, U) } hrefSetter(p, T, U) { U.setAttributeNS("http://www.w3.org/1999/xlink", T, p) } getBBox(p, T) { let U, ee, Z, H, Y, { alignValue: S, element: A, renderer: B, styles: K, textStr: c } = this, { cache: M, cacheKeys: b } = B, z = A.namespaceURI === this.SVG_NS, O = o(T, this.rotation, 0), q = B.styledMode ? A && d.prototype.getStyle.call(A, "font-size") : K && K.fontSize; if (w(c) && ((Y = c.toString()).indexOf("<") === -1 && (Y = Y.replace(/[0-9]/g, "0")), Y += ["", B.rootFontSize, q, O, this.textWidth, S, K && K.textOverflow, K && K.fontWeight].join(",")), Y && !p && (U = M[Y]), !U) { if (z || B.forExport) { try { H = this.fakeTS && function (ie) { let re = A.querySelector(".highcharts-text-outline"); re && k(re, { display: ie }) }, F(H) && H("none"), U = A.getBBox ? G({}, A.getBBox()) : { width: A.offsetWidth, height: A.offsetHeight, x: 0, y: 0 }, F(H) && H("") } catch { } (!U || U.width < 0) && (U = { x: 0, y: 0, width: 0, height: 0 }) } else U = this.htmlGetBBox(); if (ee = U.width, Z = U.height, z && (U.height = Z = { "11px,17": 14, "13px,20": 16 }[`${q || ""},${Math.round(Z)}`] || Z), O) { let ie = Number(A.getAttribute("y") || 0) - U.y, re = { right: 1, center: .5 }[S || 0] || 0, oe = O * $, he = (O - 90) * $, ce = ee * Math.cos(oe), pe = ee * Math.sin(oe), V = Math.cos(he), X = Math.sin(he), te = U.x + re * (ee - ce), ne = U.y + ie - re * pe, ae = te + ie * V, le = ae + ce, de = le - Z * V, ue = de - ce, ge = ne + ie * X, Se = ge + pe, fe = Se - Z * X, me = fe - pe; U.x = Math.min(ae, le, de, ue), U.y = Math.min(ge, Se, fe, me), U.width = Math.max(ae, le, de, ue) - U.x, U.height = Math.max(ge, Se, fe, me) - U.y } } if (Y && (c === "" || U.height > 0)) { for (; b.length > 250;)delete M[b.shift()]; M[Y] || b.push(Y), M[Y] = U } return U } getStyle(p) { return W.getComputedStyle(this.element || this, "").getPropertyValue(p) } hasClass(p) { return ("" + this.attr("class")).split(" ").indexOf(p) !== -1 } hide() { return this.attr({ visibility: "hidden" }) } htmlGetBBox() { return { height: 0, width: 0, x: 0, y: 0 } } constructor(p, T) { this.onEvents = {}, this.opacity = 1, this.SVG_NS = I, this.element = T === "span" ? v(T) : R.createElementNS(this.SVG_NS, T), this.renderer = p, _(this, "afterInit") } on(p, T) { let { onEvents: U } = this; return U[p] && U[p](), U[p] = y(this.element, p, T), this } opacitySetter(p, T, U) { let ee = Number(Number(p).toFixed(3)); this.opacity = ee, U.setAttribute(T, ee) } removeClass(p) { return this.attr("class", ("" + this.attr("class")).replace(x(p) ? RegExp(`(^| )${p}( |$)`) : p, " ").replace(/ +/g, " ").trim()) } removeTextOutline() { let p = this.element.querySelector("tspan.highcharts-text-outline"); p && this.safeRemoveChild(p) } safeRemoveChild(p) { let T = p.parentNode; T && T.removeChild(p) } setRadialReference(p) { let T = this.element.gradient && this.renderer.gradients[this.element.gradient]; return this.element.radialReference = p, T && T.radAttr && T.animate(this.renderer.getRadialAttr(p, T.radAttr)), this } setTextPath(p, T) { T = P(!0, { enabled: !0, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, T); let U = this.renderer.url, ee = this.text || this, Z = ee.textPath, { attributes: H, enabled: Y } = T; if (p = p || Z && Z.path, Z && Z.undo(), p && Y) { let S = y(ee, "afterModifyTree", A => { if (p && Y) { let B = p.attr("id"); B || p.attr("id", B = h()); let K = { x: 0, y: 0 }; w(H.dx) && (K.dx = H.dx, delete H.dx), w(H.dy) && (K.dy = H.dy, delete H.dy), ee.attr(K), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy()); let c = A.nodes.slice(0); A.nodes.length = 0, A.nodes[0] = { tagName: "textPath", attributes: G(H, { "text-anchor": H.textAnchor, href: `${U}#${B}` }), children: c } } }); ee.textPath = { path: p, undo: S } } else ee.attr({ dx: 0, dy: 0 }), delete ee.textPath; return this.added && (ee.textCache = "", this.renderer.buildText(ee)), this } shadow(p) { var Z; let { renderer: T } = this, U = P(((Z = this.parentGroup) == null ? void 0 : Z.rotation) === 90 ? { offsetX: -1, offsetY: -1 } : {}, C(p) ? p : {}), ee = T.shadowDefinition(U); return this.attr({ filter: p ? `url(${T.url}#${ee})` : "none" }) } show(p = !0) { return this.attr({ visibility: p ? "inherit" : "visible" }) } "stroke-widthSetter"(p, T, U) { this[T] = p, U.setAttribute(T, p) } strokeWidth() { if (!this.renderer.styledMode) return this["stroke-width"] || 0; let p = this.getStyle("stroke-width"), T = 0, U; return p.indexOf("px") === p.length - 2 ? T = u(p) : p !== "" && (a(U = R.createElementNS(I, "rect"), { width: p, "stroke-width": 0 }), this.element.parentNode.appendChild(U), T = U.getBBox().width, U.parentNode.removeChild(U)), T } symbolAttr(p) { let T = this; d.symbolCustomAttribs.forEach(function (U) { T[U] = o(p[U], T[U]) }), T.attr({ d: T.renderer.symbols[T.symbolName](T.x, T.y, T.width, T.height, T) }) } textSetter(p) { p !== this.textStr && (delete this.textPxLength, this.textStr = p, this.added && this.renderer.buildText(this)) } titleSetter(p) { let T = this.element, U = T.getElementsByTagName("title")[0] || R.createElementNS(this.SVG_NS, "title"); T.insertBefore ? T.insertBefore(U, T.firstChild) : T.appendChild(U), U.textContent = String(o(p, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">") } toFront() { let p = this.element; return p.parentNode.appendChild(p), this } translate(p, T) { return this.attr({ translateX: p, translateY: T }) } updateTransform(p = "transform") { let { element: T, matrix: U, rotation: ee = 0, scaleX: Z, scaleY: H, translateX: Y = 0, translateY: S = 0 } = this, A = ["translate(" + Y + "," + S + ")"]; w(U) && A.push("matrix(" + U.join(",") + ")"), ee && A.push("rotate(" + ee + " " + o(this.rotationOriginX, T.getAttribute("x"), 0) + " " + o(this.rotationOriginY, T.getAttribute("y") || 0) + ")"), (w(Z) || w(H)) && A.push("scale(" + o(Z, 1) + " " + o(H, 1) + ")"), A.length && !(this.text || this).textPath && T.setAttribute(p, A.join(" ")) } visibilitySetter(p, T, U) { p === "inherit" ? U.removeAttribute(T) : this[T] !== p && U.setAttribute(T, p), this[T] = p } xGetter(p) { return this.element.nodeName === "circle" && (p === "x" ? p = "cx" : p === "y" && (p = "cy")), this._defaultGetter(p) } zIndexSetter(p, T) { let U = this.renderer, ee = this.parentGroup, Z = ee || U, H = Z.element || U.box, Y = this.element, S = H === U.box, A, B, K, c = !1, M, b = this.added, z; if (w(p) ? (Y.setAttribute("data-z-index", p), p = +p, this[T] === p && (b = !1)) : w(this[T]) && Y.removeAttribute("data-z-index"), this[T] = p, b) { for ((p = this.zIndex) && ee && (ee.handleZ = !0), z = (A = H.childNodes).length - 1; z >= 0 && !c; z--)M = !w(K = (B = A[z]).getAttribute("data-z-index")), B !== Y && (p < 0 && M && !S && !z ? (H.insertBefore(Y, A[z]), c = !0) : (u(K) <= p || M && (!w(p) || p >= 0)) && (H.insertBefore(Y, A[z + 1]), c = !0)); c || (H.insertBefore(Y, A[S ? 3 : 0]), c = !0) } return c } } return d.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], d.prototype.strokeSetter = d.prototype.fillSetter, d.prototype.yGetter = d.prototype.xGetter, d.prototype.matrixSetter = d.prototype.rotationOriginXSetter = d.prototype.rotationOriginYSetter = d.prototype.rotationSetter = d.prototype.scaleXSetter = d.prototype.scaleYSetter = d.prototype.translateXSetter = d.prototype.translateYSetter = d.prototype.verticalAlignSetter = function (m, p) { this[p] = m, this.doTransform = !0 }, d }), n(i, "Core/Renderer/RendererRegistry.js", [i["Core/Globals.js"]], function (r) { var s, g; let j; return (g = s || (s = {})).rendererTypes = {}, g.getRendererType = function (D = j) { return g.rendererTypes[D] || g.rendererTypes[j] }, g.registerRendererType = function (D, J, se) { g.rendererTypes[D] = J, (!j || se) && (j = D, r.Renderer = J) }, s }), n(i, "Core/Renderer/SVG/SVGLabel.js", [i["Core/Renderer/SVG/SVGElement.js"], i["Core/Utilities.js"]], function (r, s) { let { defined: g, extend: j, isNumber: D, merge: J, pick: se, removeEvent: $ } = s; class R extends r { constructor(E, I, W, y, a, v, k, w, L, G) { let _; super(E, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.textStr = I, this.x = W, this.y = y, this.anchorX = v, this.anchorY = k, this.baseline = L, this.className = G, this.addClass(G === "button" ? "highcharts-no-tooltip" : "highcharts-label"), G && this.addClass("highcharts-" + G), this.text = E.text(void 0, 0, 0, w).attr({ zIndex: 1 }), typeof a == "string" && ((_ = /^url\((.*?)\)$/.test(a)) || this.renderer.symbols[a]) && (this.symbolKey = a), this.bBox = R.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = E.styledMode || _, this.deferredAttr = {}, this.alignFactor = 0 } alignSetter(E) { let I = { left: 0, center: .5, right: 1 }[E]; I !== this.alignFactor && (this.alignFactor = I, this.bBox && D(this.xSetting) && this.attr({ x: this.xSetting })) } anchorXSetter(E, I) { this.anchorX = E, this.boxAttr(I, Math.round(E) - this.getCrispAdjust() - this.xSetting) } anchorYSetter(E, I) { this.anchorY = E, this.boxAttr(I, E - this.ySetting) } boxAttr(E, I) { this.box ? this.box.attr(E, I) : this.deferredAttr[E] = I } css(E) { if (E) { let I = {}; E = J(E), R.textProps.forEach(W => { E[W] !== void 0 && (I[W] = E[W], delete E[W]) }), this.text.css(I), "fontSize" in I || "fontWeight" in I ? this.updateTextPadding() : ("width" in I || "textOverflow" in I) && this.updateBoxSize() } return r.prototype.css.call(this, E) } destroy() { $(this.element, "mouseenter"), $(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), r.prototype.destroy.call(this) } fillSetter(E, I) { E && (this.needsBox = !0), this.fill = E, this.boxAttr(I, E) } getBBox() { this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize(); let E = this.padding, I = se(this.paddingLeft, E); return { width: this.width || 0, height: this.height || 0, x: this.bBox.x - I, y: this.bBox.y - E } } getCrispAdjust() { return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2 } heightSetter(E) { this.heightSetting = E } onAdd() { this.text.add(this), this.attr({ text: se(this.textStr, ""), x: this.x || 0, y: this.y || 0 }), this.box && g(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY }) } paddingSetter(E, I) { D(E) ? E !== this[I] && (this[I] = E, this.updateTextPadding()) : this[I] = void 0 } rSetter(E, I) { this.boxAttr(I, E) } strokeSetter(E, I) { this.stroke = E, this.boxAttr(I, E) } "stroke-widthSetter"(E, I) { E && (this.needsBox = !0), this["stroke-width"] = E, this.boxAttr(I, E) } "text-alignSetter"(E) { this.textAlign = E } textSetter(E) { E !== void 0 && this.text.attr({ text: E }), this.updateTextPadding() } updateBoxSize() { let E, I = this.text, W = {}, y = this.padding, a = this.bBox = (!D(this.widthSetting) || !D(this.heightSetting) || this.textAlign) && g(I.textStr) ? I.getBBox() : R.emptyBBox; this.width = this.getPaddedWidth(), this.height = (this.heightSetting || a.height || 0) + 2 * y; let v = this.renderer.fontMetrics(I); if (this.baselineOffset = y + Math.min((this.text.firstLineMetrics || v).b, a.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - v.h) / 2), this.needsBox && !I.textPath) { if (!this.box) { let k = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(); k.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), k.add(this) } E = this.getCrispAdjust(), W.x = E, W.y = (this.baseline ? -this.baselineOffset : 0) + E, W.width = Math.round(this.width), W.height = Math.round(this.height), this.box.attr(j(W, this.deferredAttr)), this.deferredAttr = {} } } updateTextPadding() { let E = this.text; if (!E.textPath) { this.updateBoxSize(); let I = this.baseline ? 0 : this.baselineOffset, W = se(this.paddingLeft, this.padding); g(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right") && (W += { center: .5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width)), (W !== E.x || I !== E.y) && (E.attr("x", W), E.hasBoxWidthChanged && (this.bBox = E.getBBox(!0)), I !== void 0 && E.attr("y", I)), E.x = W, E.y = I } } widthSetter(E) { this.widthSetting = D(E) ? E : void 0 } getPaddedWidth() { let E = this.padding, I = se(this.paddingLeft, E), W = se(this.paddingRight, E); return (this.widthSetting || this.bBox.width || 0) + I + W } xSetter(E) { this.x = E, this.alignFactor && (E -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(E), this.attr("translateX", this.xSetting) } ySetter(E) { this.ySetting = this.y = Math.round(E), this.attr("translateY", this.ySetting) } } return R.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }, R.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"], R }), n(i, "Core/Renderer/SVG/Symbols.js", [i["Core/Utilities.js"]], function (r) { let { defined: s, isNumber: g, pick: j } = r; function D($, R, Q, E, I) { let W = []; if (I) { let y = I.start || 0, a = j(I.r, Q), v = j(I.r, E || Q), k = .001 > Math.abs((I.end || 0) - y - 2 * Math.PI), w = (I.end || 0) - .001, L = I.innerR, G = j(I.open, k), _ = Math.cos(y), N = Math.sin(y), F = Math.cos(w), C = Math.sin(w), x = j(I.longArc, w - y - Math.PI < .001 ? 0 : 1), P = ["A", a, v, 0, x, j(I.clockwise, 1), $ + a * F, R + v * C]; P.params = { start: y, end: w, cx: $, cy: R }, W.push(["M", $ + a * _, R + v * N], P), s(L) && ((P = ["A", L, L, 0, x, s(I.clockwise) ? 1 - I.clockwise : 0, $ + L * _, R + L * N]).params = { start: w, end: y, cx: $, cy: R }, W.push(G ? ["M", $ + L * F, R + L * C] : ["L", $ + L * F, R + L * C], P)), G || W.push(["Z"]) } return W } function J($, R, Q, E, I) { return I && I.r ? se($, R, Q, E, I) : [["M", $, R], ["L", $ + Q, R], ["L", $ + Q, R + E], ["L", $, R + E], ["Z"]] } function se($, R, Q, E, I) { let W = (I == null ? void 0 : I.r) || 0; return [["M", $ + W, R], ["L", $ + Q - W, R], ["A", W, W, 0, 0, 1, $ + Q, R + W], ["L", $ + Q, R + E - W], ["A", W, W, 0, 0, 1, $ + Q - W, R + E], ["L", $ + W, R + E], ["A", W, W, 0, 0, 1, $, R + E - W], ["L", $, R + W], ["A", W, W, 0, 0, 1, $ + W, R], ["Z"]] } return { arc: D, callout: function ($, R, Q, E, I) { let W = Math.min(I && I.r || 0, Q, E), y = W + 6, a = I && I.anchorX, v = I && I.anchorY || 0, k = se($, R, Q, E, { r: W }); if (!g(a) || a < Q && a > 0 && v < E && v > 0) return k; if ($ + a > Q - y) if (v > R + y && v < R + E - y) k.splice(3, 1, ["L", $ + Q, v - 6], ["L", $ + Q + 6, v], ["L", $ + Q, v + 6], ["L", $ + Q, R + E - W]); else if (a < Q) { let w = v < R + y, L = w ? R : R + E; k.splice(w ? 2 : 5, 0, ["L", a, v], ["L", $ + Q - W, L]) } else k.splice(3, 1, ["L", $ + Q, E / 2], ["L", a, v], ["L", $ + Q, E / 2], ["L", $ + Q, R + E - W]); else if ($ + a < y) if (v > R + y && v < R + E - y) k.splice(7, 1, ["L", $, v + 6], ["L", $ - 6, v], ["L", $, v - 6], ["L", $, R + W]); else if (a > 0) { let w = v < R + y, L = w ? R : R + E; k.splice(w ? 1 : 6, 0, ["L", a, v], ["L", $ + W, L]) } else k.splice(7, 1, ["L", $, E / 2], ["L", a, v], ["L", $, E / 2], ["L", $, R + W]); else v > E && a < Q - y ? k.splice(5, 1, ["L", a + 6, R + E], ["L", a, R + E + 6], ["L", a - 6, R + E], ["L", $ + W, R + E]) : v < 0 && a > y && k.splice(1, 1, ["L", a - 6, R], ["L", a, R - 6], ["L", a + 6, R], ["L", Q - W, R]); return k }, circle: function ($, R, Q, E) { return D($ + Q / 2, R + E / 2, Q / 2, E / 2, { start: .5 * Math.PI, end: 2.5 * Math.PI, open: !1 }) }, diamond: function ($, R, Q, E) { return [["M", $ + Q / 2, R], ["L", $ + Q, R + E / 2], ["L", $ + Q / 2, R + E], ["L", $, R + E / 2], ["Z"]] }, rect: J, roundedRect: se, square: J, triangle: function ($, R, Q, E) { return [["M", $ + Q / 2, R], ["L", $ + Q, R + E], ["L", $, R + E], ["Z"]] }, "triangle-down": function ($, R, Q, E) { return [["M", $, R], ["L", $ + Q, R], ["L", $ + Q / 2, R + E], ["Z"]] } } }), n(i, "Core/Renderer/SVG/TextBuilder.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g) { let { doc: j, SVG_NS: D, win: J } = s, { attr: se, extend: $, fireEvent: R, isString: Q, objectEach: E, pick: I } = g; return class { constructor(W) { let y = W.styles; this.renderer = W.renderer, this.svgElement = W, this.width = W.textWidth, this.textLineHeight = y && y.lineHeight, this.textOutline = y && y.textOutline, this.ellipsis = !!(y && y.textOverflow === "ellipsis"), this.noWrap = !!(y && y.whiteSpace === "nowrap") } buildSVG() { let W = this.svgElement, y = W.element, a = W.renderer, v = I(W.textStr, "").toString(), k = v.indexOf("<") !== -1, w = y.childNodes, L = !W.added && a.box, G = [v, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, W.getStyle("font-size"), this.width].join(","); if (G !== W.textCache) { W.textCache = G, delete W.actualWidth; for (let _ = w.length; _--;)y.removeChild(w[_]); if (k || this.ellipsis || this.width || W.textPath || v.indexOf(" ") !== -1 && (!this.noWrap || /<br.*?>/g.test(v))) { if (v !== "") { L && L.appendChild(y); let _ = new r(v); this.modifyTree(_.nodes), _.addToDOM(y), this.modifyDOM(), this.ellipsis && (y.textContent || "").indexOf("…") !== -1 && W.attr("title", this.unescapeEntities(W.textStr || "", ["&lt;", "&gt;"])), L && L.removeChild(y) } } else y.appendChild(j.createTextNode(this.unescapeEntities(v))); Q(this.textOutline) && W.applyTextOutline && W.applyTextOutline(this.textOutline) } } modifyDOM() { let W, y = this.svgElement, a = se(y.element, "x"); for (y.firstLineMetrics = void 0; (W = y.element.firstChild) && /^[\s\u200B]*$/.test(W.textContent || " ");)y.element.removeChild(W);[].forEach.call(y.element.querySelectorAll("tspan.highcharts-br"), (L, G) => { L.nextSibling && L.previousSibling && (G === 0 && L.previousSibling.nodeType === 1 && (y.firstLineMetrics = y.renderer.fontMetrics(L.previousSibling)), se(L, { dy: this.getLineHeight(L.nextSibling), x: a })) }); let v = this.width || 0; if (!v) return; let k = (L, G) => { let _ = L.textContent || "", N = _.replace(/([^\^])-/g, "$1- ").split(" "), F = !this.noWrap && (N.length > 1 || y.element.childNodes.length > 1), C = this.getLineHeight(G), x = 0, P = y.actualWidth; if (this.ellipsis) _ && this.truncate(L, _, void 0, 0, Math.max(0, v - .8 * C), (f, o) => f.substring(0, o) + "…"); else if (F) { let f = [], o = []; for (; G.firstChild && G.firstChild !== L;)o.push(G.firstChild), G.removeChild(G.firstChild); for (; N.length;)N.length && !this.noWrap && x > 0 && (f.push(L.textContent || ""), L.textContent = N.join(" ").replace(/- /g, "-")), this.truncate(L, void 0, N, x === 0 && P || 0, v, (u, l) => N.slice(0, l).join(" ").replace(/- /g, "-")), P = y.actualWidth, x++; o.forEach(u => { G.insertBefore(u, L) }), f.forEach(u => { G.insertBefore(j.createTextNode(u), L); let l = j.createElementNS(D, "tspan"); l.textContent = "​", se(l, { dy: C, x: a }), G.insertBefore(l, L) }) } }, w = L => { [].slice.call(L.childNodes).forEach(_ => { _.nodeType === J.Node.TEXT_NODE ? k(_, L) : (_.className.baseVal.indexOf("highcharts-br") !== -1 && (y.actualWidth = 0), w(_)) }) }; w(y.element) } getLineHeight(W) { let y = W.nodeType === J.Node.TEXT_NODE ? W.parentElement : W; return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(y || this.svgElement.element).h } modifyTree(W) { let y = (a, v) => { let { attributes: k = {}, children: w, style: L = {}, tagName: G } = a, _ = this.renderer.styledMode; if (G === "b" || G === "strong" ? _ ? k.class = "highcharts-strong" : L.fontWeight = "bold" : (G === "i" || G === "em") && (_ ? k.class = "highcharts-emphasized" : L.fontStyle = "italic"), L && L.color && (L.fill = L.color), G === "br") { k.class = "highcharts-br", a.textContent = "​"; let N = W[v + 1]; N && N.textContent && (N.textContent = N.textContent.replace(/^ +/gm, "")) } else G === "a" && w && w.some(N => N.tagName === "#text") && (a.children = [{ children: w, tagName: "tspan" }]); G !== "#text" && G !== "a" && (a.tagName = "tspan"), $(a, { attributes: k, style: L }), w && w.filter(N => N.tagName !== "#text").forEach(y) }; W.forEach(y), R(this.svgElement, "afterModifyTree", { nodes: W }) } truncate(W, y, a, v, k, w) { let L, G, _ = this.svgElement, { renderer: N, rotation: F } = _, C = [], x = a ? 1 : 0, P = (y || a || "").length, f = P, o = function (u, l) { let h = l || u, d = W.parentNode; if (d && C[h] === void 0 && d.getSubStringLength) try { C[h] = v + d.getSubStringLength(0, a ? h + 1 : h) } catch { } return C[h] }; if (_.rotation = 0, v + (G = o(W.textContent.length)) > k) { for (; x <= P;)f = Math.ceil((x + P) / 2), a && (L = w(a, f)), G = o(f, L && L.length - 1), x === P ? x = P + 1 : G > k ? P = f - 1 : x = f; P === 0 ? W.textContent = "" : y && P === y.length - 1 || (W.textContent = L || w(y || a, f)) } a && a.splice(0, f), _.actualWidth = G, _.rotation = F } unescapeEntities(W, y) { return E(this.renderer.escapes, function (a, v) { y && y.indexOf(a) !== -1 || (W = W.toString().replace(RegExp(a, "g"), v)) }), W } } }), n(i, "Core/Renderer/SVG/SVGRenderer.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Color/Color.js"], i["Core/Globals.js"], i["Core/Renderer/RendererRegistry.js"], i["Core/Renderer/SVG/SVGElement.js"], i["Core/Renderer/SVG/SVGLabel.js"], i["Core/Renderer/SVG/Symbols.js"], i["Core/Renderer/SVG/TextBuilder.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J, se, $, R) { let Q, { charts: E, deg2rad: I, doc: W, isFirefox: y, isMS: a, isWebKit: v, noop: k, SVG_NS: w, symbolSizes: L, win: G } = g, { addEvent: _, attr: N, createElement: F, css: C, defined: x, destroyObjectProperties: P, extend: f, isArray: o, isNumber: u, isObject: l, isString: h, merge: d, pick: m, pInt: p, uniqueKey: T } = R; class U { constructor(Z, H, Y, S, A, B, K) { let c, M, b = this.createElement("svg").attr({ version: "1.1", class: "highcharts-root" }), z = b.element; K || b.css(this.getStyle(S || {})), Z.appendChild(z), N(Z, "dir", "ltr"), Z.innerHTML.indexOf("xmlns") === -1 && N(z, "xmlns", this.SVG_NS), this.box = z, this.boxWrapper = b, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(W.createTextNode("Created with Highcharts 11.3.0")), this.defs = this.createElement("defs").add(), this.allowHTML = B, this.forExport = A, this.styledMode = K, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = b.getStyle("font-size"), this.setSize(H, Y, !1), y && Z.getBoundingClientRect && ((c = function () { C(Z, { left: 0, top: 0 }), M = Z.getBoundingClientRect(), C(Z, { left: Math.ceil(M.left) - M.left + "px", top: Math.ceil(M.top) - M.top + "px" }) })(), this.unSubPixelFix = _(G, "resize", c)) } definition(Z) { return new r([Z]).addToDOM(this.defs.element) } getReferenceURL() { if ((y || v) && W.getElementsByTagName("base").length) { if (!x(Q)) { let Z = T(), H = new r([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: Z }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${Z})`, fill: "rgba(0,0,0,0.001)" } }] }]), Y = H.addToDOM(W.body); C(Y, { position: "fixed", top: 0, left: 0, zIndex: 9e5 }); let S = W.elementFromPoint(6, 6); Q = (S && S.id) === "hitme", W.body.removeChild(Y) } if (Q) return G.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") } return "" } getStyle(Z) { return this.style = f({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, Z), this.style } setStyle(Z) { this.boxWrapper.css(this.getStyle(Z)) } isHidden() { return !this.boxWrapper.getBBox().width } destroy() { let Z = this.defs; return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), P(this.gradients || {}), this.gradients = null, this.defs = Z.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null } createElement(Z) { return new this.Element(this, Z) } getRadialAttr(Z, H) { return { cx: Z[0] - Z[2] / 2 + (H.cx || 0) * Z[2], cy: Z[1] - Z[2] / 2 + (H.cy || 0) * Z[2], r: (H.r || 0) * Z[2] } } shadowDefinition(Z) { let H = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(Z).map(S => `${S}-${Z[S]}`)].join("-").toLowerCase().replace(/[^a-z0-9\-]/g, ""), Y = d({ color: "#000000", offsetX: 1, offsetY: 1, opacity: .15, width: 5 }, Z); return this.defs.element.querySelector(`#${H}`) || this.definition({ tagName: "filter", attributes: { id: H, filterUnits: Y.filterUnits }, children: [{ tagName: "feDropShadow", attributes: { dx: Y.offsetX, dy: Y.offsetY, "flood-color": Y.color, "flood-opacity": Math.min(5 * Y.opacity, 1), stdDeviation: Y.width / 2 } }] }), H } buildText(Z) { new $(Z).buildSVG() } getContrast(Z) { let H = s.parse(Z).rgba.map(S => { let A = S / 255; return A <= .03928 ? A / 12.92 : Math.pow((A + .055) / 1.055, 2.4) }), Y = .2126 * H[0] + .7152 * H[1] + .0722 * H[2]; return 1.05 / (Y + .05) > (Y + .05) / .05 ? "#FFFFFF" : "#000000" } button(Z, H, Y, S, A = {}, B, K, c, M, b) { let z, O, q, ie = this.label(Z, H, Y, M, void 0, void 0, b, void 0, "button"), re = this.styledMode, oe = A.states || {}, he = 0; A = d(A), delete A.states; let ce = d({ color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, A.style); delete A.style; let pe = r.filterUserAttributes(A); return ie.attr(d({ padding: 8, r: 2 }, pe)), re || (pe = d({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, pe), z = (B = d(pe, { fill: "#e6e6e6" }, r.filterUserAttributes(B || oe.hover || {}))).style, delete B.style, O = (K = d(pe, { fill: "#e6e9ff", style: { color: "#000000", fontWeight: "bold" } }, r.filterUserAttributes(K || oe.select || {}))).style, delete K.style, q = (c = d(pe, { style: { color: "#cccccc" } }, r.filterUserAttributes(c || oe.disabled || {}))).style, delete c.style), _(ie.element, a ? "mouseover" : "mouseenter", function () { he !== 3 && ie.setState(1) }), _(ie.element, a ? "mouseout" : "mouseleave", function () { he !== 3 && ie.setState(he) }), ie.setState = function (V) { if (V !== 1 && (ie.state = he = V), ie.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][V || 0]), !re) { ie.attr([pe, B, K, c][V || 0]); let X = [ce, z, O, q][V || 0]; l(X) && ie.css(X) } }, !re && (ie.attr(pe).css(f({ cursor: "default" }, ce)), b && ie.text.css({ pointerEvents: "none" })), ie.on("touchstart", V => V.stopPropagation()).on("click", function (V) { he !== 3 && S.call(ie, V) }) } crispLine(Z, H, Y = "round") { let S = Z[0], A = Z[1]; return x(S[1]) && S[1] === A[1] && (S[1] = A[1] = Math[Y](S[1]) - H % 2 / 2), x(S[2]) && S[2] === A[2] && (S[2] = A[2] = Math[Y](S[2]) + H % 2 / 2), Z } path(Z) { let H = this.styledMode ? {} : { fill: "none" }; return o(Z) ? H.d = Z : l(Z) && f(H, Z), this.createElement("path").attr(H) } circle(Z, H, Y) { let S = l(Z) ? Z : Z === void 0 ? {} : { x: Z, y: H, r: Y }, A = this.createElement("circle"); return A.xSetter = A.ySetter = function (B, K, c) { c.setAttribute("c" + K, B) }, A.attr(S) } arc(Z, H, Y, S, A, B) { let K; l(Z) ? (H = (K = Z).y, Y = K.r, S = K.innerR, A = K.start, B = K.end, Z = K.x) : K = { innerR: S, start: A, end: B }; let c = this.symbol("arc", Z, H, Y, Y, K); return c.r = Y, c } rect(Z, H, Y, S, A, B) { let K = l(Z) ? Z : Z === void 0 ? {} : { x: Z, y: H, r: A, width: Math.max(Y || 0, 0), height: Math.max(S || 0, 0) }, c = this.createElement("rect"); return this.styledMode || (B !== void 0 && (K["stroke-width"] = B, f(K, c.crisp(K))), K.fill = "none"), c.rSetter = function (M, b, z) { c.r = M, N(z, { rx: M, ry: M }) }, c.rGetter = function () { return c.r || 0 }, c.attr(K) } roundedRect(Z) { return this.symbol("roundedRect").attr(Z) } setSize(Z, H, Y) { this.width = Z, this.height = H, this.boxWrapper.animate({ width: Z, height: H }, { step: function () { this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") }) }, duration: m(Y, !0) ? void 0 : 0 }), this.alignElements() } g(Z) { let H = this.createElement("g"); return Z ? H.attr({ class: "highcharts-" + Z }) : H } image(Z, H, Y, S, A, B) { let K = { preserveAspectRatio: "none" }; u(H) && (K.x = H), u(Y) && (K.y = Y), u(S) && (K.width = S), u(A) && (K.height = A); let c = this.createElement("image").attr(K), M = function (b) { c.attr({ href: Z }), B.call(c, b) }; if (B) { c.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" }); let b = new G.Image; _(b, "load", M), b.src = Z, b.complete && M({}) } else c.attr({ href: Z }); return c } symbol(Z, H, Y, S, A, B) { let K, c, M, b, z = this, O = /^url\((.*?)\)$/, q = O.test(Z), ie = !q && (this.symbols[Z] ? Z : "circle"), re = ie && this.symbols[ie]; if (re) typeof H == "number" && (c = re.call(this.symbols, Math.round(H || 0), Math.round(Y || 0), S || 0, A || 0, B)), K = this.path(c), z.styledMode || K.attr("fill", "none"), f(K, { symbolName: ie || void 0, x: H, y: Y, width: S, height: A }), B && f(K, B); else if (q) { M = Z.match(O)[1]; let oe = K = this.image(M); oe.imgwidth = m(B && B.width, L[M] && L[M].width), oe.imgheight = m(B && B.height, L[M] && L[M].height), b = he => he.attr({ width: he.width, height: he.height }), ["width", "height"].forEach(he => { oe[`${he}Setter`] = function (ce, pe) { this[pe] = ce; let { alignByTranslate: V, element: X, width: te, height: ne, imgwidth: ae, imgheight: le } = this, de = pe === "width" ? ae : le, ue = 1; B && B.backgroundSize === "within" && te && ne && ae && le ? (ue = Math.min(te / ae, ne / le), N(X, { width: Math.round(ae * ue), height: Math.round(le * ue) })) : X && de && X.setAttribute(pe, de), !V && ae && le && this.translate(((te || 0) - ae * ue) / 2, ((ne || 0) - le * ue) / 2) } }), x(H) && oe.attr({ x: H, y: Y }), oe.isImg = !0, x(oe.imgwidth) && x(oe.imgheight) ? b(oe) : (oe.attr({ width: 0, height: 0 }), F("img", { onload: function () { let he = E[z.chartIndex]; this.width === 0 && (C(this, { position: "absolute", top: "-999em" }), W.body.appendChild(this)), L[M] = { width: this.width, height: this.height }, oe.imgwidth = this.width, oe.imgheight = this.height, oe.element && b(oe), this.parentNode && this.parentNode.removeChild(this), z.imgCount--, z.imgCount || !he || he.hasLoaded || he.onload() }, src: M }), this.imgCount++) } return K } clipRect(Z, H, Y, S) { return this.rect(Z, H, Y, S, 0) } text(Z, H, Y, S) { let A = {}; if (S && (this.allowHTML || !this.forExport)) return this.html(Z, H, Y); A.x = Math.round(H || 0), Y && (A.y = Math.round(Y)), x(Z) && (A.text = Z); let B = this.createElement("text").attr(A); return S && (!this.forExport || this.allowHTML) || (B.xSetter = function (K, c, M) { let b = M.getElementsByTagName("tspan"), z = M.getAttribute(c); for (let O = 0, q; O < b.length; O++)(q = b[O]).getAttribute(c) === z && q.setAttribute(c, K); M.setAttribute(c, K) }), B } fontMetrics(Z) { let H = p(D.prototype.getStyle.call(Z, "font-size") || 0), Y = H < 24 ? H + 3 : Math.round(1.2 * H), S = Math.round(.8 * Y); return { h: Y, b: S, f: H } } rotCorr(Z, H, Y) { let S = Z; return H && Y && (S = Math.max(S * Math.cos(H * I), 4)), { x: -Z / 3 * Math.sin(H * I), y: S } } pathToSegments(Z) { let H = [], Y = [], S = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 }; for (let A = 0; A < Z.length; A++)h(Y[0]) && u(Z[A]) && Y.length === S[Y[0].toUpperCase()] && Z.splice(A, 0, Y[0].replace("M", "L").replace("m", "l")), typeof Z[A] == "string" && (Y.length && H.push(Y.slice(0)), Y.length = 0), Y.push(Z[A]); return H.push(Y.slice(0)), H } label(Z, H, Y, S, A, B, K, c, M) { return new J(this, Z, H, Y, S, A, B, K, c, M) } alignElements() { this.alignedObjects.forEach(Z => Z.align()) } } return f(U.prototype, { Element: D, SVG_NS: w, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, symbols: se, draw: k }), j.registerRendererType("svg", U, !0), U }), n(i, "Core/Renderer/HTML/HTMLElement.js", [i["Core/Globals.js"], i["Core/Renderer/SVG/SVGElement.js"], i["Core/Utilities.js"]], function (r, s, g) { let { composed: j } = r, { css: D, defined: J, extend: se, pushUnique: $, pInt: R } = g; class Q extends s { static compose(I) { if ($(j, this.compose)) { let W = Q.prototype, y = I.prototype; y.getSpanCorrection = W.getSpanCorrection, y.htmlCss = W.htmlCss, y.htmlGetBBox = W.htmlGetBBox, y.htmlUpdateTransform = W.htmlUpdateTransform, y.setSpanRotation = W.setSpanRotation } return I } getSpanCorrection(I, W, y) { this.xCorr = -I * y, this.yCorr = -W } htmlCss(I) { let W, { element: y } = this, a = y.tagName === "SPAN" && I && "width" in I, v = a && I.width; return a && (delete I.width, this.textWidth = R(v) || void 0, W = !0), (I == null ? void 0 : I.textOverflow) === "ellipsis" && (I.whiteSpace = "nowrap", I.overflow = "hidden"), se(this.styles, I), D(y, I), W && this.htmlUpdateTransform(), this } htmlGetBBox() { let { element: I } = this; return { x: I.offsetLeft, y: I.offsetTop, width: I.offsetWidth, height: I.offsetHeight } } htmlUpdateTransform() { if (!this.added) { this.alignOnAdd = !0; return } let { element: I, renderer: W, rotation: y, styles: a, textAlign: v = "left", textWidth: k, translateX: w = 0, translateY: L = 0, x: G = 0, y: _ = 0 } = this, N = { left: 0, center: .5, right: 1 }[v], F = a == null ? void 0 : a.whiteSpace; if (D(I, { marginLeft: `${w}px`, marginTop: `${L}px` }), I.tagName === "SPAN") { let C = [y, v, I.innerHTML, k, this.textAlign].join(","), x, P = !1; if (k !== this.oldTextWidth) { let f = this.textPxLength ? this.textPxLength : (D(I, { width: "", whiteSpace: F || "nowrap" }), I.offsetWidth), o = k || 0; (o > this.oldTextWidth || f > o) && (/[ \-]/.test(I.textContent || I.innerText) || I.style.textOverflow === "ellipsis") && (D(I, { width: f > o || y ? k + "px" : "auto", display: "block", whiteSpace: F || "normal" }), this.oldTextWidth = k, P = !0) } this.hasBoxWidthChanged = P, C !== this.cTT && (x = W.fontMetrics(I).b, J(y) && (y !== (this.oldRotation || 0) || v !== this.oldAlign) && this.setSpanRotation(y, N, x), this.getSpanCorrection(!J(y) && this.textPxLength || I.offsetWidth, x, N)), D(I, { left: G + (this.xCorr || 0) + "px", top: _ + (this.yCorr || 0) + "px" }), this.cTT = C, this.oldRotation = y, this.oldAlign = v } } setSpanRotation(I, W, y) { D(this.element, { transform: `rotate(${I}deg)`, transformOrigin: `${100 * W}% ${y}px` }) } } return Q }), n(i, "Core/Renderer/HTML/HTMLRenderer.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Globals.js"], i["Core/Renderer/SVG/SVGElement.js"], i["Core/Renderer/SVG/SVGRenderer.js"], i["Core/Utilities.js"]], function (r, s, g, j, D) { let { composed: J } = s, { attr: se, createElement: $, extend: R, pick: Q, pushUnique: E } = D; class I extends j { static compose(y) { if (E(J, this.compose)) { let a = I.prototype, v = y.prototype; v.html = a.html } return y } html(y, a, v) { let k = this.createElement("span"), w = k.element, L = k.renderer, G = function (_, N) { ["opacity", "visibility"].forEach(function (F) { _[F + "Setter"] = function (C, x, P) { let f = _.div ? _.div.style : N; g.prototype[F + "Setter"].call(this, C, x, P), f && (f[x] = C) } }), _.addedSetters = !0 }; return k.textSetter = function (_) { _ !== this.textStr && (delete this.bBox, delete this.oldTextWidth, r.setElementHTML(this.element, Q(_, "")), this.textStr = _, k.doTransform = !0) }, G(k, k.element.style), k.xSetter = k.ySetter = k.alignSetter = k.rotationSetter = function (_, N) { N === "align" ? k.alignValue = k.textAlign = _ : k[N] = _, k.doTransform = !0 }, k.afterSetters = function () { this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1) }, k.attr({ text: y, x: Math.round(a), y: Math.round(v) }).css({ position: "absolute" }), L.styledMode || k.css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize }), w.style.whiteSpace = "nowrap", k.css = k.htmlCss, k.add = function (_) { let N, F, C = L.box.parentNode, x = []; if (this.parentGroup = _, _) { if (!(N = _.div)) { for (F = _; F;)x.push(F), F = F.parentGroup; x.reverse().forEach(function (P) { var f; let o = se(P.element, "class"), u = P.css; function l(m, p) { P[p] = m, p === "translateX" ? d.left = m + "px" : d.top = m + "px", P.doTransform = !0 } let h = P.styles || {}; N = P.div = P.div || $("div", o ? { className: o } : void 0, { position: "absolute", left: (P.translateX || 0) + "px", top: (P.translateY || 0) + "px", display: P.display, opacity: P.opacity, visibility: P.visibility }, N || C); let d = N.style; R(P, { classSetter: (f = N, function (m) { this.element.setAttribute("class", m), f.className = m }), css: function (m) { return u.call(P, m), ["cursor", "pointerEvents"].forEach(p => { m[p] && (d[p] = m[p]) }), P }, on: function () { return x[0].div && k.on.apply({ element: x[0].div, onEvents: P.onEvents }, arguments), P }, translateXSetter: l, translateYSetter: l }), P.addedSetters || G(P), P.css(h) }) } } else N = C; return N.appendChild(w), k.added = !0, k.alignOnAdd && k.htmlUpdateTransform(), k }, k } } return I }), n(i, "Core/Axis/AxisDefaults.js", [], function () { var r, s; return (s = r || (r = {})).xAxis = { alignTicks: !0, allowDecimals: void 0, panningEnabled: !0, zIndex: 2, zoomEnabled: !0, dateTimeLabelFormats: { millisecond: { main: "%H:%M:%S.%L", range: !1 }, second: { main: "%H:%M:%S", range: !1 }, minute: { main: "%H:%M", range: !1 }, hour: { main: "%H:%M", range: !1 }, day: { main: "%e %b" }, week: { main: "%e %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } }, endOnTick: !1, gridLineDashStyle: "Solid", gridZIndex: 1, labels: { autoRotationLimit: 80, distance: 15, enabled: !0, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: !1, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em" } }, maxPadding: .01, minorGridLineDashStyle: "Solid", minorTickLength: 2, minorTickPosition: "outside", minorTicksPerMajor: 5, minPadding: .01, offset: void 0, reversed: void 0, reversedStacks: !1, showEmpty: !0, showFirstLabel: !0, showLastLabel: !0, startOfWeek: 1, startOnTick: !1, tickLength: 10, tickPixelInterval: 100, tickmarkPlacement: "between", tickPosition: "outside", title: { align: "middle", useHTML: !1, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } }, type: "linear", uniqueNames: !0, visible: !0, minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999", lineColor: "#333333", lineWidth: 1, gridLineColor: "#e6e6e6", gridLineWidth: void 0, tickColor: "#333333" }, s.yAxis = { reversedStacks: !0, endOnTick: !0, maxPadding: .05, minPadding: .05, tickPixelInterval: 72, showLastLabel: !0, labels: { x: void 0 }, startOnTick: !0, title: { text: "Values" }, stackLabels: { animation: {}, allowOverlap: !1, enabled: !1, crop: !0, overflow: "justify", formatter: function () { let { numberFormatter: g } = this.axis.chart; return g(this.total || 0, -1) }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } }, gridLineWidth: 1, lineWidth: 0 }, r }), n(i, "Core/Foundation.js", [i["Core/Utilities.js"]], function (r) { var s; let { addEvent: g, isFunction: j, objectEach: D, removeEvent: J } = r; return (s || (s = {})).registerEventOptions = function (se, $) { se.eventOptions = se.eventOptions || {}, D($.events, function (R, Q) { se.eventOptions[Q] !== R && (se.eventOptions[Q] && (J(se, Q, se.eventOptions[Q]), delete se.eventOptions[Q]), j(R) && (se.eventOptions[Q] = R, g(se, Q, R, { order: 0 }))) }) }, s }), n(i, "Core/Axis/Tick.js", [i["Core/Templating.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g) { let { deg2rad: j } = s, { clamp: D, correctFloat: J, defined: se, destroyObjectProperties: $, extend: R, fireEvent: Q, isNumber: E, merge: I, objectEach: W, pick: y } = g; return class { constructor(a, v, k, w, L) { this.isNew = !0, this.isNewLabel = !0, this.axis = a, this.pos = v, this.type = k || "", this.parameters = L || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, Q(this, "init"), k || w || this.addLabel() } addLabel() { let a = this, v = a.axis, k = v.options, w = v.chart, L = v.categories, G = v.logarithmic, _ = v.names, N = a.pos, F = y(a.options && a.options.labels, k.labels), C = v.tickPositions, x = N === C[0], P = N === C[C.length - 1], f = (!F.step || F.step === 1) && v.tickInterval === 1, o = C.info, u = a.label, l, h, d, m = this.parameters.category || (L ? y(L[N], _[N], N) : N); G && E(m) && (m = J(G.lin2log(m))), v.dateTime && (o ? l = (h = w.time.resolveDTLFormat(k.dateTimeLabelFormats[!k.grid && o.higherRanks[N] || o.unitName])).main : E(m) && (l = v.dateTime.getXDateFormat(m, k.dateTimeLabelFormats || {}))), a.isFirst = x, a.isLast = P; let p = { axis: v, chart: w, dateTimeLabelFormat: l, isFirst: x, isLast: P, pos: N, tick: a, tickPositionInfo: o, value: m }; Q(this, "labelFormat", p); let T = Z => F.formatter ? F.formatter.call(Z, Z) : F.format ? (Z.text = v.defaultLabelFormatter.call(Z, Z), r.format(F.format, Z, w)) : v.defaultLabelFormatter.call(Z, Z), U = T.call(p, p), ee = h && h.list; ee ? a.shortenLabel = function () { for (d = 0; d < ee.length; d++)if (R(p, { dateTimeLabelFormat: ee[d] }), u.attr({ text: T.call(p, p) }), u.getBBox().width < v.getSlotWidth(a) - 2 * F.padding) return; u.attr({ text: "" }) } : a.shortenLabel = void 0, f && v._addedPlotLB && a.moveLabel(U, F), se(u) || a.movedLabel ? u && u.textStr !== U && !f && (!u.textWidth || F.style.width || u.styles.width || u.css({ width: null }), u.attr({ text: U }), u.textPxLength = u.getBBox().width) : (a.label = u = a.createLabel(U, F), a.rotation = 0) } createLabel(a, v, k) { let w = this.axis, L = w.chart, G = se(a) && v.enabled ? L.renderer.text(a, k == null ? void 0 : k.x, k == null ? void 0 : k.y, v.useHTML).add(w.labelGroup) : void 0; return G && (L.styledMode || G.css(I(v.style)), G.textPxLength = G.getBBox().width), G } destroy() { $(this, this.axis) } getPosition(a, v, k, w) { let L = this.axis, G = L.chart, _ = w && G.oldChartHeight || G.chartHeight, N = { x: a ? J(L.translate(v + k, void 0, void 0, w) + L.transB) : L.left + L.offset + (L.opposite ? (w && G.oldChartWidth || G.chartWidth) - L.right - L.left : 0), y: a ? _ - L.bottom + L.offset - (L.opposite ? L.height : 0) : J(_ - L.translate(v + k, void 0, void 0, w) - L.transB) }; return N.y = D(N.y, -1e5, 1e5), Q(this, "afterGetPosition", { pos: N }), N } getLabelPosition(a, v, k, w, L, G, _, N) { let F, C, x = this.axis, P = x.transA, f = x.isLinked && x.linkedParent ? x.linkedParent.reversed : x.reversed, o = x.staggerLines, u = x.tickRotCorr || { x: 0, y: 0 }, l = w || x.reserveSpaceDefault ? 0 : -x.labelOffset * (x.labelAlign === "center" ? .5 : 1), h = L.distance, d = {}; return F = x.side === 0 ? k.rotation ? -h : -k.getBBox().height : x.side === 2 ? u.y + h : Math.cos(k.rotation * j) * (u.y - k.getBBox(!1, 0).height / 2), se(L.y) && (F = x.side === 0 && x.horiz ? L.y + F : L.y), a = a + y(L.x, [0, 1, 0, -1][x.side] * h) + l + u.x - (G && w ? G * P * (f ? -1 : 1) : 0), v = v + F - (G && !w ? G * P * (f ? 1 : -1) : 0), o && (C = _ / (N || 1) % o, x.opposite && (C = o - C - 1), v += C * (x.labelOffset / o)), d.x = a, d.y = Math.round(v), Q(this, "afterGetLabelPosition", { pos: d, tickmarkOffset: G, index: _ }), d } getLabelSize() { return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0 } getMarkPath(a, v, k, w, L, G) { return G.crispLine([["M", a, v], ["L", a + (L ? 0 : -k), v + (L ? k : 0)]], w) } handleOverflow(a) { let v = this.axis, k = v.options.labels, w = a.x, L = v.chart.chartWidth, G = v.chart.spacing, _ = y(v.labelLeft, Math.min(v.pos, G[3])), N = y(v.labelRight, Math.max(v.isRadial ? 0 : v.pos + v.len, L - G[1])), F = this.label, C = this.rotation, x = { left: 0, center: .5, right: 1 }[v.labelAlign || F.attr("align")], P = F.getBBox().width, f = v.getSlotWidth(this), o = {}, u = f, l = 1, h; C || k.overflow !== "justify" ? C < 0 && w - x * P < _ ? h = Math.round(w / Math.cos(C * j) - _) : C > 0 && w + x * P > N && (h = Math.round((L - w) / Math.cos(C * j))) : (w - x * P < _ ? u = a.x + u * (1 - x) - _ : w + (1 - x) * P > N && (u = N - a.x + u * x, l = -1), (u = Math.min(f, u)) < f && v.labelAlign === "center" && (a.x += l * (f - u - x * (f - Math.min(P, u)))), (P > u || v.autoRotation && (F.styles || {}).width) && (h = u)), h && (this.shortenLabel ? this.shortenLabel() : (o.width = Math.floor(h) + "px", (k.style || {}).textOverflow || (o.textOverflow = "ellipsis"), F.css(o))) } moveLabel(a, v) { let k = this, w = k.label, L = k.axis, G = !1, _; w && w.textStr === a ? (k.movedLabel = w, G = !0, delete k.label) : W(L.ticks, function (N) { G || N.isNew || N === k || !N.label || N.label.textStr !== a || (k.movedLabel = N.label, G = !0, N.labelPos = k.movedLabel.xy, delete N.label) }), !G && (k.labelPos || w) && (_ = k.labelPos || w.xy, k.movedLabel = k.createLabel(a, v, _), k.movedLabel && k.movedLabel.attr({ opacity: 0 })) } render(a, v, k) { let w = this.axis, L = w.horiz, G = this.pos, _ = y(this.tickmarkOffset, w.tickmarkOffset), N = this.getPosition(L, G, _, v), F = N.x, C = N.y, x = L && F === w.pos + w.len || !L && C === w.pos ? -1 : 1, P = y(k, this.label && this.label.newOpacity, 1); k = y(k, 1), this.isActive = !0, this.renderGridLine(v, k, x), this.renderMark(N, k, x), this.renderLabel(N, v, P, a), this.isNew = !1, Q(this, "afterRender") } renderGridLine(a, v, k) { let w = this.axis, L = w.options, G = {}, _ = this.pos, N = this.type, F = y(this.tickmarkOffset, w.tickmarkOffset), C = w.chart.renderer, x = this.gridLine, P, f = L.gridLineWidth, o = L.gridLineColor, u = L.gridLineDashStyle; this.type === "minor" && (f = L.minorGridLineWidth, o = L.minorGridLineColor, u = L.minorGridLineDashStyle), x || (w.chart.styledMode || (G.stroke = o, G["stroke-width"] = f || 0, G.dashstyle = u), N || (G.zIndex = 1), a && (v = 0), this.gridLine = x = C.path().attr(G).addClass("highcharts-" + (N ? N + "-" : "") + "grid-line").add(w.gridGroup)), x && (P = w.getPlotLinePath({ value: _ + F, lineWidth: x.strokeWidth() * k, force: "pass", old: a, acrossPanes: !1 })) && x[a || this.isNew ? "attr" : "animate"]({ d: P, opacity: v }) } renderMark(a, v, k) { let w = this.axis, L = w.options, G = w.chart.renderer, _ = this.type, N = w.tickSize(_ ? _ + "Tick" : "tick"), F = a.x, C = a.y, x = y(L[_ !== "minor" ? "tickWidth" : "minorTickWidth"], !_ && w.isXAxis ? 1 : 0), P = L[_ !== "minor" ? "tickColor" : "minorTickColor"], f = this.mark, o = !f; N && (w.opposite && (N[0] = -N[0]), f || (this.mark = f = G.path().addClass("highcharts-" + (_ ? _ + "-" : "") + "tick").add(w.axisGroup), w.chart.styledMode || f.attr({ stroke: P, "stroke-width": x })), f[o ? "attr" : "animate"]({ d: this.getMarkPath(F, C, N[0], f.strokeWidth() * k, w.horiz, G), opacity: v })) } renderLabel(a, v, k, w) { let L = this.axis, G = L.horiz, _ = L.options, N = this.label, F = _.labels, C = F.step, x = y(this.tickmarkOffset, L.tickmarkOffset), P = a.x, f = a.y, o = !0; N && E(P) && (N.xy = a = this.getLabelPosition(P, f, N, G, F, x, w, C), (!this.isFirst || this.isLast || _.showFirstLabel) && (!this.isLast || this.isFirst || _.showLastLabel) ? !G || F.step || F.rotation || v || k === 0 || this.handleOverflow(a) : o = !1, C && w % C && (o = !1), o && E(a.y) ? (a.opacity = k, N[this.isNewLabel ? "attr" : "animate"](a).show(!0), this.isNewLabel = !1) : (N.hide(), this.isNewLabel = !0)) } replaceMovedLabel() { let a = this.label, v = this.axis; a && !this.isNew && (a.animate({ opacity: 0 }, void 0, a.destroy), delete this.label), v.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel } } }), n(i, "Core/Axis/Axis.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Axis/AxisDefaults.js"], i["Core/Color/Color.js"], i["Core/Defaults.js"], i["Core/Foundation.js"], i["Core/Globals.js"], i["Core/Axis/Tick.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J, se, $) { let { animObject: R } = r, { xAxis: Q, yAxis: E } = s, { defaultOptions: I } = j, { registerEventOptions: W } = D, { deg2rad: y } = J, { arrayMax: a, arrayMin: v, clamp: k, correctFloat: w, defined: L, destroyObjectProperties: G, erase: _, error: N, extend: F, fireEvent: C, getClosestDistance: x, insertItem: P, isArray: f, isNumber: o, isString: u, merge: l, normalizeTickInterval: h, objectEach: d, pick: m, relativeLength: p, removeEvent: T, splat: U, syncTimeout: ee } = $, Z = (Y, S) => h(S, void 0, void 0, m(Y.options.allowDecimals, S < .5 || Y.tickAmount !== void 0), !!Y.tickAmount); F(I, { xAxis: Q, yAxis: l(Q, E) }); class H { constructor(S, A, B) { this.init(S, A, B) } init(S, A, B = this.coll) { let K = B === "xAxis", c = this.isZAxis || (S.inverted ? !K : K); this.chart = S, this.horiz = c, this.isXAxis = K, this.coll = B, C(this, "init", { userOptions: A }), this.opposite = m(A.opposite, this.opposite), this.side = m(A.side, this.side, c ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(A); let M = this.options, b = M.labels, z = M.type; this.userOptions = A, this.minPixelPadding = 0, this.reversed = m(M.reversed, this.reversed), this.visible = M.visible, this.zoomEnabled = M.zoomEnabled, this.hasNames = z === "category" || M.categories === !0, this.categories = f(M.categories) && M.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = L(M.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = M.minRange || M.maxZoom, this.range = M.range, this.offset = M.offset || 0, this.max = void 0, this.min = void 0; let O = m(M.crosshair, U(S.options.tooltip.crosshairs)[K ? 0 : 1]); this.crosshair = O === !0 ? {} : O, S.axes.indexOf(this) === -1 && (K ? S.axes.splice(S.xAxis.length, 0, this) : S.axes.push(this), P(this, S[this.coll])), S.orderItems(this.coll), this.series = this.series || [], S.inverted && !this.isZAxis && K && !L(this.reversed) && (this.reversed = !0), this.labelRotation = o(b.rotation) ? b.rotation : void 0, W(this, M), C(this, "afterInit") } setOptions(S) { let A = this.horiz ? { labels: { autoRotation: [-45] }, margin: 15 } : { title: { rotation: 90 * this.side } }; this.options = l(A, I[this.coll], S), C(this, "afterSetOptions", { userOptions: S }) } defaultLabelFormatter(S) { let A = this.axis, B = this.chart, { numberFormatter: K } = B, c = o(this.value) ? this.value : NaN, M = A.chart.time, b = A.categories, z = this.dateTimeLabelFormat, O = I.lang, q = O.numericSymbols, ie = O.numericSymbolMagnitude || 1e3, re = A.logarithmic ? Math.abs(c) : A.tickInterval, oe = q && q.length, he, ce; if (b) ce = `${this.value}`; else if (z) ce = M.dateFormat(z, c); else if (oe && q && re >= 1e3) for (; oe-- && ce === void 0;)re >= (he = Math.pow(ie, oe + 1)) && 10 * c % he == 0 && q[oe] !== null && c !== 0 && (ce = K(c / he, -1) + q[oe]); return ce === void 0 && (ce = Math.abs(c) >= 1e4 ? K(c, -1) : K(c, -1, void 0, "")), ce } getSeriesExtremes() { let S, A = this; C(this, "getSeriesExtremes", null, function () { A.hasVisibleSeries = !1, A.dataMin = A.dataMax = A.threshold = void 0, A.softThreshold = !A.isXAxis, A.series.forEach(B => { if (B.reserveSpace()) { let K = B.options, c, M = K.threshold, b, z; if (A.hasVisibleSeries = !0, A.positiveValuesOnly && 0 >= (M || 0) && (M = void 0), A.isXAxis) (c = B.xData) && c.length && (c = A.logarithmic ? c.filter(O => O > 0) : c, b = (S = B.getXExtremes(c)).min, z = S.max, o(b) || b instanceof Date || (c = c.filter(o), b = (S = B.getXExtremes(c)).min, z = S.max), c.length && (A.dataMin = Math.min(m(A.dataMin, b), b), A.dataMax = Math.max(m(A.dataMax, z), z))); else { let O = B.applyExtremes(); o(O.dataMin) && (b = O.dataMin, A.dataMin = Math.min(m(A.dataMin, b), b)), o(O.dataMax) && (z = O.dataMax, A.dataMax = Math.max(m(A.dataMax, z), z)), L(M) && (A.threshold = M), (!K.softThreshold || A.positiveValuesOnly) && (A.softThreshold = !1) } } }) }), C(this, "afterGetSeriesExtremes") } translate(S, A, B, K, c, M) { var ce; let b = this.linkedParent || this, z = K && b.old ? b.old.min : b.min; if (!o(z)) return NaN; let O = b.minPixelPadding, q = (b.isOrdinal || ((ce = b.brokenAxis) == null ? void 0 : ce.hasBreaks) || b.logarithmic && c) && b.lin2val, ie = 1, re = 0, oe = K && b.old ? b.old.transA : b.transA, he = 0; if (oe || (oe = b.transA), B && (ie *= -1, re = b.len), b.reversed && (ie *= -1, re -= ie * (b.sector || b.len)), A) he = (S = S * ie + re - O) / oe + z, q && (he = b.lin2val(he)); else { q && (S = b.val2lin(S)); let pe = ie * (S - z) * oe; he = (b.isRadial ? pe : w(pe)) + re + ie * O + (o(M) ? oe * M : 0) } return he } toPixels(S, A) { return this.translate(S, !1, !this.horiz, void 0, !0) + (A ? 0 : this.pos) } toValue(S, A) { return this.translate(S - (A ? 0 : this.pos), !0, !this.horiz, void 0, !0) } getPlotLinePath(S) { let A = this, B = A.chart, K = A.left, c = A.top, M = S.old, b = S.value, z = S.lineWidth, O = M && B.oldChartHeight || B.chartHeight, q = M && B.oldChartWidth || B.chartWidth, ie = A.transB, re = S.translatedValue, oe = S.force, he, ce, pe, V, X; function te(ae, le, de) { return oe !== "pass" && (ae < le || ae > de) && (oe ? ae = k(ae, le, de) : X = !0), ae } let ne = { value: b, lineWidth: z, old: M, force: oe, acrossPanes: S.acrossPanes, translatedValue: re }; return C(this, "getPlotLinePath", ne, function (ae) { he = pe = Math.round((re = k(re = m(re, A.translate(b, void 0, void 0, M)), -1e5, 1e5)) + ie), ce = V = Math.round(O - re - ie), o(re) ? A.horiz ? (ce = c, V = O - A.bottom, he = pe = te(he, K, K + A.width)) : (he = K, pe = q - A.right, ce = V = te(ce, c, c + A.height)) : (X = !0, oe = !1), ae.path = X && !oe ? void 0 : B.renderer.crispLine([["M", he, ce], ["L", pe, V]], z || 1) }), ne.path } getLinearTickPositions(S, A, B) { let K, c, M, b = w(Math.floor(A / S) * S), z = w(Math.ceil(B / S) * S), O = []; if (w(b + S) === b && (M = 20), this.single) return [A]; for (K = b; K <= z && (O.push(K), (K = w(K + S, M)) !== c);)c = K; return O } getMinorTickInterval() { let { minorTicks: S, minorTickInterval: A } = this.options; return S === !0 ? m(A, "auto") : S !== !1 ? A : void 0 } getMinorTickPositions() { let S = this.options, A = this.tickPositions, B = this.minorTickInterval, K = this.pointRangePadding || 0, c = (this.min || 0) - K, M = (this.max || 0) + K, b = M - c, z = [], O; if (b && b / B < this.len / 3) { let q = this.logarithmic; if (q) this.paddedTicks.forEach(function (ie, re, oe) { re && z.push.apply(z, q.getLogTickPositions(B, oe[re - 1], oe[re], !0)) }); else if (this.dateTime && this.getMinorTickInterval() === "auto") z = z.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(B), c, M, S.startOfWeek)); else for (O = c + (A[0] - c) % B; O <= M && O !== z[0]; O += B)z.push(O) } return z.length !== 0 && this.trimTicks(z), z } adjustForMinRange() { let S = this.options, A = this.logarithmic, { max: B, min: K, minRange: c } = this, M, b, z, O; this.isXAxis && c === void 0 && !A && (c = L(S.min) || L(S.max) || L(S.floor) || L(S.ceiling) ? null : Math.min(5 * (x(this.series.map(q => { var ie; return (q.xIncrement ? (ie = q.xData) == null ? void 0 : ie.slice(0, 2) : q.xData) || [] })) || 0), this.dataMax - this.dataMin)), o(B) && o(K) && o(c) && B - K < c && (b = this.dataMax - this.dataMin >= c, M = (c - B + K) / 2, z = [K - M, m(S.min, K - M)], b && (z[2] = A ? A.log2lin(this.dataMin) : this.dataMin), O = [(K = a(z)) + c, m(S.max, K + c)], b && (O[2] = A ? A.log2lin(this.dataMax) : this.dataMax), (B = v(O)) - K < c && (z[0] = B - c, z[1] = m(S.min, B - c), K = a(z))), this.minRange = c, this.min = K, this.max = B } getClosest() { let S, A; if (this.categories) A = 1; else { let B = []; this.series.forEach(function (K) { var M; let c = K.closestPointRange; ((M = K.xData) == null ? void 0 : M.length) === 1 ? B.push(K.xData[0]) : !K.noSharedTooltip && L(c) && K.reserveSpace() && (A = L(A) ? Math.min(A, c) : c) }), B.length && (B.sort((K, c) => K - c), S = x([B])) } return S && A ? Math.min(S, A) : S || A } nameToX(S) { let A = f(this.options.categories), B = A ? this.categories : this.names, K = S.options.x, c; return S.series.requireSorting = !1, L(K) || (K = this.options.uniqueNames && B ? A ? B.indexOf(S.name) : m(B.keys[S.name], -1) : S.series.autoIncrement()), K === -1 ? !A && B && (c = B.length) : c = K, c !== void 0 ? (this.names[c] = S.name, this.names.keys[S.name] = c) : S.x && (c = S.x), c } updateNames() { let S = this, A = this.names; A.length > 0 && (Object.keys(A.keys).forEach(function (K) { delete A.keys[K] }), A.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(K => { K.xIncrement = null, (!K.points || K.isDirtyData) && (S.max = Math.max(S.max, K.xData.length - 1), K.processData(), K.generatePoints()), K.data.forEach(function (c, M) { let b; c != null && c.options && c.name !== void 0 && (b = S.nameToX(c)) !== void 0 && b !== c.x && (c.x = b, K.xData[M] = b) }) })) } setAxisTranslation() { let S = this, A = S.max - S.min, B = S.linkedParent, K = !!S.categories, c = S.isXAxis, M = S.axisPointRange || 0, b, z = 0, O = 0, q, ie = S.transA; (c || K || M) && (b = S.getClosest(), B ? (z = B.minPointOffset, O = B.pointRangePadding) : S.series.forEach(function (re) { let oe = K ? 1 : c ? m(re.options.pointRange, b, 0) : S.axisPointRange || 0, he = re.options.pointPlacement; if (M = Math.max(M, oe), !S.single || K) { let ce = re.is("xrange") ? !c : c; z = Math.max(z, ce && u(he) ? 0 : oe / 2), O = Math.max(O, ce && he === "on" ? 0 : oe) } }), q = S.ordinal && S.ordinal.slope && b ? S.ordinal.slope / b : 1, S.minPointOffset = z *= q, S.pointRangePadding = O *= q, S.pointRange = Math.min(M, S.single && K ? 1 : A), c && b && (S.closestPointRange = b)), S.translationSlope = S.transA = ie = S.staticScale || S.len / (A + O || 1), S.transB = S.horiz ? S.left : S.bottom, S.minPixelPadding = ie * z, C(this, "afterSetAxisTranslation") } minFromRange() { let { max: S, min: A } = this; return o(S) && o(A) && S - A || void 0 } setTickInterval(S) { var be, we, ye, Te; let { categories: A, chart: B, dataMax: K, dataMin: c, dateTime: M, isXAxis: b, logarithmic: z, options: O, softThreshold: q } = this, ie = o(this.threshold) ? this.threshold : void 0, re = this.minRange || 0, { ceiling: oe, floor: he, linkedTo: ce, softMax: pe, softMin: V } = O, X = o(ce) && ((be = B[this.coll]) == null ? void 0 : be[ce]), te = O.tickPixelInterval, ne = O.maxPadding, ae = O.minPadding, le = 0, de, ue = o(O.tickInterval) && O.tickInterval >= 0 ? O.tickInterval : void 0, ge, Se, fe, me; if (M || A || X || this.getTickAmount(), fe = m(this.userMin, O.min), me = m(this.userMax, O.max), X ? (this.linkedParent = X, de = X.getExtremes(), this.min = m(de.min, de.dataMin), this.max = m(de.max, de.dataMax), O.type !== X.options.type && N(11, !0, B)) : (q && L(ie) && o(K) && o(c) && (c >= ie ? (ge = ie, ae = 0) : K <= ie && (Se = ie, ne = 0)), this.min = m(fe, ge, c), this.max = m(me, Se, K)), o(this.max) && o(this.min) && (z && (this.positiveValuesOnly && !S && 0 >= Math.min(this.min, m(c, this.min)) && N(10, !0, B), this.min = w(z.log2lin(this.min), 16), this.max = w(z.log2lin(this.max), 16)), this.range && o(c) && (this.userMin = this.min = fe = Math.max(c, this.minFromRange() || 0), this.userMax = me = this.max, this.range = void 0)), C(this, "foundExtremes"), this.adjustForMinRange(), o(this.min) && o(this.max)) { if (!o(this.userMin) && o(V) && V < this.min && (this.min = fe = V), !o(this.userMax) && o(pe) && pe > this.max && (this.max = me = pe), A || this.axisPointRange || (we = this.stacking) != null && we.usePercentage || X || !(le = this.max - this.min) || (!L(fe) && ae && (this.min -= le * ae), L(me) || !ne || (this.max += le * ne)), !o(this.userMin) && o(he) && (this.min = Math.max(this.min, he)), !o(this.userMax) && o(oe) && (this.max = Math.min(this.max, oe)), q && o(c) && o(K)) { let Me = ie || 0; !L(fe) && this.min < Me && c >= Me ? this.min = O.minRange ? Math.min(Me, this.max - re) : Me : !L(me) && this.max > Me && K <= Me && (this.max = O.minRange ? Math.max(Me, this.min + re) : Me) } !B.polar && this.min > this.max && (L(O.min) ? this.max = this.min : L(O.max) && (this.min = this.max)), le = this.max - this.min } if (this.min !== this.max && o(this.min) && o(this.max) ? X && !ue && te === X.options.tickPixelInterval ? this.tickInterval = ue = X.tickInterval : this.tickInterval = m(ue, this.tickAmount ? le / Math.max(this.tickAmount - 1, 1) : void 0, A ? 1 : le * te / Math.max(this.len, te)) : this.tickInterval = 1, b && !S) { let Me = this.min !== ((ye = this.old) == null ? void 0 : ye.min) || this.max !== ((Te = this.old) == null ? void 0 : Te.max); this.series.forEach(function (Ee) { var je; Ee.forceCrop = (je = Ee.forceCropping) == null ? void 0 : je.call(Ee), Ee.processData(Me) }), C(this, "postProcessData", { hasExtremesChanged: Me }) } this.setAxisTranslation(), C(this, "initialAxisTranslation"), this.pointRange && !ue && (this.tickInterval = Math.max(this.pointRange, this.tickInterval)); let ke = m(O.minTickInterval, M && !this.series.some(Me => Me.noSharedTooltip) ? this.closestPointRange : 0); !ue && this.tickInterval < ke && (this.tickInterval = ke), M || z || ue || (this.tickInterval = Z(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions() } setTickPositions() { var ie, re; let S = this.options, A = S.tickPositions, B = S.tickPositioner, K = this.getMinorTickInterval(), c = this.hasVerticalPanning(), M = this.coll === "colorAxis", b = (M || !c) && S.startOnTick, z = (M || !c) && S.endOnTick, O = [], q; if (this.tickmarkOffset = this.categories && S.tickmarkPlacement === "between" && this.tickInterval === 1 ? .5 : 0, this.minorTickInterval = K === "auto" && this.tickInterval ? this.tickInterval / S.minorTicksPerMajor : K, this.single = this.min === this.max && L(this.min) && !this.tickAmount && (this.min % 1 == 0 || S.allowDecimals !== !1), A) O = A.slice(); else if (o(this.min) && o(this.max)) { if (!((ie = this.ordinal) != null && ie.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) O = [this.min, this.max], N(19, !1, this.chart); else if (this.dateTime) O = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, S.units), this.min, this.max, S.startOfWeek, (re = this.ordinal) == null ? void 0 : re.positions, this.closestPointRange, !0); else if (this.logarithmic) O = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max); else { let oe = this.tickInterval, he = oe; for (; he <= 2 * oe && (O = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && O.length > this.tickAmount);)this.tickInterval = Z(this, he *= 1.1) } O.length > this.len && (O = [O[0], O[O.length - 1]])[0] === O[1] && (O.length = 1), B && (this.tickPositions = O, (q = B.apply(this, [this.min, this.max])) && (O = q)) } this.tickPositions = O, this.paddedTicks = O.slice(0), this.trimTicks(O, b, z), !this.isLinked && o(this.min) && o(this.max) && (this.single && O.length < 2 && !this.categories && !this.series.some(oe => oe.is("heatmap") && oe.options.pointPlacement === "between") && (this.min -= .5, this.max += .5), A || q || this.adjustTickAmount()), C(this, "afterSetTickPositions") } trimTicks(S, A, B) { let K = S[0], c = S[S.length - 1], M = !this.isOrdinal && this.minPointOffset || 0; if (C(this, "trimTicks"), !this.isLinked) { if (A && K !== -1 / 0) this.min = K; else for (; this.min - M > S[0];)S.shift(); if (B) this.max = c; else for (; this.max + M < S[S.length - 1];)S.pop(); S.length === 0 && L(K) && !this.options.tickPositions && S.push((c + K) / 2) } } alignToOthers() { let S, A = this, B = [this], K = A.options, c = this.chart.options.chart, M = this.coll === "yAxis" && c.alignThresholds, b = []; if (A.thresholdAlignment = void 0, (c.alignTicks !== !1 && K.alignTicks || M) && K.startOnTick !== !1 && K.endOnTick !== !1 && !A.logarithmic) { let z = q => { let { horiz: ie, options: re } = q; return [ie ? re.left : re.top, re.width, re.height, re.pane].join(",") }, O = z(this); this.chart[this.coll].forEach(function (q) { let { series: ie } = q; ie.length && ie.some(re => re.visible) && q !== A && z(q) === O && (S = !0, B.push(q)) }) } if (S && M) { B.forEach(O => { let q = O.getThresholdAlignment(A); o(q) && b.push(q) }); let z = b.length > 1 ? b.reduce((O, q) => O += q, 0) / b.length : void 0; B.forEach(O => { O.thresholdAlignment = z }) } return S } getThresholdAlignment(S) { if ((!o(this.dataMin) || this !== S && this.series.some(A => A.isDirty || A.isDirtyData)) && this.getSeriesExtremes(), o(this.threshold)) { let A = k((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1); return this.options.reversed && (A = 1 - A), A } } getTickAmount() { let S = this.options, A = S.tickPixelInterval, B = S.tickAmount; L(S.tickInterval) || B || !(this.len < A) || this.isRadial || this.logarithmic || !S.startOnTick || !S.endOnTick || (B = 2), !B && this.alignToOthers() && (B = Math.ceil(this.len / A) + 1), B < 4 && (this.finalTickAmt = B, B = 5), this.tickAmount = B } adjustTickAmount() { let S = this, { finalTickAmt: A, max: B, min: K, options: c, tickPositions: M, tickAmount: b, thresholdAlignment: z } = S, O = M == null ? void 0 : M.length, q = m(S.threshold, S.softThreshold ? 0 : null), ie, re, oe = S.tickInterval, he, ce = () => M.push(w(M[M.length - 1] + oe)), pe = () => M.unshift(w(M[0] - oe)); if (o(z) && (he = z < .5 ? Math.ceil(z * (b - 1)) : Math.floor(z * (b - 1)), c.reversed && (he = b - 1 - he)), S.hasData() && o(K) && o(B)) { let V = () => { S.transA *= (O - 1) / (b - 1), S.min = c.startOnTick ? M[0] : Math.min(K, M[0]), S.max = c.endOnTick ? M[M.length - 1] : Math.max(B, M[M.length - 1]) }; if (o(he) && o(S.threshold)) { for (; M[he] !== q || M.length !== b || M[0] > K || M[M.length - 1] < B;) { for (M.length = 0, M.push(S.threshold); M.length < b;)M[he] === void 0 || M[he] > S.threshold ? pe() : ce(); if (oe > 8 * S.tickInterval) break; oe *= 2 } V() } else if (O < b) { for (; M.length < b;)M.length % 2 || K === q ? ce() : pe(); V() } if (L(A)) { for (re = ie = M.length; re--;)(A === 3 && re % 2 == 1 || A <= 2 && re > 0 && re < ie - 1) && M.splice(re, 1); S.finalTickAmt = void 0 } } } setScale() { var M, b; let { coll: S, stacking: A } = this, B = !1, K = !1; this.series.forEach(z => { B = B || z.isDirtyData || z.isDirty, K = K || z.xAxis && z.xAxis.isDirty || !1 }), this.setAxisSize(); let c = this.len !== (this.old && this.old.len); c || B || K || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (A && S === "yAxis" && A.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), A && S === "xAxis" && A.buildStacks(), this.isDirty || (this.isDirty = c || this.min !== ((M = this.old) == null ? void 0 : M.min) || this.max !== ((b = this.old) == null ? void 0 : b.max))) : A && A.cleanStacks(), B && this.panningState && (this.panningState.isDirty = !0), C(this, "afterSetScale") } setExtremes(S, A, B = !0, K, c) { let M = this, b = M.chart; M.series.forEach(z => { delete z.kdTree }), C(M, "setExtremes", c = F(c, { min: S, max: A }), () => { M.userMin = S, M.userMax = A, M.eventArgs = c, B && b.redraw(K) }) } zoom(S, A) { let B = this, K = this.dataMin, c = this.dataMax, M = this.options, b = Math.min(K, m(M.min, K)), z = Math.max(c, m(M.max, c)), O = { newMin: S, newMax: A }; return C(this, "zoom", O, function (q) { let ie = q.newMin, re = q.newMax; (ie !== B.min || re !== B.max) && (!B.allowZoomOutside && (L(K) && (ie < b && (ie = b), ie > z && (ie = z)), L(c) && (re < b && (re = b), re > z && (re = z))), B.displayBtn = ie !== void 0 || re !== void 0, B.setExtremes(ie, re, !1, void 0, { trigger: "zoom" })), q.zoomed = !0 }), O.zoomed } setAxisSize() { let S = this.chart, A = this.options, B = A.offsets || [0, 0, 0, 0], K = this.horiz, c = this.width = Math.round(p(m(A.width, S.plotWidth - B[3] + B[1]), S.plotWidth)), M = this.height = Math.round(p(m(A.height, S.plotHeight - B[0] + B[2]), S.plotHeight)), b = this.top = Math.round(p(m(A.top, S.plotTop + B[0]), S.plotHeight, S.plotTop)), z = this.left = Math.round(p(m(A.left, S.plotLeft + B[3]), S.plotWidth, S.plotLeft)); this.bottom = S.chartHeight - M - b, this.right = S.chartWidth - c - z, this.len = Math.max(K ? c : M, 0), this.pos = K ? z : b } getExtremes() { let S = this.logarithmic; return { min: S ? w(S.lin2log(this.min)) : this.min, max: S ? w(S.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax } } getThreshold(S) { let A = this.logarithmic, B = A ? A.lin2log(this.min) : this.min, K = A ? A.lin2log(this.max) : this.max; return S === null || S === -1 / 0 ? S = B : S === 1 / 0 ? S = K : B > S ? S = B : K < S && (S = K), this.translate(S, 0, 1, 0, 1) } autoLabelAlign(S) { let A = (m(S, 0) - 90 * this.side + 720) % 360, B = { align: "center" }; return C(this, "autoLabelAlign", B, function (K) { A > 15 && A < 165 ? K.align = "right" : A > 195 && A < 345 && (K.align = "left") }), B.align } tickSize(S) { let A = this.options, B = m(A[S === "tick" ? "tickWidth" : "minorTickWidth"], S === "tick" && this.isXAxis && !this.categories ? 1 : 0), K = A[S === "tick" ? "tickLength" : "minorTickLength"], c; B && K && (A[S + "Position"] === "inside" && (K = -K), c = [K, B]); let M = { tickSize: c }; return C(this, "afterTickSize", M), M.tickSize } labelMetrics() { let S = this.chart.renderer, A = this.ticks, B = A[Object.keys(A)[0]] || {}; return this.chart.renderer.fontMetrics(B.label || B.movedLabel || S.box) } unsquish() { let S = this.options.labels, A = this.horiz, B = this.tickInterval, K = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / B), c = S.rotation, M = this.labelMetrics().h, b = Math.max(this.max - this.min, 0), z = function (oe) { let he = oe / (K || 1); return (he = he > 1 ? Math.ceil(he) : 1) * B > b && oe !== 1 / 0 && K !== 1 / 0 && b && (he = Math.ceil(b / B)), w(he * B) }, O = B, q, ie = Number.MAX_VALUE, re; if (A) { if (!S.staggerLines && (o(c) ? re = [c] : K < S.autoRotationLimit && (re = S.autoRotation)), re) { let oe, he; for (let ce of re) (ce === c || ce && ce >= -90 && ce <= 90) && (he = (oe = z(Math.abs(M / Math.sin(y * ce)))) + Math.abs(ce / 360)) < ie && (ie = he, q = ce, O = oe) } } else O = z(.75 * M); return this.autoRotation = re, this.labelRotation = m(q, o(c) ? c : 0), S.step ? B : O } getSlotWidth(S) { let A = this.chart, B = this.horiz, K = this.options.labels, c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), M = A.margin[3]; if (S && o(S.slotWidth)) return S.slotWidth; if (B && K.step < 2) return K.rotation ? 0 : (this.staggerLines || 1) * this.len / c; if (!B) { let b = K.style.width; if (b !== void 0) return parseInt(String(b), 10); if (M) return M - A.spacing[3] } return .33 * A.chartWidth } renderUnsquish() { let S = this.chart, A = S.renderer, B = this.tickPositions, K = this.ticks, c = this.options.labels, M = c.style, b = this.horiz, z = this.getSlotWidth(), O = Math.max(1, Math.round(z - 2 * c.padding)), q = {}, ie = this.labelMetrics(), re = M.textOverflow, oe, he, ce = 0, pe, V; if (u(c.rotation) || (q.rotation = c.rotation || 0), B.forEach(function (X) { let te = K[X]; te.movedLabel && te.replaceMovedLabel(), te && te.label && te.label.textPxLength > ce && (ce = te.label.textPxLength) }), this.maxLabelLength = ce, this.autoRotation) ce > O && ce > ie.h ? q.rotation = this.labelRotation : this.labelRotation = 0; else if (z && (oe = O, !re)) for (he = "clip", V = B.length; !b && V--;)(pe = K[B[V]].label) && (pe.styles && pe.styles.textOverflow === "ellipsis" ? pe.css({ textOverflow: "clip" }) : pe.textPxLength > z && pe.css({ width: z + "px" }), pe.getBBox().height > this.len / B.length - (ie.h - ie.f) && (pe.specificTextOverflow = "ellipsis")); q.rotation && (oe = ce > .5 * S.chartHeight ? .33 * S.chartHeight : ce, re || (he = "ellipsis")), this.labelAlign = c.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (q.align = this.labelAlign), B.forEach(function (X) { let te = K[X], ne = te && te.label, ae = M.width, le = {}; ne && (ne.attr(q), te.shortenLabel ? te.shortenLabel() : oe && !ae && M.whiteSpace !== "nowrap" && (oe < ne.textPxLength || ne.element.tagName === "SPAN") ? (le.width = oe + "px", re || (le.textOverflow = ne.specificTextOverflow || he), ne.css(le)) : ne.styles && ne.styles.width && !le.width && !ae && ne.css({ width: null }), delete ne.specificTextOverflow, te.rotation = q.rotation) }, this), this.tickRotCorr = A.rotCorr(ie.b, this.labelRotation || 0, this.side !== 0) } hasData() { return this.series.some(function (S) { return S.hasData() }) || this.options.showEmpty && L(this.min) && L(this.max) } addTitle(S) { let A, B = this.chart.renderer, K = this.horiz, c = this.opposite, M = this.options, b = M.title, z = this.chart.styledMode; this.axisTitle || ((A = b.textAlign) || (A = (K ? { low: "left", middle: "center", high: "right" } : { low: c ? "right" : "left", middle: "center", high: c ? "left" : "right" })[b.align]), this.axisTitle = B.text(b.text || "", 0, 0, b.useHTML).attr({ zIndex: 7, rotation: b.rotation || 0, align: A }).addClass("highcharts-axis-title"), z || this.axisTitle.css(l(b.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), z || b.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" }), this.axisTitle[S ? "show" : "hide"](S) } generateTick(S) { let A = this.ticks; A[S] ? A[S].addLabel() : A[S] = new se(this, S) } createGroups() { let { axisParent: S, chart: A, coll: B, options: K } = this, c = A.renderer, M = (b, z, O) => c.g(b).attr({ zIndex: O }).addClass(`highcharts-${B.toLowerCase()}${z} ` + (this.isRadial ? `highcharts-radial-axis${z} ` : "") + (K.className || "")).add(S); this.axisGroup || (this.gridGroup = M("grid", "-grid", K.gridZIndex), this.axisGroup = M("axis", "", K.zIndex), this.labelGroup = M("axis-labels", "-labels", K.labels.zIndex)) } getOffset() { let S = this, { chart: A, horiz: B, options: K, side: c, ticks: M, tickPositions: b, coll: z } = S, O = A.inverted && !S.isZAxis ? [1, 0, 3, 2][c] : c, q = S.hasData(), ie = K.title, re = K.labels, oe = o(K.crossing), he = A.axisOffset, ce = A.clipOffset, pe = [-1, 1, 1, -1][c], V, X = 0, te, ne = 0, ae = 0, le, de; if (S.showAxis = V = q || K.showEmpty, S.staggerLines = S.horiz && re.staggerLines || void 0, S.createGroups(), q || S.isLinked ? (b.forEach(function (ue) { S.generateTick(ue) }), S.renderUnsquish(), S.reserveSpaceDefault = c === 0 || c === 2 || { 1: "left", 3: "right" }[c] === S.labelAlign, m(re.reserveSpace, !oe && null, S.labelAlign === "center" || null, S.reserveSpaceDefault) && b.forEach(function (ue) { ae = Math.max(M[ue].getLabelSize(), ae) }), S.staggerLines && (ae *= S.staggerLines), S.labelOffset = ae * (S.opposite ? -1 : 1)) : d(M, function (ue, ge) { ue.destroy(), delete M[ge] }), ie != null && ie.text && ie.enabled !== !1 && (S.addTitle(V), V && !oe && ie.reserveSpace !== !1 && (S.titleOffset = X = S.axisTitle.getBBox()[B ? "height" : "width"], ne = L(te = ie.offset) ? 0 : m(ie.margin, B ? 5 : 10))), S.renderLine(), S.offset = pe * m(K.offset, he[c] ? he[c] + (K.margin || 0) : 0), S.tickRotCorr = S.tickRotCorr || { x: 0, y: 0 }, de = c === 0 ? -S.labelMetrics().h : c === 2 ? S.tickRotCorr.y : 0, le = Math.abs(ae) + ne, ae && (le -= de, le += pe * (B ? m(re.y, S.tickRotCorr.y + pe * re.distance) : m(re.x, pe * re.distance))), S.axisTitleMargin = m(te, le), S.getMaxLabelDimensions && (S.maxLabelDimensions = S.getMaxLabelDimensions(M, b)), z !== "colorAxis") { let ue = this.tickSize("tick"); he[c] = Math.max(he[c], (S.axisTitleMargin || 0) + X + pe * S.offset, le, b && b.length && ue ? ue[0] + pe * S.offset : 0); let ge = !S.axisLine || K.offset ? 0 : 2 * Math.floor(S.axisLine.strokeWidth() / 2); ce[O] = Math.max(ce[O], ge) } C(this, "afterGetOffset") } getLinePath(S) { let A = this.chart, B = this.opposite, K = this.offset, c = this.horiz, M = this.left + (B ? this.width : 0) + K, b = A.chartHeight - this.bottom - (B ? this.height : 0) + K; return B && (S *= -1), A.renderer.crispLine([["M", c ? this.left : M, c ? b : this.top], ["L", c ? A.chartWidth - this.right : M, c ? b : A.chartHeight - this.bottom]], S) } renderLine() { this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 })) } getTitlePosition(S) { let A = this.horiz, B = this.left, K = this.top, c = this.len, M = this.options.title, b = A ? B : K, z = this.opposite, O = this.offset, q = M.x, ie = M.y, re = this.chart.renderer.fontMetrics(S), oe = S ? Math.max(S.getBBox(!1, 0).height - re.h - 1, 0) : 0, he = { low: b + (A ? 0 : c), middle: b + c / 2, high: b + (A ? c : 0) }[M.align], ce = (A ? K + this.height : B) + (A ? 1 : -1) * (z ? -1 : 1) * (this.axisTitleMargin || 0) + [-oe, oe, re.f, -oe][this.side], pe = { x: A ? he + q : ce + (z ? this.width : 0) + O + q, y: A ? ce + ie - (z ? this.height : 0) + O : he + ie }; return C(this, "afterGetTitlePosition", { titlePosition: pe }), pe } renderMinorTick(S, A) { let B = this.minorTicks; B[S] || (B[S] = new se(this, S, "minor")), A && B[S].isNew && B[S].render(null, !0), B[S].render(null, !1, 1) } renderTick(S, A, B) { let K = this.isLinked, c = this.ticks; (!K || S >= this.min && S <= this.max || this.grid && this.grid.isColumn) && (c[S] || (c[S] = new se(this, S)), B && c[S].isNew && c[S].render(A, !0, -1), c[S].render(A)) } render() { let S, A, B = this, K = B.chart, c = B.logarithmic, M = K.renderer, b = B.options, z = B.isLinked, O = B.tickPositions, q = B.axisTitle, ie = B.ticks, re = B.minorTicks, oe = B.alternateBands, he = b.stackLabels, ce = b.alternateGridColor, pe = b.crossing, V = B.tickmarkOffset, X = B.axisLine, te = B.showAxis, ne = R(M.globalAnimation); if (B.labelEdge.length = 0, B.overlap = !1, [ie, re, oe].forEach(function (ae) { d(ae, function (le) { le.isActive = !1 }) }), o(pe)) { let ae = this.isXAxis ? K.yAxis[0] : K.xAxis[0], le = [1, -1, -1, 1][this.side]; if (ae) { let de = ae.toPixels(pe, !0); B.horiz && (de = ae.len - de), B.offset = le * de } } if (B.hasData() || z) { let ae = B.chart.hasRendered && B.old && o(B.old.min); B.minorTickInterval && !B.categories && B.getMinorTickPositions().forEach(function (le) { B.renderMinorTick(le, ae) }), O.length && (O.forEach(function (le, de) { B.renderTick(le, de, ae) }), V && (B.min === 0 || B.single) && (ie[-1] || (ie[-1] = new se(B, -1, null, !0)), ie[-1].render(-1))), ce && O.forEach(function (le, de) { A = O[de + 1] !== void 0 ? O[de + 1] + V : B.max - V, de % 2 == 0 && le < B.max && A <= B.max + (K.polar ? -V : V) && (oe[le] || (oe[le] = new J.PlotLineOrBand(B, {})), S = le + V, oe[le].options = { from: c ? c.lin2log(S) : S, to: c ? c.lin2log(A) : A, color: ce, className: "highcharts-alternate-grid" }, oe[le].render(), oe[le].isActive = !0) }), B._addedPlotLB || (B._addedPlotLB = !0, (b.plotLines || []).concat(b.plotBands || []).forEach(function (le) { B.addPlotBandOrLine(le) })) } [ie, re, oe].forEach(function (ae) { let le = [], de = ne.duration; d(ae, function (ue, ge) { ue.isActive || (ue.render(ge, !1, 0), ue.isActive = !1, le.push(ge)) }), ee(function () { let ue = le.length; for (; ue--;)ae[le[ue]] && !ae[le[ue]].isActive && (ae[le[ue]].destroy(), delete ae[le[ue]]) }, ae !== oe && K.hasRendered && de ? de : 0) }), X && (X[X.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(X.strokeWidth()) }), X.isPlaced = !0, X[te ? "show" : "hide"](te)), q && te && (q[q.isNew ? "attr" : "animate"](B.getTitlePosition(q)), q.isNew = !1), he && he.enabled && B.stacking && B.stacking.renderStackTotals(), B.old = { len: B.len, max: B.max, min: B.min, transA: B.transA, userMax: B.userMax, userMin: B.userMin }, B.isDirty = !1, C(this, "afterRender") } redraw() { this.visible && (this.render(), this.plotLinesAndBands.forEach(function (S) { S.render() })), this.series.forEach(function (S) { S.isDirty = !0 }) } getKeepProps() { return this.keepProps || H.keepProps } destroy(S) { let A = this, B = A.plotLinesAndBands, K = this.eventOptions; if (C(this, "destroy", { keepEvents: S }), S || T(A), [A.ticks, A.minorTicks, A.alternateBands].forEach(function (c) { G(c) }), B) { let c = B.length; for (; c--;)B[c].destroy() } for (let c in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function (M) { A[M] && (A[M] = A[M].destroy()) }), A.plotLinesAndBandsGroups) A.plotLinesAndBandsGroups[c] = A.plotLinesAndBandsGroups[c].destroy(); d(A, function (c, M) { A.getKeepProps().indexOf(M) === -1 && delete A[M] }), this.eventOptions = K } drawCrosshair(S, A) { let B = this.crosshair, K = m(B && B.snap, !0), c = this.chart, M, b, z, O = this.cross, q; if (C(this, "drawCrosshair", { e: S, point: A }), S || (S = this.cross && this.cross.e), B && (L(A) || !K) !== !1) { if (K ? L(A) && (b = m(this.coll !== "colorAxis" ? A.crosshairPos : null, this.isXAxis ? A.plotX : this.len - A.plotY)) : b = S && (this.horiz ? S.chartX - this.pos : this.len - S.chartY + this.pos), L(b) && (q = { value: A && (this.isXAxis ? A.x : m(A.stackY, A.y)), translatedValue: b }, c.polar && F(q, { isCrosshair: !0, chartX: S && S.chartX, chartY: S && S.chartY, point: A }), M = this.getPlotLinePath(q) || null), !L(M)) { this.hideCrosshair(); return } z = this.categories && !this.isRadial, O || (this.cross = O = c.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (z ? "category " : "thin ") + (B.className || "")).attr({ zIndex: m(B.zIndex, 2) }).add(), !c.styledMode && (O.attr({ stroke: B.color || (z ? g.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"), "stroke-width": m(B.width, 1) }).css({ "pointer-events": "none" }), B.dashStyle && O.attr({ dashstyle: B.dashStyle }))), O.show().attr({ d: M }), z && !B.width && O.attr({ "stroke-width": this.transA }), this.cross.e = S } else this.hideCrosshair(); C(this, "afterDrawCrosshair", { e: S, point: A }) } hideCrosshair() { this.cross && this.cross.hide(), C(this, "afterHideCrosshair") } hasVerticalPanning() { let S = this.chart.options.chart.panning; return !!(S && S.enabled && /y/.test(S.type)) } update(S, A) { let B = this.chart; S = l(this.userOptions, S), this.destroy(!0), this.init(B, S), B.isDirtyBox = !0, m(A, !0) && B.redraw() } remove(S) { let A = this.chart, B = this.coll, K = this.series, c = K.length; for (; c--;)K[c] && K[c].remove(!1); _(A.axes, this), _(A[B] || [], this), A.orderItems(B), this.destroy(), A.isDirtyBox = !0, m(S, !0) && A.redraw() } setTitle(S, A) { this.update({ title: S }, A) } setCategories(S, A) { this.update({ categories: S }, A) } } return H.keepProps = ["coll", "extKey", "hcEvents", "names", "series", "userMax", "userMin"], H }), n(i, "Core/Axis/DateTimeAxis.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { var g; let { composed: j } = r, { addEvent: D, getMagnitude: J, normalizeTickInterval: se, pushUnique: $, timeUnits: R } = s; return function (Q) { function E() { return this.chart.time.getTimeTicks.apply(this.chart.time, arguments) } function I() { if (this.options.type !== "datetime") { this.dateTime = void 0; return } this.dateTime || (this.dateTime = new W(this)) } Q.compose = function y(a) { if ($(j, y)) { a.keepProps.push("dateTime"); let v = a.prototype; v.getTimeTicks = E, D(a, "afterSetOptions", I) } return a }; class W { constructor(a) { this.axis = a } normalizeTimeTickInterval(a, v) { let k = v || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], w = k[k.length - 1], L = R[w[0]], G = w[1], _; for (_ = 0; _ < k.length; _++)if (L = R[(w = k[_])[0]], G = w[1], k[_ + 1]) { let F = (L * G[G.length - 1] + R[k[_ + 1][0]]) / 2; if (a <= F) break } L === R.year && a < 5 * L && (G = [1, 2, 5]); let N = se(a / L, G, w[0] === "year" ? Math.max(J(a / L), 1) : 1); return { unitRange: L, count: N, unitName: w[0] } } getXDateFormat(a, v) { let { axis: k } = this, w = k.chart.time; return k.closestPointRange ? w.getDateFormat(k.closestPointRange, a, k.options.startOfWeek, v) || w.resolveDTLFormat(v.year).main : w.resolveDTLFormat(v.day).main } } Q.Additions = W }(g || (g = {})), g }), n(i, "Core/Axis/LogarithmicAxis.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { var g; let { composed: j } = r, { addEvent: D, normalizeTickInterval: J, pick: se, pushUnique: $ } = s; return function (R) { function Q(W) { let y = W.userOptions, a = this.logarithmic; y.type !== "logarithmic" ? this.logarithmic = void 0 : a || (a = this.logarithmic = new I(this)) } function E() { let W = this.logarithmic; W && (this.lin2val = function (y) { return W.lin2log(y) }, this.val2lin = function (y) { return W.log2lin(y) }) } R.compose = function W(y) { return $(j, W) && (y.keepProps.push("logarithmic"), D(y, "init", Q), D(y, "afterInit", E)), y }; class I { constructor(y) { this.axis = y } getLogTickPositions(y, a, v, k) { let w = this.axis, L = w.len, G = w.options, _ = []; if (k || (this.minorAutoInterval = void 0), y >= .5) y = Math.round(y), _ = w.getLinearTickPositions(y, a, v); else if (y >= .08) { let N, F, C, x, P, f, o, u = Math.floor(a); for (N = y > .3 ? [1, 2, 4] : y > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], F = u; F < v + 1 && !o; F++)for (C = 0, x = N.length; C < x && !o; C++)(P = this.log2lin(this.lin2log(F) * N[C])) > a && (!k || f <= v) && f !== void 0 && _.push(f), f > v && (o = !0), f = P } else { let N = this.lin2log(a), F = this.lin2log(v), C = k ? w.getMinorTickInterval() : G.tickInterval, x = C === "auto" ? null : C, P = G.tickPixelInterval / (k ? 5 : 1), f = k ? L / w.tickPositions.length : L; y = J(y = se(x, this.minorAutoInterval, (F - N) * P / (f || 1))), _ = w.getLinearTickPositions(y, N, F).map(this.log2lin), k || (this.minorAutoInterval = y / 5) } return k || (w.tickInterval = y), _ } lin2log(y) { return Math.pow(10, y) } log2lin(y) { return Math.log(y) / Math.LN10 } } R.Additions = I }(g || (g = {})), g }), n(i, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { var g; let { composed: j } = r, { erase: D, extend: J, isNumber: se, pushUnique: $ } = s; return function (R) { let Q; function E(w) { return this.addPlotBandOrLine(w, "plotBands") } function I(w, L) { let G = this.userOptions, _ = new Q(this, w); if (this.visible && (_ = _.render()), _) { if (this._addedPlotLB || (this._addedPlotLB = !0, (G.plotLines || []).concat(G.plotBands || []).forEach(N => { this.addPlotBandOrLine(N) })), L) { let N = G[L] || []; N.push(w), G[L] = N } this.plotLinesAndBands.push(_) } return _ } function W(w) { return this.addPlotBandOrLine(w, "plotLines") } function y(w, L, G) { G = G || this.options; let _ = this.getPlotLinePath({ value: L, force: !0, acrossPanes: G.acrossPanes }), N = [], F = this.horiz, C = !se(this.min) || !se(this.max) || w < this.min && L < this.min || w > this.max && L > this.max, x = this.getPlotLinePath({ value: w, force: !0, acrossPanes: G.acrossPanes }), P, f = 1, o; if (x && _) for (C && (o = x.toString() === _.toString(), f = 0), P = 0; P < x.length; P += 2) { let u = x[P], l = x[P + 1], h = _[P], d = _[P + 1]; (u[0] === "M" || u[0] === "L") && (l[0] === "M" || l[0] === "L") && (h[0] === "M" || h[0] === "L") && (d[0] === "M" || d[0] === "L") && (F && h[1] === u[1] ? (h[1] += f, d[1] += f) : F || h[2] !== u[2] || (h[2] += f, d[2] += f), N.push(["M", u[1], u[2]], ["L", l[1], l[2]], ["L", d[1], d[2]], ["L", h[1], h[2]], ["Z"])), N.isFlat = o } return N } function a(w) { this.removePlotBandOrLine(w) } function v(w) { let L = this.plotLinesAndBands, G = this.options, _ = this.userOptions; if (L) { let N = L.length; for (; N--;)L[N].id === w && L[N].destroy();[G.plotLines || [], _.plotLines || [], G.plotBands || [], _.plotBands || []].forEach(function (F) { for (N = F.length; N--;)(F[N] || {}).id === w && D(F, F[N]) }) } } function k(w) { this.removePlotBandOrLine(w) } R.compose = function w(L, G) { return $(j, w) && (Q = L, J(G.prototype, { addPlotBand: E, addPlotLine: W, addPlotBandOrLine: I, getPlotBandPath: y, removePlotBand: a, removePlotLine: k, removePlotBandOrLine: v })), G } }(g || (g = {})), g }), n(i, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [i["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], i["Core/Utilities.js"]], function (r, s) { let { arrayMax: g, arrayMin: j, defined: D, destroyObjectProperties: J, erase: se, fireEvent: $, merge: R, objectEach: Q, pick: E } = s; class I { static compose(y) { return r.compose(I, y) } constructor(y, a) { this.axis = y, this.options = a, this.id = a.id } render() { $(this, "render"); let { axis: y, options: a } = this, { horiz: v, logarithmic: k } = y, { color: w, events: L, zIndex: G = 0 } = a, _ = {}, N = y.chart.renderer, F = a.to, C = a.from, x = a.value, P = a.borderWidth, f = a.label, { label: o, svgElem: u } = this, l = [], h, d = D(C) && D(F), m = D(x), p = !u, T = { class: "highcharts-plot-" + (d ? "band " : "line ") + (a.className || "") }, U = d ? "bands" : "lines"; if (!y.chart.styledMode && (m ? (T.stroke = w || "#999999", T["stroke-width"] = E(a.width, 1), a.dashStyle && (T.dashstyle = a.dashStyle)) : d && (T.fill = w || "#e6e9ff", P && (T.stroke = a.borderColor, T["stroke-width"] = P))), _.zIndex = G, U += "-" + G, (h = y.plotLinesAndBandsGroups[U]) || (y.plotLinesAndBandsGroups[U] = h = N.g("plot-" + U).attr(_).add()), u || (this.svgElem = u = N.path().attr(T).add(h)), D(x)) l = y.getPlotLinePath({ value: (k == null ? void 0 : k.log2lin(x)) ?? x, lineWidth: u.strokeWidth(), acrossPanes: a.acrossPanes }); else { if (!(D(C) && D(F))) return; l = y.getPlotBandPath((k == null ? void 0 : k.log2lin(C)) ?? C, (k == null ? void 0 : k.log2lin(F)) ?? F, a) } return !this.eventsAdded && L && (Q(L, (ee, Z) => { u == null || u.on(Z, function (H) { L[Z].apply(this, [H]) }) }), this.eventsAdded = !0), (p || !u.d) && (l != null && l.length) ? u.attr({ d: l }) : u && (l ? (u.show(), u.animate({ d: l })) : u.d && (u.hide(), o && (this.label = o = o.destroy()))), f && (D(f.text) || D(f.formatter)) && (l != null && l.length) && y.width > 0 && y.height > 0 && !l.isFlat ? (f = R({ align: v && d && "center", x: v ? !d && 4 : 10, verticalAlign: !v && d && "middle", y: v ? d ? 16 : 10 : d ? 6 : -4, rotation: v && !d && 90 }, f), this.renderLabel(f, l, d, G)) : o && o.hide(), this } renderLabel(y, a, v, k) { let w = this.axis, L = w.chart.renderer, G = this.label; G || (this.label = G = L.text(this.getLabelText(y), 0, 0, y.useHTML).attr({ align: y.textAlign || y.align, rotation: y.rotation, class: "highcharts-plot-" + (v ? "band" : "line") + "-label" + (y.className || ""), zIndex: k }), w.chart.styledMode || G.css(R({ fontSize: "0.8em", textOverflow: "ellipsis" }, y.style)), G.add()); let _ = a.xBounds || [a[0][1], a[1][1], v ? a[2][1] : a[0][1]], N = a.yBounds || [a[0][2], a[1][2], v ? a[2][2] : a[0][2]], F = j(_), C = j(N); if (G.align(y, !1, { x: F, y: C, width: g(_) - F, height: g(N) - C }), !G.alignValue || G.alignValue === "left") { let x = y.clip ? w.width : w.chart.chartWidth; G.css({ width: (G.rotation === 90 ? w.height - (G.alignAttr.y - w.top) : x - (G.alignAttr.x - w.left)) + "px" }) } G.show(!0) } getLabelText(y) { return D(y.formatter) ? y.formatter.call(this) : y.text } destroy() { se(this.axis.plotLinesAndBands, this), delete this.axis, J(this) } } return I }), n(i, "Core/Tooltip.js", [i["Core/Templating.js"], i["Core/Globals.js"], i["Core/Renderer/RendererUtilities.js"], i["Core/Renderer/RendererRegistry.js"], i["Core/Utilities.js"]], function (r, s, g, j, D) { var J; let { format: se } = r, { composed: $, doc: R, isSafari: Q } = s, { distribute: E } = g, { addEvent: I, clamp: W, css: y, discardElement: a, extend: v, fireEvent: k, isArray: w, isNumber: L, isString: G, merge: _, pick: N, pushUnique: F, splat: C, syncTimeout: x } = D; class P { constructor(o, u) { this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = o, this.init(o, u) } bodyFormatter(o) { return o.map(function (u) { let l = u.series.tooltipOptions; return (l[(u.point.formatPrefix || "point") + "Formatter"] || u.point.tooltipFormatter).call(u.point, l[(u.point.formatPrefix || "point") + "Format"] || "") }) } cleanSplit(o) { this.chart.series.forEach(function (u) { let l = u && u.tt; l && (!l.isActive || o ? u.tt = l.destroy() : l.isActive = !1) }) } defaultFormatter(o) { let u, l = this.points || C(this); return (u = (u = [o.tooltipFooterHeaderFormatter(l[0])]).concat(o.bodyFormatter(l))).push(o.tooltipFooterHeaderFormatter(l[0], !0)), u } destroy() { this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), a(this.container)), D.clearTimeout(this.hideTimer), D.clearTimeout(this.tooltipTimeout) } getAnchor(o, u) { let l, h = this.chart, d = h.pointer, m = h.inverted, p = h.plotTop, T = h.plotLeft; if ((o = C(o))[0].series && o[0].series.yAxis && !o[0].series.yAxis.options.reversedStacks && (o = o.slice().reverse()), this.followPointer && u) u.chartX === void 0 && (u = d.normalize(u)), l = [u.chartX - T, u.chartY - p]; else if (o[0].tooltipPos) l = o[0].tooltipPos; else { let U = 0, ee = 0; o.forEach(function (Z) { let H = Z.pos(!0); H && (U += H[0], ee += H[1]) }), U /= o.length, ee /= o.length, this.shared && o.length > 1 && u && (m ? U = u.chartX : ee = u.chartY), l = [U - T, ee - p] } return l.map(Math.round) } getClassName(o, u, l) { let h = this.options, d = o.series, m = d.options; return [h.className, "highcharts-label", l && "highcharts-tooltip-header", u ? "highcharts-tooltip-box" : "highcharts-tooltip", !l && "highcharts-color-" + N(o.colorIndex, d.colorIndex), m && m.className].filter(G).join(" ") } getLabel() { let o = this, u = this.chart.styledMode, l = this.options, h = this.split && this.allowShared, d = this.container, m = this.chart.renderer; if (this.label) { let p = !this.label.hasClass("highcharts-label"); (!h && p || h && !p) && this.destroy() } if (!this.label) { if (this.outside) { let p = this.chart.options.chart.style, T = j.getRendererType(); this.container = d = s.doc.createElement("div"), d.className = "highcharts-tooltip-container", y(d, { position: "absolute", top: "1px", pointerEvents: "none", zIndex: Math.max(this.options.style.zIndex || 0, (p && p.zIndex || 0) + 3) }), this.renderer = m = new T(d, 0, 0, p, void 0, void 0, m.styledMode) } if (h ? this.label = m.g("tooltip") : (this.label = m.label("", 0, 0, l.shape, void 0, void 0, l.useHTML, void 0, "tooltip").attr({ padding: l.padding, r: l.borderRadius }), u || this.label.attr({ fill: l.backgroundColor, "stroke-width": l.borderWidth || 0 }).css(l.style).css({ pointerEvents: l.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none") })), o.outside) { let p = this.label, { xSetter: T, ySetter: U } = p; p.xSetter = function (ee) { T.call(p, o.distance), d && (d.style.left = ee + "px") }, p.ySetter = function (ee) { U.call(p, o.distance), d && (d.style.top = ee + "px") } } this.label.attr({ zIndex: 8 }).shadow(l.shadow).add() } return d && !d.parentElement && s.doc.body.appendChild(d), this.label } getPlayingField() { let { body: o, documentElement: u } = R, { chart: l, distance: h, outside: d } = this; return { width: d ? Math.max(o.scrollWidth, u.scrollWidth, o.offsetWidth, u.offsetWidth, u.clientWidth) - 2 * h : l.chartWidth, height: d ? Math.max(o.scrollHeight, u.scrollHeight, o.offsetHeight, u.offsetHeight, u.clientHeight) : l.chartHeight } } getPosition(o, u, l) { var V, X; let { distance: h, chart: d, outside: m } = this, { inverted: p, plotLeft: T, plotTop: U, polar: ee } = d, { plotX: Z = 0, plotY: H = 0 } = l, Y = {}, S = p && l.h || 0, { height: A, width: B } = this.getPlayingField(), K = d.pointer.getChartPosition(), c = te => te * K.scaleX, M = te => te * K.scaleY, b = te => { let ne = te === "x"; return [te, ne ? B : A, ne ? o : u].concat(m ? [ne ? c(o) : M(u), ne ? K.left - h + c(Z + T) : K.top - h + M(H + U), 0, ne ? B : A] : [ne ? o : u, ne ? Z + T : H + U, ne ? T : U, ne ? T + d.plotWidth : U + d.plotHeight]) }, z = b("y"), O = b("x"), q, ie = !!l.negative; !ee && ((X = (V = d.hoverSeries) == null ? void 0 : V.yAxis) != null && X.reversed) && (ie = !ie); let re = !this.followPointer && N(l.ttBelow, !ee && !p === ie), oe = function (te, ne, ae, le, de, ue, ge) { let Se = m ? te === "y" ? M(h) : c(h) : h, fe = (ae - le) / 2, me = le < de - h, ke = de + h + le < ne, be = de - Se - ae + fe, we = de + Se - fe; if (re && ke) Y[te] = we; else if (!re && me) Y[te] = be; else if (me) Y[te] = Math.min(ge - le, be - S < 0 ? be : be - S); else { if (!ke) return !1; Y[te] = Math.max(ue, we + S + ae > ne ? we : we + S) } }, he = function (te, ne, ae, le, de) { if (de < h || de > ne - h) return !1; de < ae / 2 ? Y[te] = 1 : de > ne - le / 2 ? Y[te] = ne - le - 2 : Y[te] = de - ae / 2 }, ce = function (te) { [z, O] = [O, z], q = te }, pe = () => { oe.apply(0, z) !== !1 ? he.apply(0, O) !== !1 || q || (ce(!0), pe()) : q ? Y.x = Y.y = 0 : (ce(!0), pe()) }; return (p && !ee || this.len > 1) && ce(), pe(), Y } hide(o) { let u = this; D.clearTimeout(this.hideTimer), o = N(o, this.options.hideDelay), this.isHidden || (this.hideTimer = x(function () { let l = u.getLabel(); u.getLabel().animate({ opacity: 0 }, { duration: o && 150, complete: () => { l.hide(), u.container && u.container.remove() } }), u.isHidden = !0 }, o)) } init(o, u) { this.chart = o, this.options = u, this.crosshairs = [], this.now = { x: 0, y: 0 }, this.isHidden = !0, this.split = u.split && !o.inverted && !o.polar, this.shared = u.shared || this.split, this.outside = N(u.outside, !!(o.scrollablePixelsX || o.scrollablePixelsY)) } shouldStickOnContact(o) { return !!(!this.followPointer && this.options.stickOnContact && (!o || this.chart.pointer.inClass(o.target, "highcharts-tooltip"))) } move(o, u, l, h) { let d = this, m = d.now, p = d.options.animation !== !1 && !d.isHidden && (Math.abs(o - m.x) > 1 || Math.abs(u - m.y) > 1), T = d.followPointer || d.len > 1; v(m, { x: p ? (2 * m.x + o) / 3 : o, y: p ? (m.y + u) / 2 : u, anchorX: T ? void 0 : p ? (2 * m.anchorX + l) / 3 : l, anchorY: T ? void 0 : p ? (m.anchorY + h) / 2 : h }), d.getLabel().attr(m), d.drawTracker(), p && (D.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () { d && d.move(o, u, l, h) }, 32)) } refresh(o, u) { let l = this.chart, h = this.options, d = l.pointer, m = C(o), p = m[0], T = [], U = h.format, ee = h.formatter || this.defaultFormatter, Z = this.shared, H = l.styledMode, Y = {}; if (!h.enabled || !p.series) return; D.clearTimeout(this.hideTimer), this.allowShared = !(!w(o) && o.series && o.series.noSharedTooltip), this.followPointer = !this.split && p.series.tooltipOptions.followPointer; let S = this.getAnchor(o, u), A = S[0], B = S[1]; Z && this.allowShared ? (d.applyInactiveState(m), m.forEach(function (M) { M.setState("hover"), T.push(M.getLabelConfig()) }), (Y = p.getLabelConfig()).points = T) : Y = p.getLabelConfig(), this.len = T.length; let K = G(U) ? se(U, Y, l) : ee.call(Y, this), c = p.series; if (this.distance = N(c.tooltipOptions.distance, 16), K === !1) this.hide(); else { if (this.split && this.allowShared) this.renderSplit(K, m); else { let M = A, b = B; if (u && d.isDirectTouch && (M = u.chartX - l.plotLeft, b = u.chartY - l.plotTop), l.polar || c.options.clip === !1 || m.some(z => d.isDirectTouch || z.series.shouldShowTooltip(M, b))) { let z = this.getLabel(); (!h.style.width || H) && z.css({ width: (this.outside ? this.getPlayingField() : l.spacingBox).width + "px" }), z.attr({ text: K && K.join ? K.join("") : K }), z.addClass(this.getClassName(p), !0), H || z.attr({ stroke: h.borderColor || p.color || c.color || "#666666" }), this.updatePosition({ plotX: A, plotY: B, negative: p.negative, ttBelow: p.ttBelow, h: S[2] || 0 }) } else { this.hide(); return } } this.isHidden && this.label && this.label.attr({ opacity: 1 }).show(), this.isHidden = !1 } k(this, "refresh") } renderSplit(o, u) { let l = this, { chart: h, chart: { chartWidth: d, chartHeight: m, plotHeight: p, plotLeft: T, plotTop: U, pointer: ee, scrollablePixelsY: Z = 0, scrollablePixelsX: H, scrollingContainer: { scrollLeft: Y, scrollTop: S } = { scrollLeft: 0, scrollTop: 0 }, styledMode: A }, distance: B, options: K, options: { positioner: c } } = l, M = l.outside && typeof H != "number" ? R.documentElement.getBoundingClientRect() : { left: Y, right: Y + d, top: S, bottom: S + m }, b = l.getLabel(), z = this.renderer || h.renderer, O = !!(h.xAxis[0] && h.xAxis[0].opposite), { left: q, top: ie } = ee.getChartPosition(), re = U + S, oe = 0, he = p - Z; function ce(ae, le, de, ue, ge = !0) { let Se, fe; return de ? (Se = O ? 0 : he, fe = W(ae - ue / 2, M.left, M.right - ue - (l.outside ? q : 0))) : (Se = le - re, fe = W(fe = ge ? ae - ue - B : ae + B, ge ? fe : M.left, M.right)), { x: fe, y: Se } } G(o) && (o = [!1, o]); let pe = o.slice(0, u.length + 1).reduce(function (ae, le, de) { if (le !== !1 && le !== "") { let ue = u[de - 1] || { isHeader: !0, plotX: u[0].plotX, plotY: p, series: {} }, ge = ue.isHeader, Se = ge ? l : ue.series, fe = Se.tt = function (ye, Te, Me) { let Ee = ye, { isHeader: je, series: $e } = Te; if (!Ee) { let ct = { padding: K.padding, r: K.borderRadius }; A || (ct.fill = K.backgroundColor, ct["stroke-width"] = K.borderWidth ?? 1), Ee = z.label("", 0, 0, K[je ? "headerShape" : "shape"], void 0, void 0, K.useHTML).addClass(l.getClassName(Te, !0, je)).attr(ct).add(b) } return Ee.isActive = !0, Ee.attr({ text: Me }), A || Ee.css(K.style).attr({ stroke: K.borderColor || Te.color || $e.color || "#333333" }), Ee }(Se.tt, ue, le.toString()), me = fe.getBBox(), ke = me.width + fe.strokeWidth(); ge && (oe = me.height, he += oe, O && (re -= oe)); let { anchorX: be, anchorY: we } = function (ye) { let Te, Me, { isHeader: Ee, plotX: je = 0, plotY: $e = 0, series: ct } = ye; if (Ee) Te = Math.max(T + je, T), Me = U + p / 2; else { let { xAxis: Ue, yAxis: jt } = ct; Te = Ue.pos + W(je, -B, Ue.len + B), ct.shouldShowTooltip(0, jt.pos - U + $e, { ignoreX: !0 }) && (Me = jt.pos + $e) } return { anchorX: Te = W(Te, M.left - B, M.right + B), anchorY: Me } }(ue); if (typeof we == "number") { let ye = me.height + 1, Te = c ? c.call(l, ke, ye, ue) : ce(be, we, ge, ke); ae.push({ align: c ? 0 : void 0, anchorX: be, anchorY: we, boxWidth: ke, point: ue, rank: N(Te.rank, ge ? 1 : 0), size: ye, target: Te.y, tt: fe, x: Te.x }) } else fe.isActive = !1 } return ae }, []); !c && pe.some(ae => { let { outside: le } = l, de = (le ? q : 0) + ae.anchorX; return de < M.left && de + ae.boxWidth < M.right || de < q - M.left + ae.boxWidth && M.right - de > de }) && (pe = pe.map(ae => { let { x: le, y: de } = ce(ae.anchorX, ae.anchorY, ae.point.isHeader, ae.boxWidth, !1); return v(ae, { target: de, x: le }) })), l.cleanSplit(), E(pe, he); let V = { left: q, right: q }; pe.forEach(function (ae) { let { x: le, boxWidth: de, isHeader: ue } = ae; !ue && (l.outside && q + le < V.left && (V.left = q + le), !ue && l.outside && V.left + de > V.right && (V.right = q + le)) }), pe.forEach(function (ae) { let { x: le, anchorX: de, anchorY: ue, pos: ge, point: { isHeader: Se } } = ae, fe = { visibility: ge === void 0 ? "hidden" : "inherit", x: le, y: (ge || 0) + re, anchorX: de, anchorY: ue }; if (l.outside && le < de) { let me = q - V.left; me > 0 && (Se || (fe.x = le + me, fe.anchorX = de + me), Se && (fe.x = (V.right - V.left) / 2, fe.anchorX = de + me)) } ae.tt.attr(fe) }); let { container: X, outside: te, renderer: ne } = l; if (te && X && ne) { let { width: ae, height: le, x: de, y: ue } = b.getBBox(); ne.setSize(ae + de, le + ue, !1), X.style.left = V.left + "px", X.style.top = ie + "px" } Q && b.attr({ opacity: b.opacity === 1 ? .999 : 1 }) } drawTracker() { if (!this.shouldStickOnContact()) { this.tracker && (this.tracker = this.tracker.destroy()); return } let o = this.chart, u = this.label, l = this.shared ? o.hoverPoints : o.hoverPoint; if (!u || !l) return; let h = { x: 0, y: 0, width: 0, height: 0 }, d = this.getAnchor(l), m = u.getBBox(); d[0] += o.plotLeft - (u.translateX || 0), d[1] += o.plotTop - (u.translateY || 0), h.x = Math.min(0, d[0]), h.y = Math.min(0, d[1]), h.width = d[0] < 0 ? Math.max(Math.abs(d[0]), m.width - d[0]) : Math.max(Math.abs(d[0]), m.width), h.height = d[1] < 0 ? Math.max(Math.abs(d[1]), m.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), m.height), this.tracker ? this.tracker.attr(h) : (this.tracker = u.renderer.rect(h).addClass("highcharts-tracker").add(u), o.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" })) } styledModeFormat(o) { return o.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"') } tooltipFooterHeaderFormatter(o, u) { let l = o.series, h = l.tooltipOptions, d = l.xAxis, m = d && d.dateTime, p = { isFooter: u, labelConfig: o }, T = h.xDateFormat, U = h[u ? "footerFormat" : "headerFormat"]; return k(this, "headerFormatter", p, function (ee) { m && !T && L(o.key) && (T = m.getXDateFormat(o.key, h.dateTimeLabelFormats)), m && T && (o.point && o.point.tooltipDateKeys || ["key"]).forEach(function (Z) { U = U.replace("{point." + Z + "}", "{point." + Z + ":" + T + "}") }), l.chart.styledMode && (U = this.styledModeFormat(U)), ee.text = se(U, { point: o, series: l }, this.chart) }), p.text } update(o) { this.destroy(), this.init(this.chart, _(!0, this.options, o)) } updatePosition(o) { let { chart: u, container: l, distance: h, options: d, renderer: m } = this, { height: p = 0, width: T = 0 } = this.getLabel(), U = u.pointer, { left: ee, top: Z, scaleX: H, scaleY: Y } = U.getChartPosition(), S = (d.positioner || this.getPosition).call(this, T, p, o), A = (o.plotX || 0) + u.plotLeft, B = (o.plotY || 0) + u.plotTop, K; m && l && (d.positioner && (S.x += ee - h, S.y += Z - h), K = (d.borderWidth || 0) + 2 * h + 2, m.setSize(T + K, p + K, !1), (H !== 1 || Y !== 1) && (y(l, { transform: `scale(${H}, ${Y})` }), A *= H, B *= Y), A += ee - S.x, B += Z - S.y), this.move(Math.round(S.x), Math.round(S.y || 0), A, B) } } return (J = P || (P = {})).compose = function f(o) { F($, f) && I(o, "afterInit", function () { let u = this.chart; u.options.tooltip && (u.tooltip = new J(u, u.options.tooltip)) }) }, P }), n(i, "Core/Series/Point.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Animation/AnimationUtilities.js"], i["Core/Defaults.js"], i["Core/Templating.js"], i["Core/Utilities.js"]], function (r, s, g, j, D) { let { animObject: J } = s, { defaultOptions: se } = g, { format: $ } = j, { addEvent: R, defined: Q, erase: E, extend: I, fireEvent: W, getNestedProperty: y, isArray: a, isFunction: v, isNumber: k, isObject: w, merge: L, objectEach: G, pick: _, syncTimeout: N, removeEvent: F, uniqueKey: C } = D; class x { animateBeforeDestroy() { let f = this, o = { x: f.startXPos, opacity: 0 }, u = f.getGraphicalProps(); u.singular.forEach(function (l) { f[l] = f[l].animate(l === "dataLabel" ? { x: f[l].startXPos, y: f[l].startYPos, opacity: 0 } : o) }), u.plural.forEach(function (l) { f[l].forEach(function (h) { h.element && h.animate(I({ x: f.startXPos }, h.startYPos ? { x: h.startXPos, y: h.startYPos } : {})) }) }) } applyOptions(f, o) { let u = this.series, l = u.options.pointValKey || u.pointValKey; return I(this, f = x.prototype.optionsToObject.call(this, f)), this.options = this.options ? I(this.options, f) : f, f.group && delete this.group, f.dataLabels && delete this.dataLabels, l && (this.y = x.prototype.getNestedProperty.call(this, l)), this.selected && (this.state = "select"), "name" in this && o === void 0 && u.xAxis && u.xAxis.hasNames && (this.x = u.xAxis.nameToX(this)), this.x === void 0 && u ? o === void 0 ? this.x = u.autoIncrement() : this.x = o : k(f.x) && u.options.relativeXValue && (this.x = u.autoIncrement(f.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this } destroy() { if (!this.destroyed) { let f = this, o = f.series, u = o.chart, l = o.options.dataSorting, h = u.hoverPoints, d = f.series.chart.renderer.globalAnimation, m = J(d), p = () => { for (let T in (f.graphic || f.graphics || f.dataLabel || f.dataLabels) && (F(f), f.destroyElements()), f) delete f[T] }; f.legendItem && u.legend.destroyItem(f), h && (f.setState(), E(h, f), h.length || (u.hoverPoints = null)), f === u.hoverPoint && f.onMouseOut(), l && l.enabled ? (this.animateBeforeDestroy(), N(p, m.duration)) : p(), u.pointCount-- } this.destroyed = !0 } destroyElements(f) { let o = this, u = o.getGraphicalProps(f); u.singular.forEach(function (l) { o[l] = o[l].destroy() }), u.plural.forEach(function (l) { o[l].forEach(function (h) { h && h.element && h.destroy() }), delete o[l] }) } firePointEvent(f, o, u) { let l = this, h = this.series, d = h.options; (d.point.events[f] || l.options && l.options.events && l.options.events[f]) && l.importEvents(), f === "click" && d.allowPointSelect && (u = function (m) { !l.destroyed && l.select && l.select(null, m.ctrlKey || m.metaKey || m.shiftKey) }), W(l, f, o, u) } getClassName() { return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (this.colorIndex !== void 0 ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "") } getGraphicalProps(f) { let o, u, l = this, h = [], d = { singular: [], plural: [] }; for ((f = f || { graphic: 1, dataLabel: 1 }).graphic && h.push("graphic", "connector"), f.dataLabel && h.push("dataLabel", "dataLabelPath", "dataLabelUpper"), u = h.length; u--;)l[o = h[u]] && d.singular.push(o); return ["graphic", "dataLabel"].forEach(function (m) { let p = m + "s"; f[m] && l[p] && d.plural.push(p) }), d } getLabelConfig() { return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal } } getNestedProperty(f) { return f ? f.indexOf("custom.") === 0 ? y(f, this.options) : this[f] : void 0 } getZone() { let f = this.series, o = f.zones, u = f.zoneAxis || "y", l, h = 0; for (l = o[0]; this[u] >= l.value;)l = o[++h]; return this.nonZonedColor || (this.nonZonedColor = this.color), l && l.color && !this.options.color ? this.color = l.color : this.color = this.nonZonedColor, l } hasNewShapeType() { return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType } constructor(f, o, u) { this.formatPrefix = "point", this.visible = !0, this.series = f, this.applyOptions(o, u), this.id ?? (this.id = C()), this.resolveColor(), f.chart.pointCount++, W(this, "afterInit") } isValid() { return (k(this.x) || this.x instanceof Date) && k(this.y) } optionsToObject(f) { let o = this.series, u = o.options.keys, l = u || o.pointArrayMap || ["y"], h = l.length, d = {}, m, p = 0, T = 0; if (k(f) || f === null) d[l[0]] = f; else if (a(f)) for (!u && f.length > h && ((m = typeof f[0]) == "string" ? d.name = f[0] : m === "number" && (d.x = f[0]), p++); T < h;)u && f[p] === void 0 || (l[T].indexOf(".") > 0 ? x.prototype.setNestedProperty(d, f[p], l[T]) : d[l[T]] = f[p]), p++, T++; else typeof f == "object" && (d = f, f.dataLabels && (o.hasDataLabels = () => !0), f.marker && (o._hasPointMarkers = !0)); return d } pos(f, o = this.plotY) { if (!this.destroyed) { let { plotX: u, series: l } = this, { chart: h, xAxis: d, yAxis: m } = l, p = 0, T = 0; if (k(u) && k(o)) return f && (p = d ? d.pos : h.plotLeft, T = m ? m.pos : h.plotTop), h.inverted && d && m ? [m.len - o + T, d.len - u + p] : [u + p, o + T] } } resolveColor() { let f = this.series, o = f.chart.options.chart, u = f.chart.styledMode, l, h, d = o.colorCount, m; delete this.nonZonedColor, f.options.colorByPoint ? (u || (l = (h = f.options.colors || f.chart.options.colors)[f.colorCounter], d = h.length), m = f.colorCounter, f.colorCounter++, f.colorCounter === d && (f.colorCounter = 0)) : (u || (l = f.color), m = f.colorIndex), this.colorIndex = _(this.options.colorIndex, m), this.color = _(this.options.color, l) } setNestedProperty(f, o, u) { return u.split(".").reduce(function (h, d, m, p) { let T = p.length - 1 === m; return h[d] = T ? o : w(h[d], !0) ? h[d] : {}, h[d] }, f), f } shouldDraw() { return !this.isNull } tooltipFormatter(f) { let o = this.series, u = o.tooltipOptions, l = _(u.valueDecimals, ""), h = u.valuePrefix || "", d = u.valueSuffix || ""; return o.chart.styledMode && (f = o.chart.tooltip.styledModeFormat(f)), (o.pointArrayMap || ["y"]).forEach(function (m) { m = "{point." + m, (h || d) && (f = f.replace(RegExp(m + "}", "g"), h + m + "}" + d)), f = f.replace(RegExp(m + "}", "g"), m + ":,." + l + "f}") }), $(f, { point: this, series: this.series }, o.chart) } update(f, o, u, l) { let h, d = this, m = d.series, p = d.graphic, T = m.chart, U = m.options; function ee() { d.applyOptions(f); let Z = p && d.hasMockGraphic, H = d.y === null ? !Z : Z; p && H && (d.graphic = p.destroy(), delete d.hasMockGraphic), w(f, !0) && (p && p.element && f && f.marker && f.marker.symbol !== void 0 && (d.graphic = p.destroy()), f != null && f.dataLabels && d.dataLabel && (d.dataLabel = d.dataLabel.destroy())), h = d.index, m.updateParallelArrays(d, h), U.data[h] = w(U.data[h], !0) || w(f, !0) ? d.options : _(f, U.data[h]), m.isDirty = m.isDirtyData = !0, !m.fixedBox && m.hasCartesianSeries && (T.isDirtyBox = !0), U.legendType === "point" && (T.isDirtyLegend = !0), o && T.redraw(u) } o = _(o, !0), l === !1 ? ee() : d.firePointEvent("update", { options: f }, ee) } remove(f, o) { this.series.removePoint(this.series.data.indexOf(this), f, o) } select(f, o) { let u = this, l = u.series, h = l.chart; f = _(f, !u.selected), this.selectedStaging = f, u.firePointEvent(f ? "select" : "unselect", { accumulate: o }, function () { u.selected = u.options.selected = f, l.options.data[l.data.indexOf(u)] = u.options, u.setState(f && "select"), o || h.getSelectedPoints().forEach(function (d) { let m = d.series; d.selected && d !== u && (d.selected = d.options.selected = !1, m.options.data[m.data.indexOf(d)] = d.options, d.setState(h.hoverPoints && m.options.inactiveOtherPoints ? "inactive" : ""), d.firePointEvent("unselect")) }) }), delete this.selectedStaging } onMouseOver(f) { let o = this.series, u = o.chart, l = u.pointer; f = f ? l.normalize(f) : l.getChartCoordinatesFromPoint(this, u.inverted), l.runPointActions(f, this) } onMouseOut() { let f = this.series.chart; this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (f.hoverPoints || []).forEach(function (o) { o.setState() }), f.hoverPoints = f.hoverPoint = null } importEvents() { if (!this.hasImportedEvents) { let f = this, o = L(f.series.options.point, f.options), u = o.events; f.events = u, G(u, function (l, h) { v(l) && R(f, h, l) }), this.hasImportedEvents = !0 } } setState(f, o) { let u = this.series, l = this.state, h = u.options.states[f || "normal"] || {}, d = se.plotOptions[u.type].marker && u.options.marker, m = d && d.enabled === !1, p = d && d.states && d.states[f || "normal"] || {}, T = p.enabled === !1, U = this.marker || {}, ee = u.chart, Z = d && u.markerAttribs, H = u.halo, Y, S, A, B = u.stateMarkerGraphic, K; if ((f = f || "") === this.state && !o || this.selected && f !== "select" || h.enabled === !1 || f && (T || m && p.enabled === !1) || f && U.states && U.states[f] && U.states[f].enabled === !1) return; if (this.state = f, Z && (Y = u.markerAttribs(this, f)), this.graphic && !this.hasMockGraphic) { if (l && this.graphic.removeClass("highcharts-point-" + l), f && this.graphic.addClass("highcharts-point-" + f), !ee.styledMode) { S = u.pointAttribs(this, f), A = _(ee.options.chart.animation, h.animation); let z = S.opacity; u.options.inactiveOtherPoints && k(z) && (this.dataLabels || []).forEach(function (O) { O && !O.hasClass("highcharts-data-label-hidden") && (O.animate({ opacity: z }, A), O.connector && O.connector.animate({ opacity: z }, A)) }), this.graphic.animate(S, A) } Y && this.graphic.animate(Y, _(ee.options.chart.animation, p.animation, d.animation)), B && B.hide() } else f && p && (K = U.symbol || u.symbol, B && B.currentSymbol !== K && (B = B.destroy()), Y && (B ? B[o ? "animate" : "attr"]({ x: Y.x, y: Y.y }) : K && (u.stateMarkerGraphic = B = ee.renderer.symbol(K, Y.x, Y.y, Y.width, Y.height).add(u.markerGroup), B.currentSymbol = K)), !ee.styledMode && B && this.state !== "inactive" && B.attr(u.pointAttribs(this, f))), B && (B[f && this.isInside ? "show" : "hide"](), B.element.point = this, B.addClass(this.getClassName(), !0)); let c = h.halo, M = this.graphic || B, b = M && M.visibility || "inherit"; c && c.size && M && b !== "hidden" && !this.isCluster ? (H || (u.halo = H = ee.renderer.path().add(M.parentGroup)), H.show()[o ? "animate" : "attr"]({ d: this.haloPath(c.size) }), H.attr({ class: "highcharts-halo highcharts-color-" + _(this.colorIndex, u.colorIndex) + (this.className ? " " + this.className : ""), visibility: b, zIndex: -1 }), H.point = this, ee.styledMode || H.attr(I({ fill: this.color || u.color, "fill-opacity": c.opacity }, r.filterUserAttributes(c.attributes || {})))) : H && H.point && H.point.haloPath && H.animate({ d: H.point.haloPath(0) }, null, H.hide), W(this, "afterSetState", { state: f }) } haloPath(f) { let o = this.pos(); return o ? this.series.chart.renderer.symbols.circle(Math.floor(o[0]) - f, o[1] - f, 2 * f, 2 * f) : [] } } return x }), n(i, "Core/Pointer.js", [i["Core/Color/Color.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g) { var j; let { parse: D } = r, { charts: J, composed: se, noop: $ } = s, { addEvent: R, attr: Q, css: E, defined: I, extend: W, find: y, fireEvent: a, isNumber: v, isObject: k, objectEach: w, offset: L, pick: G, pushUnique: _, splat: N } = g; class F { applyInactiveState(x) { let P = [], f; (x || []).forEach(function (o) { f = o.series, P.push(f), f.linkedParent && P.push(f.linkedParent), f.linkedSeries && (P = P.concat(f.linkedSeries)), f.navigatorSeries && P.push(f.navigatorSeries) }), this.chart.series.forEach(function (o) { P.indexOf(o) === -1 ? o.setState("inactive", !0) : o.options.inactiveOtherPoints && o.setAllPointsToState("inactive") }) } destroy() { let x = this; this.eventsToUnbind.forEach(P => P()), this.eventsToUnbind = [], !s.chartCount && (F.unbindDocumentMouseUp && (F.unbindDocumentMouseUp = F.unbindDocumentMouseUp()), F.unbindDocumentTouchEnd && (F.unbindDocumentTouchEnd = F.unbindDocumentTouchEnd())), clearInterval(x.tooltipTimeout), w(x, function (P, f) { x[f] = void 0 }) } getSelectionMarkerAttrs(x, P) { let f = { args: { chartX: x, chartY: P }, attrs: {}, shapeType: "rect" }; return a(this, "getSelectionMarkerAttrs", f, o => { let u, { chart: l, mouseDownX: h = 0, mouseDownY: d = 0, zoomHor: m, zoomVert: p } = this, T = o.attrs; T.x = l.plotLeft, T.y = l.plotTop, T.width = m ? 1 : l.plotWidth, T.height = p ? 1 : l.plotHeight, m && (u = x - h, T.width = Math.abs(u), T.x = (u > 0 ? 0 : u) + h), p && (u = P - d, T.height = Math.abs(u), T.y = (u > 0 ? 0 : u) + d) }), f } drag(x) { let P = this.chart, f = P.options.chart, o = P.plotLeft, u = P.plotTop, l = P.plotWidth, h = P.plotHeight, d = this.mouseDownX || 0, m = this.mouseDownY || 0, p = k(f.panning) ? f.panning && f.panning.enabled : f.panning, T = f.panKey && x[f.panKey + "Key"], U = x.chartX, ee = x.chartY, Z, H = this.selectionMarker; if ((!H || !H.touch) && (U < o ? U = o : U > o + l && (U = o + l), ee < u ? ee = u : ee > u + h && (ee = u + h), this.hasDragged = Math.sqrt(Math.pow(d - U, 2) + Math.pow(m - ee, 2)), this.hasDragged > 10)) { Z = P.isInsidePlot(d - o, m - u, { visiblePlotOnly: !0 }); let { shapeType: Y, attrs: S } = this.getSelectionMarkerAttrs(U, ee); (P.hasCartesianSeries || P.mapView) && (this.zoomX || this.zoomY) && Z && !T && !H && (this.selectionMarker = H = P.renderer[Y](), H.attr({ class: "highcharts-selection-marker", zIndex: 7 }).add(), P.styledMode || H.attr({ fill: f.selectionMarkerFill || D("#334eff").setOpacity(.25).get() })), H && H.attr(S), Z && !H && p && P.pan(x, f.panning) } } dragStart(x) { let P = this.chart; P.mouseIsDown = x.type, P.cancelClick = !1, P.mouseDownX = this.mouseDownX = x.chartX, P.mouseDownY = this.mouseDownY = x.chartY } getSelectionBox(x) { let P = { args: { marker: x }, result: {} }; return a(this, "getSelectionBox", P, f => { f.result = { x: x.attr ? +x.attr("x") : x.x, y: x.attr ? +x.attr("y") : x.y, width: x.attr ? x.attr("width") : x.width, height: x.attr ? x.attr("height") : x.height } }), P.result } drop(x) { let P = this, f = this.chart, o = this.hasPinched; if (this.selectionMarker) { let { x: u, y: l, width: h, height: d } = this.getSelectionBox(this.selectionMarker), m = { originalEvent: x, xAxis: [], yAxis: [], x: u, y: l, width: h, height: d }, p = !!f.mapView; (this.hasDragged || o) && (f.axes.forEach(function (T) { if (T.zoomEnabled && I(T.min) && (o || P[{ xAxis: "zoomX", yAxis: "zoomY" }[T.coll]]) && v(u) && v(l) && v(h) && v(d)) { let U = T.horiz, ee = x.type === "touchend" ? T.minPixelPadding : 0, Z = T.toValue((U ? u : l) + ee), H = T.toValue((U ? u + h : l + d) - ee); m[T.coll].push({ axis: T, min: Math.min(Z, H), max: Math.max(Z, H) }), p = !0 } }), p && a(f, "selection", m, function (T) { f.zoom(W(T, o ? { animation: !1 } : null)) })), v(f.index) && (this.selectionMarker = this.selectionMarker.destroy()), o && this.scaleGroups() } f && v(f.index) && (E(f.container, { cursor: f._cursor }), f.cancelClick = +this.hasDragged > 10, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []) } findNearestKDPoint(x, P, f) { let o; return x.forEach(function (u) { let l = u.noSharedTooltip && P, h = !l && 0 > u.options.findNearestPointBy.indexOf("y"), d = u.searchPoint(f, h); k(d, !0) && d.series && (!k(o, !0) || function (m, p) { let T = m.distX - p.distX, U = m.dist - p.dist, ee = (p.series.group && p.series.group.zIndex) - (m.series.group && m.series.group.zIndex); return T !== 0 && P ? T : U !== 0 ? U : ee !== 0 ? ee : m.series.index > p.series.index ? -1 : 1 }(o, d) > 0) && (o = d) }), o } getChartCoordinatesFromPoint(x, P) { let f = x.series, o = f.xAxis, u = f.yAxis, l = x.shapeArgs; if (o && u) { let h = G(x.clientX, x.plotX), d = x.plotY || 0; return x.isNode && l && v(l.x) && v(l.y) && (h = l.x, d = l.y), P ? { chartX: u.len + u.pos - d, chartY: o.len + o.pos - h } : { chartX: h + o.pos, chartY: d + u.pos } } if (l && l.x && l.y) return { chartX: l.x, chartY: l.y } } getChartPosition() { if (this.chartPosition) return this.chartPosition; let { container: x } = this.chart, P = L(x); this.chartPosition = { left: P.left, top: P.top, scaleX: 1, scaleY: 1 }; let f = x.offsetWidth, o = x.offsetHeight; return f > 2 && o > 2 && (this.chartPosition.scaleX = P.width / f, this.chartPosition.scaleY = P.height / o), this.chartPosition } getCoordinates(x) { let P = { xAxis: [], yAxis: [] }; return this.chart.axes.forEach(function (f) { P[f.isXAxis ? "xAxis" : "yAxis"].push({ axis: f, value: f.toValue(x[f.horiz ? "chartX" : "chartY"]) }) }), P } getHoverData(x, P, f, o, u, l) { let h = [], d = function (Z) { return Z.visible && !(!u && Z.directTouch) && G(Z.options.enableMouseTracking, !0) }, m = P, p, T = { chartX: l ? l.chartX : void 0, chartY: l ? l.chartY : void 0, shared: u }; a(this, "beforeGetHoverData", T), p = m && !m.stickyTracking ? [m] : f.filter(Z => Z.stickyTracking && (T.filter || d)(Z)); let ee = o && x || !l ? x : this.findNearestKDPoint(p, u, l); return m = ee && ee.series, ee && (u && !m.noSharedTooltip ? (p = f.filter(function (Z) { return T.filter ? T.filter(Z) : d(Z) && !Z.noSharedTooltip })).forEach(function (Z) { let H = y(Z.points, function (Y) { return Y.x === ee.x && !Y.isNull }); k(H) && (Z.boosted && Z.boost && (H = Z.boost.getPoint(H)), h.push(H)) }) : h.push(ee)), a(this, "afterGetHoverData", T = { hoverPoint: ee }), { hoverPoint: T.hoverPoint, hoverSeries: m, hoverPoints: h } } getPointFromEvent(x) { let P = x.target, f; for (; P && !f;)f = P.point, P = P.parentNode; return f } onTrackerMouseOut(x) { let P = this.chart, f = x.relatedTarget, o = P.hoverSeries; this.isDirectTouch = !1, !o || !f || o.stickyTracking || this.inClass(f, "highcharts-tooltip") || this.inClass(f, "highcharts-series-" + o.index) && this.inClass(f, "highcharts-tracker") || o.onMouseOut() } inClass(x, P) { let f = x, o; for (; f;) { if (o = Q(f, "class")) { if (o.indexOf(P) !== -1) return !0; if (o.indexOf("highcharts-container") !== -1) return !1 } f = f.parentElement } } constructor(x, P) { var f; this.hasDragged = !1, this.lastValidTouch = {}, this.pinchDown = [], this.eventsToUnbind = [], this.options = P, this.chart = x, this.runChartClick = !!((f = P.chart.events) != null && f.click), this.pinchDown = [], this.lastValidTouch = {}, this.setDOMEvents(), a(this, "afterInit") } normalize(x, P) { let f = x.touches, o = f ? f.length ? f.item(0) : G(f.changedTouches, x.changedTouches)[0] : x; P || (P = this.getChartPosition()); let u = o.pageX - P.left, l = o.pageY - P.top; return W(x, { chartX: Math.round(u /= P.scaleX), chartY: Math.round(l /= P.scaleY) }) } onContainerClick(x) { let P = this.chart, f = P.hoverPoint, o = this.normalize(x), u = P.plotLeft, l = P.plotTop; !P.cancelClick && (f && this.inClass(o.target, "highcharts-tracker") ? (a(f.series, "click", W(o, { point: f })), P.hoverPoint && f.firePointEvent("click", o)) : (W(o, this.getCoordinates(o)), P.isInsidePlot(o.chartX - u, o.chartY - l, { visiblePlotOnly: !0 }) && a(P, "click", o))) } onContainerMouseDown(x) { let P = (1 & (x.buttons || x.button)) == 1; x = this.normalize(x), s.isFirefox && x.button !== 0 && this.onContainerMouseMove(x), (x.button === void 0 || P) && (this.zoomOption(x), P && x.preventDefault && x.preventDefault(), this.dragStart(x)) } onContainerMouseLeave(x) { let P = J[G(F.hoverChartIndex, -1)]; x = this.normalize(x), this.onContainerMouseMove(x), P && x.relatedTarget && !this.inClass(x.relatedTarget, "highcharts-tooltip") && (P.pointer.reset(), P.pointer.chartPosition = void 0) } onContainerMouseEnter(x) { delete this.chartPosition } onContainerMouseMove(x) { let P = this.chart, f = P.tooltip, o = this.normalize(x); this.setHoverChartIndex(x), (P.mouseIsDown === "mousedown" || this.touchSelect(o)) && this.drag(o), !P.openMenu && (this.inClass(o.target, "highcharts-tracker") || P.isInsidePlot(o.chartX - P.plotLeft, o.chartY - P.plotTop, { visiblePlotOnly: !0 })) && !(f && f.shouldStickOnContact(o)) && (this.inClass(o.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(o)) } onDocumentTouchEnd(x) { let P = J[G(F.hoverChartIndex, -1)]; P && P.pointer.drop(x) } onContainerTouchMove(x) { this.touchSelect(x) ? this.onContainerMouseMove(x) : this.touch(x) } onContainerTouchStart(x) { this.touchSelect(x) ? this.onContainerMouseDown(x) : (this.zoomOption(x), this.touch(x, !0)) } onDocumentMouseMove(x) { let P = this.chart, f = P.tooltip, o = this.chartPosition, u = this.normalize(x, o); !o || P.isInsidePlot(u.chartX - P.plotLeft, u.chartY - P.plotTop, { visiblePlotOnly: !0 }) || f && f.shouldStickOnContact(u) || this.inClass(u.target, "highcharts-tracker") || this.reset() } onDocumentMouseUp(x) { let P = J[G(F.hoverChartIndex, -1)]; P && P.pointer.drop(x) } pinch(x) { let P = this, f = P.chart, o = P.pinchDown, u = x.touches || [], l = u.length, h = P.lastValidTouch, d = P.hasZoom, m = {}, p = l === 1 && (P.inClass(x.target, "highcharts-tracker") && f.runTrackerClick || P.runChartClick), T = {}, U = P.chart.tooltip, ee = l === 1 && G(U && U.options.followTouchMove, !0), Z = P.selectionMarker; l > 1 ? P.initiated = !0 : ee && (P.initiated = !1), d && P.initiated && !p && x.cancelable !== !1 && x.preventDefault(), [].map.call(u, function (H) { return P.normalize(H) }), x.type === "touchstart" ? ([].forEach.call(u, function (H, Y) { o[Y] = { chartX: H.chartX, chartY: H.chartY } }), h.x = [o[0].chartX, o[1] && o[1].chartX], h.y = [o[0].chartY, o[1] && o[1].chartY], f.axes.forEach(function (H) { if (H.zoomEnabled) { let Y = f.bounds[H.horiz ? "h" : "v"], S = H.minPixelPadding, A = H.toPixels(Math.min(G(H.options.min, H.dataMin), H.dataMin)), B = H.toPixels(Math.max(G(H.options.max, H.dataMax), H.dataMax)), K = Math.min(A, B), c = Math.max(A, B); Y.min = Math.min(H.pos, K - S), Y.max = Math.max(H.pos + H.len, c + S) } }), P.res = !0) : ee ? this.runPointActions(P.normalize(x)) : o.length && (a(f, "touchpan", { originalEvent: x }, () => { Z || (P.selectionMarker = Z = W({ destroy: $, touch: !0 }, f.plotBox)), P.pinchTranslate(o, u, m, Z, T, h), P.hasPinched = d, P.scaleGroups(m, T) }), P.res && (P.res = !1, this.reset(!1, 0))) } pinchTranslate(x, P, f, o, u, l) { this.zoomHor && this.pinchTranslateDirection(!0, x, P, f, o, u, l), this.zoomVert && this.pinchTranslateDirection(!1, x, P, f, o, u, l) } pinchTranslateDirection(x, P, f, o, u, l, h, d) { let m = this.chart, p = x ? "x" : "y", T = x ? "X" : "Y", U = "chart" + T, ee = x ? "width" : "height", Z = m["plot" + (x ? "Left" : "Top")], H = m.inverted, Y = m.bounds[x ? "h" : "v"], S = P.length === 1, A = P[0][U], B = !S && P[1][U], K = function () { typeof q == "number" && Math.abs(A - B) > 20 && (z = d || Math.abs(O - q) / Math.abs(A - B)), b = (Z - O) / z + A, c = m["plot" + (x ? "Width" : "Height")] / z }, c, M, b, z = d || 1, O = f[0][U], q = !S && f[1][U], ie; K(), (M = b) < Y.min ? (M = Y.min, ie = !0) : M + c > Y.max && (M = Y.max - c, ie = !0), ie ? (O -= .8 * (O - h[p][0]), typeof q == "number" && (q -= .8 * (q - h[p][1])), K()) : h[p] = [O, q], H || (l[p] = b - Z, l[ee] = c); let re = H ? x ? "scaleY" : "scaleX" : "scale" + T, oe = H ? 1 / z : z; u[ee] = c, u[p] = M, o[re] = z * (H && !x ? -1 : 1), o["translate" + T] = oe * Z + (O - oe * A) } reset(x, P) { let f = this.chart, o = f.hoverSeries, u = f.hoverPoint, l = f.hoverPoints, h = f.tooltip, d = h && h.shared ? l : u; x && d && N(d).forEach(function (m) { m.series.isCartesian && m.plotX === void 0 && (x = !1) }), x ? h && d && N(d).length && (h.refresh(d), h.shared && l ? l.forEach(function (m) { m.setState(m.state, !0), m.series.isCartesian && (m.series.xAxis.crosshair && m.series.xAxis.drawCrosshair(null, m), m.series.yAxis.crosshair && m.series.yAxis.drawCrosshair(null, m)) }) : u && (u.setState(u.state, !0), f.axes.forEach(function (m) { m.crosshair && u.series[m.coll] === m && m.drawCrosshair(null, u) }))) : (u && u.onMouseOut(), l && l.forEach(function (m) { m.setState() }), o && o.onMouseOut(), h && h.hide(P), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), f.axes.forEach(function (m) { m.hideCrosshair() }), this.hoverX = f.hoverPoints = f.hoverPoint = null) } runPointActions(x, P, f) { let o = this.chart, u = o.series, l = o.tooltip && o.tooltip.options.enabled ? o.tooltip : void 0, h = !!l && l.shared, d = P || o.hoverPoint, m = d && d.series || o.hoverSeries, p = (!x || x.type !== "touchmove") && (!!P || m && m.directTouch && this.isDirectTouch), T = this.getHoverData(d, m, u, p, h, x); d = T.hoverPoint, m = T.hoverSeries; let U = T.hoverPoints, ee = m && m.tooltipOptions.followPointer && !m.tooltipOptions.split, Z = h && m && !m.noSharedTooltip; if (d && (f || d !== o.hoverPoint || l && l.isHidden)) { if ((o.hoverPoints || []).forEach(function (H) { U.indexOf(H) === -1 && H.setState() }), o.hoverSeries !== m && m.onMouseOver(), this.applyInactiveState(U), (U || []).forEach(function (H) { H.setState("hover") }), o.hoverPoint && o.hoverPoint.firePointEvent("mouseOut"), !d.series) return; o.hoverPoints = U, o.hoverPoint = d, d.firePointEvent("mouseOver", void 0, () => { l && d && l.refresh(Z ? U : d, x) }) } else if (ee && l && !l.isHidden) { let H = l.getAnchor([{}], x); o.isInsidePlot(H[0], H[1], { visiblePlotOnly: !0 }) && l.updatePosition({ plotX: H[0], plotY: H[1] }) } this.unDocMouseMove || (this.unDocMouseMove = R(o.container.ownerDocument, "mousemove", function (H) { let Y = J[F.hoverChartIndex]; Y && Y.pointer.onDocumentMouseMove(H) }), this.eventsToUnbind.push(this.unDocMouseMove)), o.axes.forEach(function (H) { let Y, S = G((H.crosshair || {}).snap, !0); !S || (Y = o.hoverPoint) && Y.series[H.coll] === H || (Y = y(U, A => A.series && A.series[H.coll] === H)), Y || !S ? H.drawCrosshair(x, Y) : H.hideCrosshair() }) } scaleGroups(x, P) { let f = this.chart; f.series.forEach(function (o) { let u = x || o.getPlotBox("series"); o.group && (o.xAxis && o.xAxis.zoomEnabled || f.mapView) && (o.group.attr(u), o.markerGroup && (o.markerGroup.attr(x || o.getPlotBox("marker")), o.markerGroup.clip(P ? f.clipRect : null)), o.dataLabelsGroup && o.dataLabelsGroup.attr(u)) }), f.clipRect.attr(P || f.clipBox) } setDOMEvents() { let x = this.chart.container, P = x.ownerDocument; x.onmousedown = this.onContainerMouseDown.bind(this), x.onmousemove = this.onContainerMouseMove.bind(this), x.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(R(x, "mouseenter", this.onContainerMouseEnter.bind(this))), this.eventsToUnbind.push(R(x, "mouseleave", this.onContainerMouseLeave.bind(this))), F.unbindDocumentMouseUp || (F.unbindDocumentMouseUp = R(P, "mouseup", this.onDocumentMouseUp.bind(this))); let f = this.chart.renderTo.parentElement; for (; f && f.tagName !== "BODY";)this.eventsToUnbind.push(R(f, "scroll", () => { delete this.chartPosition })), f = f.parentElement; s.hasTouch && (this.eventsToUnbind.push(R(x, "touchstart", this.onContainerTouchStart.bind(this), { passive: !1 })), this.eventsToUnbind.push(R(x, "touchmove", this.onContainerTouchMove.bind(this), { passive: !1 })), F.unbindDocumentTouchEnd || (F.unbindDocumentTouchEnd = R(P, "touchend", this.onDocumentTouchEnd.bind(this), { passive: !1 }))) } setHoverChartIndex(x) { let P = this.chart, f = s.charts[G(F.hoverChartIndex, -1)]; f && f !== P && f.pointer.onContainerMouseLeave(x || { relatedTarget: P.container }), f && f.mouseIsDown || (F.hoverChartIndex = P.index) } touch(x, P) { let f, o, u = this.chart; this.setHoverChartIndex(), x.touches.length === 1 ? (x = this.normalize(x), u.isInsidePlot(x.chartX - u.plotLeft, x.chartY - u.plotTop, { visiblePlotOnly: !0 }) && !u.openMenu ? (P && this.runPointActions(x), x.type === "touchmove" && (f = !!(o = this.pinchDown)[0] && Math.sqrt(Math.pow(o[0].chartX - x.chartX, 2) + Math.pow(o[0].chartY - x.chartY, 2)) >= 4), G(f, !0) && this.pinch(x)) : P && this.reset()) : x.touches.length === 2 && this.pinch(x) } touchSelect(x) { return !!(this.chart.zooming.singleTouch && x.touches && x.touches.length === 1) } zoomOption(x) { let P = this.chart, f = (P.options.chart, P.inverted), o = P.zooming.type || "", u, l; /touch/.test(x.type) && (o = G(P.zooming.pinchType, o)), this.zoomX = u = /x/.test(o), this.zoomY = l = /y/.test(o), this.zoomHor = u && !f || l && f, this.zoomVert = l && !f || u && f, this.hasZoom = u || l } } return (j = F || (F = {})).compose = function C(x) { _(se, C) && R(x, "beforeRender", function () { this.pointer = new j(this, this.options) }) }, F }), n(i, "Core/Legend/Legend.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Templating.js"], i["Core/Globals.js"], i["Core/Series/Point.js"], i["Core/Renderer/RendererUtilities.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J) { var se; let { animObject: $, setAnimation: R } = r, { format: Q } = s, { composed: E, marginNames: I } = g, { distribute: W } = D, { addEvent: y, createElement: a, css: v, defined: k, discardElement: w, find: L, fireEvent: G, isNumber: _, merge: N, pick: F, pushUnique: C, relativeLength: x, stableSort: P, syncTimeout: f } = J; class o { constructor(l, h) { this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = l, this.setOptions(h), h.enabled && (this.render(), y(this.chart, "endResize", function () { this.legend.positionCheckboxes() })), y(this.chart, "render", () => { this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems()) }) } setOptions(l) { let h = F(l.padding, 8); this.options = l, this.chart.styledMode || (this.itemStyle = l.itemStyle, this.itemHiddenStyle = N(this.itemStyle, l.itemHiddenStyle)), this.itemMarginTop = l.itemMarginTop, this.itemMarginBottom = l.itemMarginBottom, this.padding = h, this.initialItemY = h - 5, this.symbolWidth = F(l.symbolWidth, 16), this.pages = [], this.proximate = l.layout === "proximate" && !this.chart.inverted, this.baseline = void 0 } update(l, h) { let d = this.chart; this.setOptions(N(!0, this.options, l)), this.destroy(), d.isDirtyLegend = d.isDirtyBox = !0, F(h, !0) && d.redraw(), G(this, "afterUpdate", { redraw: h }) } colorizeItem(l, h) { let { area: d, group: m, label: p, line: T, symbol: U } = l.legendItem || {}; if (m == null || m[h ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) { let { itemHiddenStyle: ee = {} } = this, Z = ee.color, { fillColor: H, fillOpacity: Y, lineColor: S, marker: A } = l.options, B = K => (!h && (K.fill && (K.fill = Z), K.stroke && (K.stroke = Z)), K); p == null || p.css(N(h ? this.itemStyle : ee)), T == null || T.attr(B({ stroke: S || l.color })), U && U.attr(B(A && U.isMarker ? l.pointAttribs() : { fill: l.color })), d == null || d.attr(B({ fill: H || l.color, "fill-opacity": H ? 1 : Y ?? .75 })) } G(this, "afterColorizeItem", { item: l, visible: h }) } positionItems() { this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes() } positionItem(l) { let { group: h, x: d = 0, y: m = 0 } = l.legendItem || {}, p = this.options, T = p.symbolPadding, U = !p.rtl, ee = l.checkbox; if (h && h.element) { let Z = { translateX: U ? d : this.legendWidth - d - 2 * T - 4, translateY: m }; h[k(h.translateY) ? "animate" : "attr"](Z, void 0, () => { G(this, "afterPositionItem", { item: l }) }) } ee && (ee.x = d, ee.y = m) } destroyItem(l) { let h = l.checkbox, d = l.legendItem || {}; for (let m of ["group", "label", "line", "symbol"]) d[m] && (d[m] = d[m].destroy()); h && w(h), l.legendItem = void 0 } destroy() { for (let l of this.getAllItems()) this.destroyItem(l); for (let l of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[l] && (this[l] = this[l].destroy()); this.display = null } positionCheckboxes() { let l, h = this.group && this.group.alignAttr, d = this.clipHeight || this.legendHeight, m = this.titleHeight; h && (l = h.translateY, this.allItems.forEach(function (p) { let T, U = p.checkbox; U && (T = l + m + U.y + (this.scrollOffset || 0) + 3, v(U, { left: h.translateX + p.checkboxOffset + U.x - 20 + "px", top: T + "px", display: this.proximate || T > l - 6 && T < l + d - 6 ? "" : "none" })) }, this)) } renderTitle() { let l = this.options, h = this.padding, d = l.title, m, p = 0; d.text && (this.title || (this.title = this.chart.renderer.label(d.text, h - 3, h - 4, void 0, void 0, void 0, l.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({ width: this.maxLegendWidth + "px" }), p = (m = this.title.getBBox()).height, this.offsetWidth = m.width, this.contentGroup.attr({ translateY: p })), this.titleHeight = p } setText(l) { let h = this.options; l.legendItem.label.attr({ text: h.labelFormat ? Q(h.labelFormat, l, this.chart) : h.labelFormatter.call(l) }) } renderItem(l) { let h = l.legendItem = l.legendItem || {}, d = this.chart, m = d.renderer, p = this.options, T = p.layout === "horizontal", U = this.symbolWidth, ee = p.symbolPadding || 0, Z = this.itemStyle, H = this.itemHiddenStyle, Y = T ? F(p.itemDistance, 20) : 0, S = !p.rtl, A = !l.series, B = !A && l.series.drawLegendSymbol ? l.series : l, K = B.options, c = !!this.createCheckboxForItem && K && K.showCheckbox, M = p.useHTML, b = l.options.className, z = h.label, O = U + ee + Y + (c ? 20 : 0); !z && (h.group = m.g("legend-item").addClass("highcharts-" + B.type + "-series highcharts-color-" + l.colorIndex + (b ? " " + b : "") + (A ? " highcharts-series-" + l.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), h.label = z = m.text("", S ? U + ee : -ee, this.baseline || 0, M), d.styledMode || z.css(N(l.visible ? Z : H)), z.attr({ align: S ? "left" : "right", zIndex: 2 }).add(h.group), !this.baseline && (this.fontMetrics = m.fontMetrics(z), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, z.attr("y", this.baseline), this.symbolHeight = F(p.symbolHeight, this.fontMetrics.f), p.squareSymbol && (this.symbolWidth = F(p.symbolWidth, Math.max(this.symbolHeight, 16)), O = this.symbolWidth + ee + Y + (c ? 20 : 0), S && z.attr("x", this.symbolWidth + ee))), B.drawLegendSymbol(this, l), this.setItemEvents && this.setItemEvents(l, z, M)), c && !l.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(l), this.colorizeItem(l, l.visible), (d.styledMode || !Z.width) && z.css({ width: (p.itemWidth || this.widthOption || d.spacingBox.width) - O + "px" }), this.setText(l); let q = z.getBBox(), ie = this.fontMetrics && this.fontMetrics.h || 0; l.itemWidth = l.checkboxOffset = p.itemWidth || h.labelWidth || q.width + O, this.maxItemWidth = Math.max(this.maxItemWidth, l.itemWidth), this.totalItemWidth += l.itemWidth, this.itemHeight = l.itemHeight = Math.round(h.labelHeight || (q.height > 1.5 * ie ? q.height : ie)) } layoutItem(l) { let h = this.options, d = this.padding, m = h.layout === "horizontal", p = l.itemHeight, T = this.itemMarginBottom, U = this.itemMarginTop, ee = m ? F(h.itemDistance, 20) : 0, Z = this.maxLegendWidth, H = h.alignColumns && this.totalItemWidth > Z ? this.maxItemWidth : l.itemWidth, Y = l.legendItem || {}; m && this.itemX - d + H > Z && (this.itemX = d, this.lastLineHeight && (this.itemY += U + this.lastLineHeight + T), this.lastLineHeight = 0), this.lastItemY = U + this.itemY + T, this.lastLineHeight = Math.max(p, this.lastLineHeight), Y.x = this.itemX, Y.y = this.itemY, m ? this.itemX += H : (this.itemY += U + p + T, this.lastLineHeight = p), this.offsetWidth = this.widthOption || Math.max((m ? this.itemX - d - (l.checkbox ? 0 : ee) : H) + d, this.offsetWidth) } getAllItems() { let l = []; return this.chart.series.forEach(function (h) { let d = h && h.options; h && F(d.showInLegend, !k(d.linkedTo) && void 0, !0) && (l = l.concat((h.legendItem || {}).labels || (d.legendType === "point" ? h.data : h))) }), G(this, "afterGetAllItems", { allItems: l }), l } getAlignment() { let l = this.options; return this.proximate ? l.align.charAt(0) + "tv" : l.floating ? "" : l.align.charAt(0) + l.verticalAlign.charAt(0) + l.layout.charAt(0) } adjustMargins(l, h) { let d = this.chart, m = this.options, p = this.getAlignment(); p && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (T, U) { T.test(p) && !k(l[U]) && (d[I[U]] = Math.max(d[I[U]], d.legend[(U + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][U] * m[U % 2 ? "x" : "y"] + F(m.margin, 12) + h[U] + (d.titleOffset[U] || 0))) }) } proximatePositions() { let l, h = this.chart, d = [], m = this.options.align === "left"; for (let p of (this.allItems.forEach(function (T) { let U, ee, Z = m, H, Y; T.yAxis && (T.xAxis.options.reversed && (Z = !Z), T.points && (U = L(Z ? T.points : T.points.slice(0).reverse(), function (S) { return _(S.plotY) })), ee = this.itemMarginTop + T.legendItem.label.getBBox().height + this.itemMarginBottom, Y = T.yAxis.top - h.plotTop, H = T.visible ? (U ? U.plotY : T.yAxis.height) + (Y - .3 * ee) : Y + T.yAxis.height, d.push({ target: H, size: ee, item: T })) }, this), W(d, h.plotHeight))) l = p.item.legendItem || {}, _(p.pos) && (l.y = h.plotTop - h.spacing[0] + p.pos) } render() { let l = this.chart, h = l.renderer, d = this.options, m = this.padding, p = this.getAllItems(), T, U, ee, Z = this.group, H, Y = this.box; this.itemX = m, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = x(d.width, l.spacingBox.width - m), H = l.spacingBox.width - 2 * m - d.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (H /= 2), this.maxLegendWidth = this.widthOption || H, Z || (this.group = Z = h.g("legend").addClass(d.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = h.g().attr({ zIndex: 1 }).add(Z), this.scrollGroup = h.g().add(this.contentGroup)), this.renderTitle(), P(p, (S, A) => (S.options && S.options.legendIndex || 0) - (A.options && A.options.legendIndex || 0)), d.reversed && p.reverse(), this.allItems = p, this.display = T = !!p.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, p.forEach(this.renderItem, this), p.forEach(this.layoutItem, this), U = (this.widthOption || this.offsetWidth) + m, ee = this.lastItemY + this.lastLineHeight + this.titleHeight, ee = this.handleOverflow(ee) + m, Y || (this.box = Y = h.rect().addClass("highcharts-legend-box").attr({ r: d.borderRadius }).add(Z)), l.styledMode || Y.attr({ stroke: d.borderColor, "stroke-width": d.borderWidth || 0, fill: d.backgroundColor || "none" }).shadow(d.shadow), U > 0 && ee > 0 && Y[Y.placed ? "animate" : "attr"](Y.crisp.call({}, { x: 0, y: 0, width: U, height: ee }, Y.strokeWidth())), Z[T ? "show" : "hide"](), l.styledMode && Z.getStyle("display") === "none" && (U = ee = 0), this.legendWidth = U, this.legendHeight = ee, T && this.align(), this.proximate || this.positionItems(), G(this, "afterRender") } align(l = this.chart.spacingBox) { let h = this.chart, d = this.options, m = l.y; /(lth|ct|rth)/.test(this.getAlignment()) && h.titleOffset[0] > 0 ? m += h.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && h.titleOffset[2] > 0 && (m -= h.titleOffset[2]), m !== l.y && (l = N(l, { y: m })), h.hasRendered || (this.group.placed = !1), this.group.align(N(d, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : d.verticalAlign }), !0, l) } handleOverflow(l) { let h = this, d = this.chart, m = d.renderer, p = this.options, T = p.y, U = p.verticalAlign === "top", ee = this.padding, Z = p.maxHeight, H = p.navigation, Y = F(H.animation, !0), S = H.arrowSize || 12, A = this.pages, B = this.allItems, K = function (re) { typeof re == "number" ? ie.attr({ height: re }) : ie && (h.clipRect = ie.destroy(), h.contentGroup.clip()), h.contentGroup.div && (h.contentGroup.div.style.clip = re ? "rect(" + ee + "px,9999px," + (ee + re) + "px,0)" : "auto") }, c = function (re) { return h[re] = m.circle(0, 0, 1.3 * S).translate(S / 2, S / 2).add(q), d.styledMode || h[re].attr("fill", "rgba(0,0,0,0.0001)"), h[re] }, M, b, z, O = d.spacingBox.height + (U ? -T : T) - ee, q = this.nav, ie = this.clipRect; return p.layout !== "horizontal" || p.verticalAlign === "middle" || p.floating || (O /= 2), Z && (O = Math.min(O, Z)), A.length = 0, l && O > 0 && l > O && H.enabled !== !1 ? (this.clipHeight = M = Math.max(O - 20 - this.titleHeight - ee, 0), this.currentPage = F(this.currentPage, 1), this.fullHeight = l, B.forEach((re, oe) => { z = re.legendItem || {}; let he = z.y || 0, ce = Math.round(z.label.getBBox().height), pe = A.length; (!pe || he - A[pe - 1] > M && (b || he) !== A[pe - 1]) && (A.push(b || he), pe++), z.pageIx = pe - 1, b && ((B[oe - 1].legendItem || {}).pageIx = pe - 1), oe === B.length - 1 && he + ce - A[pe - 1] > M && he > A[pe - 1] && (A.push(he), z.pageIx = pe), he !== b && (b = he) }), ie || (ie = h.clipRect = m.clipRect(0, ee - 2, 9999, 0), h.contentGroup.clip(ie)), K(M), q || (this.nav = q = m.g().attr({ zIndex: 1 }).add(this.group), this.up = m.symbol("triangle", 0, 0, S, S).add(q), c("upTracker").on("click", function () { h.scroll(-1, Y) }), this.pager = m.text("", 15, 10).addClass("highcharts-legend-navigation"), !d.styledMode && H.style && this.pager.css(H.style), this.pager.add(q), this.down = m.symbol("triangle-down", 0, 0, S, S).add(q), c("downTracker").on("click", function () { h.scroll(1, Y) })), h.scroll(0), l = O) : q && (K(), this.nav = q.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0), l } scroll(l, h) { let d = this.chart, m = this.pages, p = m.length, T = this.clipHeight, U = this.options.navigation, ee = this.pager, Z = this.padding, H = this.currentPage + l; if (H > p && (H = p), H > 0) { h !== void 0 && R(h, d), this.nav.attr({ translateX: Z, translateY: T + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function (S) { S.attr({ class: H === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }) }), ee.attr({ text: H + "/" + p }), [this.down, this.downTracker].forEach(function (S) { S.attr({ x: 18 + this.pager.getBBox().width, class: H === p ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }) }, this), d.styledMode || (this.up.attr({ fill: H === 1 ? U.inactiveColor : U.activeColor }), this.upTracker.css({ cursor: H === 1 ? "default" : "pointer" }), this.down.attr({ fill: H === p ? U.inactiveColor : U.activeColor }), this.downTracker.css({ cursor: H === p ? "default" : "pointer" })), this.scrollOffset = -m[H - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = H, this.positionCheckboxes(); let Y = $(F(h, d.renderer.globalAnimation, !0)); f(() => { G(this, "afterScroll", { currentPage: H }) }, Y.duration) } } setItemEvents(l, h, d) { let m = this, p = l.legendItem || {}, T = m.chart.renderer.boxWrapper, U = l instanceof j, ee = "highcharts-legend-" + (U ? "point" : "series") + "-active", Z = m.chart.styledMode, H = d ? [h, p.symbol] : [p.group], Y = S => { m.allItems.forEach(A => { l !== A && [A].concat(A.linkedSeries || []).forEach(B => { B.setState(S, !U) }) }) }; for (let S of H) S && S.on("mouseover", function () { l.visible && Y("inactive"), l.setState("hover"), l.visible && T.addClass(ee), Z || h.css(m.options.itemHoverStyle) }).on("mouseout", function () { m.chart.styledMode || h.css(N(l.visible ? m.itemStyle : m.itemHiddenStyle)), Y(""), T.removeClass(ee), l.setState() }).on("click", function (A) { let B = "legendItemClick", K = function () { l.setVisible && l.setVisible(), Y(l.visible ? "inactive" : "") }; T.removeClass(ee), A = { browserEvent: A }, l.firePointEvent ? l.firePointEvent(B, A, K) : G(l, B, A, K) }) } createCheckboxForItem(l) { l.checkbox = a("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: l.selected, defaultChecked: l.selected }, this.options.itemCheckboxStyle, this.chart.container), y(l.checkbox, "click", function (h) { let d = h.target; G(l.series || l, "checkboxClick", { checked: d.checked, item: l }, function () { l.select() }) }) } } return (se = o || (o = {})).compose = function u(l) { C(E, u) && y(l, "beforeMargins", function () { this.legend = new se(this, this.options.legend) }) }, o }), n(i, "Core/Legend/LegendSymbol.js", [i["Core/Utilities.js"]], function (r) { var s; let { extend: g, merge: j, pick: D } = r; return function (J) { function se($, R, Q) { var P; let E = this.legendItem = this.legendItem || {}, { chart: I, options: W } = this, { baseline: y = 0, symbolWidth: a, symbolHeight: v } = $, k = this.symbol || "circle", w = v / 2, L = I.renderer, G = E.group, _ = y - Math.round(v * (Q ? .4 : .3)), N = {}, F, C = W.marker, x = 0; if (I.styledMode || (N["stroke-width"] = Math.min(W.lineWidth || 0, 24), W.dashStyle ? N.dashstyle = W.dashStyle : W.linecap === "square" || (N["stroke-linecap"] = "round")), E.line = L.path().addClass("highcharts-graph").attr(N).add(G), Q && (E.area = L.path().addClass("highcharts-area").add(G)), N["stroke-linecap"] && (x = Math.min(E.line.strokeWidth(), a) / 2), a) { let f = [["M", x, _], ["L", a - x, _]]; E.line.attr({ d: f }), (P = E.area) == null || P.attr({ d: [...f, ["L", a - x, y], ["L", x, y]] }) } if (C && C.enabled !== !1 && a) { let f = Math.min(D(C.radius, w), w); k.indexOf("url") === 0 && (C = j(C, { width: v, height: v }), f = 0), E.symbol = F = L.symbol(k, a / 2 - f, _ - f, 2 * f, 2 * f, g({ context: "legend" }, C)).addClass("highcharts-point").add(G), F.isMarker = !0 } } J.areaMarker = function ($, R) { se.call(this, $, R, !0) }, J.lineMarker = se, J.rectangle = function ($, R) { let Q = R.legendItem || {}, E = $.options, I = $.symbolHeight, W = E.squareSymbol, y = W ? I : $.symbolWidth; Q.symbol = this.chart.renderer.rect(W ? ($.symbolWidth - I) / 2 : 0, $.baseline - I + 1, y, I, D($.options.symbolRadius, I / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(Q.group) } }(s || (s = {})), s }), n(i, "Core/Series/SeriesDefaults.js", [], function () { return { lineWidth: 2, allowPointSelect: !1, crisp: !0, showCheckbox: !1, animation: { duration: 1e3 }, enableMouseTracking: !0, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: !0 }, hover: { animation: { duration: 150 }, enabled: !0, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: !0, formatter: function () { let { numberFormatter: r } = this.series.chart; return typeof this.y != "number" ? "" : r(this.y, -1) }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: !0, states: { normal: { animation: !0 }, hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: .25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 150 }, opacity: .2 } }, stickyTracking: !0, turboThreshold: 1e3, findNearestPointBy: "x" } }), n(i, "Core/Series/SeriesRegistry.js", [i["Core/Globals.js"], i["Core/Defaults.js"], i["Core/Series/Point.js"], i["Core/Utilities.js"]], function (r, s, g, j) { var D; let { defaultOptions: J } = s, { extendClass: se, merge: $ } = j; return function (R) { function Q(E, I) { let W = J.plotOptions || {}, y = I.defaultOptions, a = I.prototype; a.type = E, a.pointClass || (a.pointClass = g), y && (W[E] = y), R.seriesTypes[E] = I } R.seriesTypes = r.seriesTypes, R.registerSeriesType = Q, R.seriesType = function (E, I, W, y, a) { let v = J.plotOptions || {}; return I = I || "", v[E] = $(v[I], W), Q(E, se(R.seriesTypes[I] || function () { }, y)), R.seriesTypes[E].prototype.type = E, a && (R.seriesTypes[E].prototype.pointClass = se(g, a)), R.seriesTypes[E] } }(D || (D = {})), D }), n(i, "Core/Series/Series.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Defaults.js"], i["Core/Foundation.js"], i["Core/Globals.js"], i["Core/Legend/LegendSymbol.js"], i["Core/Series/Point.js"], i["Core/Series/SeriesDefaults.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Renderer/SVG/SVGElement.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J, se, $, R, Q) { let { animObject: E, setAnimation: I } = r, { defaultOptions: W } = s, { registerEventOptions: y } = g, { hasTouch: a, svg: v, win: k } = j, { seriesTypes: w } = $, { arrayMax: L, arrayMin: G, clamp: _, correctFloat: N, defined: F, destroyObjectProperties: C, diffObjects: x, erase: P, error: f, extend: o, find: u, fireEvent: l, getClosestDistance: h, getNestedProperty: d, insertItem: m, isArray: p, isNumber: T, isString: U, merge: ee, objectEach: Z, pick: H, removeEvent: Y, splat: S, syncTimeout: A } = Q; class B { constructor() { this.zoneAxis = "y" } init(c, M) { let b; l(this, "init", { options: M }); let z = this, O = c.series; this.eventsToUnbind = [], z.chart = c, z.options = z.setOptions(M); let q = z.options, ie = q.visible !== !1; z.linkedSeries = [], z.bindAxes(), o(z, { name: q.name, state: "", visible: ie, selected: q.selected === !0 }), y(this, q); let re = q.events; (re && re.click || q.point && q.point.events && q.point.events.click || q.allowPointSelect) && (c.runTrackerClick = !0), z.getColor(), z.getSymbol(), z.parallelArrays.forEach(function (oe) { z[oe + "Data"] || (z[oe + "Data"] = []) }), z.isCartesian && (c.hasCartesianSeries = !0), O.length && (b = O[O.length - 1]), z._i = H(b && b._i, -1) + 1, z.opacity = z.options.opacity, c.orderItems("series", m(this, O)), q.dataSorting && q.dataSorting.enabled ? z.setDataSortingOptions() : z.points || z.data || z.setData(q.data, !1), l(this, "afterInit") } is(c) { return w[c] && this instanceof w[c] } bindAxes() { let c, M = this, b = M.options, z = M.chart; l(this, "bindAxes", null, function () { (M.axisTypes || []).forEach(function (O) { z[O].forEach(function (q) { c = q.options, (H(b[O], 0) === q.index || b[O] !== void 0 && b[O] === c.id) && (m(M, q.series), M[O] = q, q.isDirty = !0) }), M[O] || M.optionalAxis === O || f(18, !0, z) }) }), l(this, "afterBindAxes") } updateParallelArrays(c, M, b) { let z = c.series, O = T(M) ? function (q) { let ie = q === "y" && z.toYData ? z.toYData(c) : c[q]; z[q + "Data"][M] = ie } : function (q) { Array.prototype[M].apply(z[q + "Data"], b) }; z.parallelArrays.forEach(O) } hasData() { return this.visible && this.dataMax !== void 0 && this.dataMin !== void 0 || this.visible && this.yData && this.yData.length > 0 } hasMarkerChanged(c, M) { let b = c.marker, z = M.marker || {}; return b && (z.enabled && !b.enabled || z.symbol !== b.symbol || z.height !== b.height || z.width !== b.width) } autoIncrement(c) { let M = this.options, b = M.pointIntervalUnit, z = M.relativeXValue, O = this.chart.time, q = this.xIncrement, ie, re; return q = H(q, M.pointStart, 0), this.pointInterval = re = H(this.pointInterval, M.pointInterval, 1), z && T(c) && (re *= c), b && (ie = new O.Date(q), b === "day" ? O.set("Date", ie, O.get("Date", ie) + re) : b === "month" ? O.set("Month", ie, O.get("Month", ie) + re) : b === "year" && O.set("FullYear", ie, O.get("FullYear", ie) + re), re = ie.getTime() - q), z && T(c) ? q + re : (this.xIncrement = q + re, q) } setDataSortingOptions() { let c = this.options; o(this, { requireSorting: !1, sorted: !1, enabledDataSorting: !0, allowDG: !1 }), F(c.pointRange) || (c.pointRange = 1) } setOptions(c) { var ae, le; let M, b = this.chart, z = b.options, O = z.plotOptions, q = b.userOptions || {}, ie = ee(c), re = b.styledMode, oe = { plotOptions: O, userOptions: ie }; l(this, "setOptions", oe); let he = oe.plotOptions[this.type], ce = q.plotOptions || {}, pe = ce.series || {}, V = W.plotOptions[this.type] || {}, X = ce[this.type] || {}; this.userOptions = oe.userOptions; let te = ee(he, O.series, X, ie); this.tooltipOptions = ee(W.tooltip, (ae = W.plotOptions.series) == null ? void 0 : ae.tooltip, V == null ? void 0 : V.tooltip, b.userOptions.tooltip, (le = ce.series) == null ? void 0 : le.tooltip, X.tooltip, ie.tooltip), this.stickyTracking = H(ie.stickyTracking, X.stickyTracking, pe.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || te.stickyTracking), he.marker === null && delete te.marker, this.zoneAxis = te.zoneAxis || "y"; let ne = this.zones = (te.zones || []).slice(); return (te.negativeColor || te.negativeFillColor) && !te.zones && (M = { value: te[this.zoneAxis + "Threshold"] || te.threshold || 0, className: "highcharts-negative" }, re || (M.color = te.negativeColor, M.fillColor = te.negativeFillColor), ne.push(M)), ne.length && F(ne[ne.length - 1].value) && ne.push(re ? {} : { color: this.color, fillColor: this.fillColor }), l(this, "afterSetOptions", { options: te }), te } getName() { return H(this.options.name, "Series " + (this.index + 1)) } getCyclic(c, M, b) { let z, O, q = this.chart, ie = `${c}Index`, re = `${c}Counter`, oe = (b == null ? void 0 : b.length) || q.options.chart.colorCount; !M && (F(O = H(c === "color" ? this.options.colorIndex : void 0, this[ie])) ? z = O : (q.series.length || (q[re] = 0), z = q[re] % oe, q[re] += 1), b && (M = b[z])), z !== void 0 && (this[ie] = z), this[c] = M } getColor() { this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || W.plotOptions[this.type].color, this.chart.options.colors) } getPointsCollection() { return (this.hasGroupedData ? this.points : this.data) || [] } getSymbol() { let c = this.options.marker; this.getCyclic("symbol", c.symbol, this.chart.options.symbols) } findPointIndex(c, M) { let b, z, O, q = c.id, ie = c.x, re = this.points, oe = this.options.dataSorting; if (q) { let he = this.chart.get(q); he instanceof J && (b = he) } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) { let he = ce => !ce.touched && ce.index === c.index; if (oe && oe.matchByName ? he = ce => !ce.touched && ce.name === c.name : this.options.relativeXValue && (he = ce => !ce.touched && ce.options.x === c.x), !(b = u(re, he))) return } return b && (O = b && b.index) !== void 0 && (z = !0), O === void 0 && T(ie) && (O = this.xData.indexOf(ie, M)), O !== -1 && O !== void 0 && this.cropped && (O = O >= this.cropStart ? O - this.cropStart : O), !z && T(O) && re[O] && re[O].touched && (O = void 0), O } updateData(c, M) { let b = this.options, z = b.dataSorting, O = this.points, q = [], ie = this.requireSorting, re = c.length === O.length, oe, he, ce, pe, V = !0; if (this.xIncrement = null, c.forEach(function (X, te) { let ne, ae = F(X) && this.pointClass.prototype.optionsToObject.call({ series: this }, X) || {}, le = ae.x; ae.id || T(le) ? ((ne = this.findPointIndex(ae, pe)) === -1 || ne === void 0 ? q.push(X) : O[ne] && X !== b.data[ne] ? (O[ne].update(X, !1, null, !1), O[ne].touched = !0, ie && (pe = ne + 1)) : O[ne] && (O[ne].touched = !0), (!re || te !== ne || z && z.enabled || this.hasDerivedData) && (oe = !0)) : q.push(X) }, this), oe) for (he = O.length; he--;)(ce = O[he]) && !ce.touched && ce.remove && ce.remove(!1, M); else !re || z && z.enabled ? V = !1 : (c.forEach(function (X, te) { X === O[te].y || O[te].destroyed || O[te].update(X, !1, null, !1) }), q.length = 0); return O.forEach(function (X) { X && (X.touched = !1) }), !!V && (q.forEach(function (X) { this.addPoint(X, !1, null, null, !1) }, this), this.xIncrement === null && this.xData && this.xData.length && (this.xIncrement = L(this.xData), this.autoIncrement()), !0) } setData(c, M = !0, b, z) { var be; let O = this, q = O.points, ie = q && q.length || 0, re = O.options, oe = O.chart, he = re.dataSorting, ce = O.xAxis, pe = re.turboThreshold, V = this.xData, X = this.yData, te = O.pointArrayMap, ne = te && te.length, ae = re.keys, le, de, ue, ge = 0, Se = 1, fe = null, me; oe.options.chart.allowMutatingData || (re.data && delete O.options.data, O.userOptions.data && delete O.userOptions.data, me = ee(!0, c)), c = me || c || []; let ke = c.length; if (he && he.enabled && (c = this.sortData(c)), oe.options.chart.allowMutatingData && z !== !1 && ke && ie && !O.cropped && !O.hasGroupedData && O.visible && !O.boosted && (ue = this.updateData(c, b)), !ue) { if (O.xIncrement = null, O.colorCounter = 0, this.parallelArrays.forEach(function (we) { O[we + "Data"].length = 0 }), pe && ke > pe) if (T(fe = O.getFirstValidPoint(c))) for (le = 0; le < ke; le++)V[le] = this.autoIncrement(), X[le] = c[le]; else if (p(fe)) if (ne) if (fe.length === ne) for (le = 0; le < ke; le++)V[le] = this.autoIncrement(), X[le] = c[le]; else for (le = 0; le < ke; le++)de = c[le], V[le] = de[0], X[le] = de.slice(1, ne + 1); else if (ae && (ge = ae.indexOf("x"), Se = ae.indexOf("y"), ge = ge >= 0 ? ge : 0, Se = Se >= 0 ? Se : 1), fe.length === 1 && (Se = 0), ge === Se) for (le = 0; le < ke; le++)V[le] = this.autoIncrement(), X[le] = c[le][Se]; else for (le = 0; le < ke; le++)de = c[le], V[le] = de[ge], X[le] = de[Se]; else f(12, !1, oe); else for (le = 0; le < ke; le++)de = { series: O }, O.pointClass.prototype.applyOptions.apply(de, [c[le]]), O.updateParallelArrays(de, le); for (X && U(X[0]) && f(14, !0, oe), O.data = [], O.options.data = O.userOptions.data = c, le = ie; le--;)(be = q[le]) == null || be.destroy(); ce && (ce.minRange = ce.userMinRange), O.isDirty = oe.isDirtyBox = !0, O.isDirtyData = !!q, b = !1 } re.legendType === "point" && (this.processData(), this.generatePoints()), M && oe.redraw(b) } sortData(c) { let M = this, b = M.options, z = b.dataSorting, O = z.sortKey || "y", q = function (re, oe) { return F(oe) && re.pointClass.prototype.optionsToObject.call({ series: re }, oe) || {} }; return c.forEach(function (re, oe) { c[oe] = q(M, re), c[oe].index = oe }, this), c.concat().sort((re, oe) => { let he = d(O, re), ce = d(O, oe); return ce < he ? -1 : ce > he ? 1 : 0 }).forEach(function (re, oe) { re.x = oe }, this), M.linkedSeries && M.linkedSeries.forEach(function (re) { let oe = re.options, he = oe.data; oe.dataSorting && oe.dataSorting.enabled || !he || (he.forEach(function (ce, pe) { he[pe] = q(re, ce), c[pe] && (he[pe].x = c[pe].x, he[pe].index = pe) }), re.setData(he, !1)) }), c } getProcessedData(c) { let M = this, b = M.xAxis, z = M.options, O = z.cropThreshold, q = c || M.getExtremesFromAll || z.getExtremesFromAll, ie = b == null ? void 0 : b.logarithmic, re = M.isCartesian, oe, he, ce = 0, pe, V, X, te = M.xData, ne = M.yData, ae = !1, le = te.length; b && (V = (pe = b.getExtremes()).min, X = pe.max, ae = !!(b.categories && !b.names.length)), re && M.sorted && !q && (!O || le > O || M.forceCrop) && (te[le - 1] < V || te[0] > X ? (te = [], ne = []) : M.yData && (te[0] < V || te[le - 1] > X) && (te = (oe = this.cropData(M.xData, M.yData, V, X)).xData, ne = oe.yData, ce = oe.start, he = !0)); let de = h([ie ? te.map(ie.log2lin) : te], () => M.requireSorting && !ae && f(15, !1, M.chart)); return { xData: te, yData: ne, cropped: he, cropStart: ce, closestPointRange: de } } processData(c) { let M = this.xAxis; if (this.isCartesian && !this.isDirty && !M.isDirty && !this.yAxis.isDirty && !c) return !1; let b = this.getProcessedData(); this.cropped = b.cropped, this.cropStart = b.cropStart, this.processedXData = b.xData, this.processedYData = b.yData, this.closestPointRange = this.basePointRange = b.closestPointRange, l(this, "afterProcessData") } cropData(c, M, b, z) { let O = c.length, q, ie, re = 0, oe = O; for (q = 0; q < O; q++)if (c[q] >= b) { re = Math.max(0, q - 1); break } for (ie = q; ie < O; ie++)if (c[ie] > z) { oe = ie + 1; break } return { xData: c.slice(re, oe), yData: M.slice(re, oe), start: re, end: oe } } generatePoints() { let c = this.options, M = this.processedData || c.data, b = this.processedXData, z = this.processedYData, O = this.pointClass, q = b.length, ie = this.cropStart || 0, re = this.hasGroupedData, oe = c.keys, he = [], ce = c.dataGrouping && c.dataGrouping.groupAll ? ie : 0, pe, V, X, te, ne = this.data; if (!ne && !re) { let ae = []; ae.length = M.length, ne = this.data = ae } for (oe && re && (this.options.keys = !1), te = 0; te < q; te++)V = ie + te, re ? ((X = new O(this, [b[te]].concat(S(z[te])))).dataGroup = this.groupMap[ce + te], X.dataGroup.options && (X.options = X.dataGroup.options, o(X, X.dataGroup.options), delete X.dataLabels)) : (X = ne[V]) || M[V] === void 0 || (ne[V] = X = new O(this, M[V], b[te])), X && (X.index = re ? ce + te : V, he[te] = X); if (this.options.keys = oe, ne && (q !== (pe = ne.length) || re)) for (te = 0; te < pe; te++)te !== ie || re || (te += q), ne[te] && (ne[te].destroyElements(), ne[te].plotX = void 0); this.data = ne, this.points = he, l(this, "afterGeneratePoints") } getXExtremes(c) { return { min: G(c), max: L(c) } } getExtremes(c, M) { let b = this.xAxis, z = this.yAxis, O = this.processedXData || this.xData, q = [], ie = this.requireSorting && !this.is("column") ? 1 : 0, re = !!z && z.positiveValuesOnly, oe, he, ce, pe, V, X, te, ne = 0, ae = 0, le = 0; c = c || this.stackedYData || this.processedYData || []; let de = c.length; for (b && (ne = (oe = b.getExtremes()).min, ae = oe.max), X = 0; X < de; X++)if (pe = O[X], he = (T(V = c[X]) || p(V)) && ((T(V) ? V > 0 : V.length) || !re), ce = M || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (O[X + ie] || pe) >= ne && (O[X - ie] || pe) <= ae, he && ce) if (te = V.length) for (; te--;)T(V[te]) && (q[le++] = V[te]); else q[le++] = V; let ue = { activeYData: q, dataMin: G(q), dataMax: L(q) }; return l(this, "afterGetExtremes", { dataExtremes: ue }), ue } applyExtremes() { let c = this.getExtremes(); return this.dataMin = c.dataMin, this.dataMax = c.dataMax, c } getFirstValidPoint(c) { let M = c.length, b = 0, z = null; for (; z === null && b < M;)z = c[b], b++; return z } translate() { var de; this.processedXData || this.processData(), this.generatePoints(); let c = this.options, M = c.stacking, b = this.xAxis, z = b.categories, O = this.enabledDataSorting, q = this.yAxis, ie = this.points, re = ie.length, oe = this.pointPlacementToXValue(), he = !!oe, ce = c.threshold, pe = c.startFromThreshold ? ce : 0, V, X, te, ne, ae = Number.MAX_VALUE; function le(ue) { return _(ue, -1e5, 1e5) } for (V = 0; V < re; V++) { let ue, ge = ie[V], Se = ge.x, fe, me, ke = ge.y, be = ge.low, we = M && ((de = q.stacking) == null ? void 0 : de.stacks[(this.negStacks && ke < (pe ? 0 : ce) ? "-" : "") + this.stackKey]); X = b.translate(Se, !1, !1, !1, !0, oe), ge.plotX = T(X) ? N(le(X)) : void 0, M && this.visible && we && we[Se] && (ne = this.getStackIndicator(ne, Se, this.index), !ge.isNull && ne.key && (me = (fe = we[Se]).points[ne.key]), fe && p(me) && (be = me[0], ke = me[1], be === pe && ne.key === we[Se].base && (be = H(T(ce) ? ce : q.min)), q.positiveValuesOnly && F(be) && be <= 0 && (be = void 0), ge.total = ge.stackTotal = H(fe.total), ge.percentage = F(ge.y) && fe.total ? ge.y / fe.total * 100 : void 0, ge.stackY = ke, this.irregularWidths || fe.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), ge.yBottom = F(be) ? le(q.translate(be, !1, !0, !1, !0)) : void 0, this.dataModify && (ke = this.dataModify.modifyValue(ke, V)), T(ke) && ge.plotX !== void 0 && (ue = T(ue = q.translate(ke, !1, !0, !1, !0)) ? le(ue) : void 0), ge.plotY = ue, ge.isInside = this.isPointInside(ge), ge.clientX = he ? N(b.translate(Se, !1, !1, !1, !0, oe)) : X, ge.negative = (ge.y || 0) < (ce || 0), ge.category = H(z && z[ge.x], ge.x), ge.isNull || ge.visible === !1 || (te !== void 0 && (ae = Math.min(ae, Math.abs(X - te))), te = X), ge.zone = this.zones.length ? ge.getZone() : void 0, !ge.graphic && this.group && O && (ge.isNew = !0) } this.closestPointRangePx = ae, l(this, "afterTranslate") } getValidPoints(c, M, b) { let z = this.chart; return (c || this.points || []).filter(function (O) { let { plotX: q, plotY: ie } = O; return !(!b && (O.isNull || !T(ie))) && (!M || !!z.isInsidePlot(q, ie, { inverted: z.inverted })) && O.visible !== !1 }) } getClipBox() { let { chart: c, xAxis: M, yAxis: b } = this, z = ee(c.clipBox); return M && M.len !== c.plotSizeX && (z.width = M.len), b && b.len !== c.plotSizeY && (z.height = b.len), z } getSharedClipKey() { return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey } setClip() { let { chart: c, group: M, markerGroup: b } = this, z = c.sharedClips, O = c.renderer, q = this.getClipBox(), ie = this.getSharedClipKey(), re = z[ie]; re ? re.animate(q) : z[ie] = re = O.clipRect(q), M && M.clip(this.options.clip === !1 ? void 0 : re), b && b.clip() } animate(c) { let { chart: M, group: b, markerGroup: z } = this, O = M.inverted, q = E(this.options.animation), ie = [this.getSharedClipKey(), q.duration, q.easing, q.defer].join(","), re = M.sharedClips[ie], oe = M.sharedClips[ie + "m"]; if (c && b) { let he = this.getClipBox(); if (re) re.attr("height", he.height); else { he.width = 0, O && (he.x = M.plotHeight), re = M.renderer.clipRect(he), M.sharedClips[ie] = re; let ce = { x: -99, y: -99, width: O ? M.plotWidth + 199 : 99, height: O ? 99 : M.plotHeight + 199 }; oe = M.renderer.clipRect(ce), M.sharedClips[ie + "m"] = oe } b.clip(re), z && z.clip(oe) } else if (re && !re.hasClass("highcharts-animating")) { let he = this.getClipBox(), ce = q.step; z && z.element.childNodes.length && (q.step = function (pe, V) { ce && ce.apply(V, arguments), V.prop === "width" && oe && oe.element && oe.attr(O ? "height" : "width", pe + 99) }), re.addClass("highcharts-animating").animate(he, q) } } afterAnimate() { this.setClip(), Z(this.chart.sharedClips, (c, M, b) => { c && !this.chart.container.querySelector(`[clip-path="url(#${c.id})"]`) && (c.destroy(), delete b[M]) }), this.finishedAnimating = !0, l(this, "afterAnimate") } drawPoints(c = this.points) { let M, b, z, O, q, ie, re, oe = this.chart, he = oe.styledMode, { colorAxis: ce, options: pe } = this, V = pe.marker, X = this[this.specialGroup || "markerGroup"], te = this.xAxis, ne = H(V.enabled, !te || !!te.isRadial || null, this.closestPointRangePx >= V.enabledThreshold * V.radius); if (V.enabled !== !1 || this._hasPointMarkers) for (M = 0; M < c.length; M++)if (O = (z = (b = c[M]).graphic) ? "animate" : "attr", q = b.marker || {}, ie = !!b.marker, (ne && q.enabled === void 0 || q.enabled) && !b.isNull && b.visible !== !1) { let le = H(q.symbol, this.symbol, "rect"); re = this.markerAttribs(b, b.selected && "select"), this.enabledDataSorting && (b.startXPos = te.reversed ? -(re.width || 0) : te.width); let de = b.isInside !== !1; if (!z && de && ((re.width || 0) > 0 || b.hasImage) && (b.graphic = z = oe.renderer.symbol(le, re.x, re.y, re.width, re.height, ie ? q : V).add(X), this.enabledDataSorting && oe.hasRendered && (z.attr({ x: b.startXPos }), O = "animate")), z && O === "animate" && z[de ? "show" : "hide"](de).animate(re), z) { let ue = this.pointAttribs(b, he || !b.selected ? void 0 : "select"); he ? ce && z.css({ fill: ue.fill }) : z[O](ue) } z && z.addClass(b.getClassName(), !0) } else z && (b.graphic = z.destroy()) } markerAttribs(c, M) { let b = this.options, z = b.marker, O = c.marker || {}, q = O.symbol || z.symbol, ie = {}, re, oe, he = H(O.radius, z && z.radius); M && (re = z.states[M], he = H((oe = O.states && O.states[M]) && oe.radius, re && re.radius, he && he + (re && re.radiusPlus || 0))), c.hasImage = q && q.indexOf("url") === 0, c.hasImage && (he = 0); let ce = c.pos(); return T(he) && ce && (ie.x = ce[0] - he, ie.y = ce[1] - he, b.crisp && (ie.x = Math.floor(ie.x))), he && (ie.width = ie.height = 2 * he), ie } pointAttribs(c, M) { let b = this.options.marker, z = c && c.options, O = z && z.marker || {}, q = z && z.color, ie = c && c.color, re = c && c.zone && c.zone.color, oe, he, ce = this.color, pe, V, X = H(O.lineWidth, b.lineWidth), te = 1; return ce = q || re || ie || ce, pe = O.fillColor || b.fillColor || ce, V = O.lineColor || b.lineColor || ce, M = M || "normal", oe = b.states[M] || {}, X = H((he = O.states && O.states[M] || {}).lineWidth, oe.lineWidth, X + H(he.lineWidthPlus, oe.lineWidthPlus, 0)), pe = he.fillColor || oe.fillColor || pe, { stroke: V = he.lineColor || oe.lineColor || V, "stroke-width": X, fill: pe, opacity: te = H(he.opacity, oe.opacity, te) } } destroy(c) { let M, b, z, O = this, q = O.chart, ie = /AppleWebKit\/533/.test(k.navigator.userAgent), re = O.data || []; for (l(O, "destroy", { keepEventsForUpdate: c }), this.removeEvents(c), (O.axisTypes || []).forEach(function (oe) { (z = O[oe]) && z.series && (P(z.series, O), z.isDirty = z.forceRedraw = !0) }), O.legendItem && O.chart.legend.destroyItem(O), M = re.length; M--;)(b = re[M]) && b.destroy && b.destroy(); O.zones.forEach(C), Q.clearTimeout(O.animationTimeout), Z(O, function (oe, he) { oe instanceof R && !oe.survive && oe[ie && he === "group" ? "hide" : "destroy"]() }), q.hoverSeries === O && (q.hoverSeries = void 0), P(q.series, O), q.orderItems("series"), Z(O, function (oe, he) { c && he === "hcEvents" || delete O[he] }) } applyZones() { let { area: c, chart: M, graph: b, zones: z, points: O, xAxis: q, yAxis: ie, zoneAxis: re } = this, { inverted: oe, renderer: he } = M, ce = this[`${re}Axis`], { isXAxis: pe, len: V = 0 } = ce || {}, X = ((b == null ? void 0 : b.strokeWidth()) || 0) / 2 + 1, te = (ne, ae = 0, le = 0) => { oe && (le = V - le); let { translated: de = 0, lineClip: ue } = ne, ge = le - de; ue == null || ue.push(["L", ae, Math.abs(ge) < X ? le - X * (ge <= 0 ? -1 : 1) : de]) }; if (z.length && (b || c) && ce && T(ce.min)) { let ne = ce.getExtremes().max, ae = ue => { ue.forEach((ge, Se) => { (ge[0] === "M" || ge[0] === "L") && (ue[Se] = [ge[0], pe ? V - ge[1] : ge[1], pe ? ge[2] : V - ge[2]]) }) }; if (z.forEach((ue, ge) => { ue.lineClip = [], ue.translated = _(ce.toPixels(H(ue.value, ne), !0) || 0, 0, V) }), b && !this.showLine && b.hide(), c && c.hide(), re === "y" && O.length < q.len) for (let ue of O) { let { plotX: ge, plotY: Se, zone: fe } = ue, me = fe && z[z.indexOf(fe) - 1]; fe && te(fe, ge, Se), me && te(me, ge, Se) } let le = [], de = ce.toPixels(ce.getExtremes().min, !0); z.forEach(ue => { var Ee, je; let ge = ue.lineClip || [], Se = Math.round(ue.translated || 0); q.reversed && ge.reverse(); let { clip: fe, simpleClip: me } = ue, ke = 0, be = 0, we = q.len, ye = ie.len; pe ? (ke = Se, we = de) : (be = Se, ye = de); let Te = [["M", ke, be], ["L", we, be], ["L", we, ye], ["L", ke, ye], ["Z"]], Me = [Te[0], ...ge, Te[1], Te[2], ...le, Te[3], Te[4]]; le = ge.reverse(), de = Se, oe && (ae(Me), c && ae(Te)), fe ? (fe.animate({ d: Me }), me == null || me.animate({ d: Te })) : (fe = ue.clip = he.path(Me), c && (me = ue.simpleClip = he.path(Te))), b && ((Ee = ue.graph) == null || Ee.clip(fe)), c && ((je = ue.area) == null || je.clip(me)) }) } else this.visible && (b && b.show(), c && c.show()) } plotGroup(c, M, b, z, O) { let q = this[c], ie = !q, re = { visibility: b, zIndex: z || .1 }; return F(this.opacity) && !this.chart.styledMode && this.state !== "inactive" && (re.opacity = this.opacity), q || (this[c] = q = this.chart.renderer.g().add(O)), q.addClass("highcharts-" + M + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (F(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (q.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), q.attr(re)[ie ? "attr" : "animate"](this.getPlotBox(M)), q } getPlotBox(c) { let M = this.xAxis, b = this.yAxis, z = this.chart, O = z.inverted && !z.polar && M && this.invertible !== !1 && c === "series"; return z.inverted && (M = b, b = this.xAxis), { translateX: M ? M.left : z.plotLeft, translateY: b ? b.top : z.plotTop, rotation: O ? 90 : 0, rotationOriginX: O ? (M.len - b.len) / 2 : 0, rotationOriginY: O ? (M.len + b.len) / 2 : 0, scaleX: O ? -1 : 1, scaleY: 1 } } removeEvents(c) { let { eventsToUnbind: M } = this; c || Y(this), M.length && (M.forEach(b => { b() }), M.length = 0) } render() { var he, ce, pe, V, X; let c = this, { chart: M, options: b, hasRendered: z } = c, O = E(b.animation), q = c.visible ? "inherit" : "hidden", ie = b.zIndex, re = M.seriesGroup, oe = c.finishedAnimating ? 0 : O.duration; l(this, "render"), c.plotGroup("group", "series", q, ie, re), c.markerGroup = c.plotGroup("markerGroup", "markers", q, ie, re), b.clip !== !1 && c.setClip(), oe && ((he = c.animate) == null || he.call(c, !0)), c.drawGraph && (c.drawGraph(), c.applyZones()), c.visible && c.drawPoints(), (ce = c.drawDataLabels) == null || ce.call(c), (pe = c.redrawPoints) == null || pe.call(c), b.enableMouseTracking && ((V = c.drawTracker) == null || V.call(c)), oe && ((X = c.animate) == null || X.call(c)), z || (oe && O.defer && (oe += O.defer), c.animationTimeout = A(() => { c.afterAnimate() }, oe || 0)), c.isDirty = !1, c.hasRendered = !0, l(c, "afterRender") } redraw() { let c = this.isDirty || this.isDirtyData; this.translate(), this.render(), c && delete this.kdTree } reserveSpace() { return this.visible || !this.chart.options.chart.ignoreHiddenSeries } searchPoint(c, M) { let { xAxis: b, yAxis: z } = this, O = this.chart.inverted; return this.searchKDTree({ clientX: O ? b.len - c.chartY + b.pos : c.chartX - b.pos, plotY: O ? z.len - c.chartX + z.pos : c.chartY - z.pos }, M, c) } buildKDTree(c) { this.buildingKdTree = !0; let M = this, b = M.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1; delete M.kdTree, A(function () { M.kdTree = function z(O, q, ie) { let re, oe, he = O == null ? void 0 : O.length; if (he) return re = M.kdAxisArray[q % ie], O.sort((ce, pe) => (ce[re] || 0) - (pe[re] || 0)), { point: O[oe = Math.floor(he / 2)], left: z(O.slice(0, oe), q + 1, ie), right: z(O.slice(oe + 1), q + 1, ie) } }(M.getValidPoints(void 0, !M.directTouch), b, b), M.buildingKdTree = !1 }, M.options.kdNow || (c == null ? void 0 : c.type) === "touchstart" ? 0 : 1) } searchKDTree(c, M, b) { let z = this, [O, q] = this.kdAxisArray, ie = M ? "distX" : "dist", re = (z.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, oe = !!z.isBubble; if (this.kdTree || this.buildingKdTree || this.buildKDTree(b), this.kdTree) return function he(ce, pe, V, X) { var fe; let te = pe.point, ne = z.kdAxisArray[V % X], ae, le, de = te; (function (me, ke) { var $e; let be = me[O], we = ke[O], ye = F(be) && F(we) ? be - we : null, Te = me[q], Me = ke[q], Ee = F(Te) && F(Me) ? Te - Me : 0, je = oe && (($e = ke.marker) == null ? void 0 : $e.radius) || 0; ke.dist = Math.sqrt((ye && ye * ye || 0) + Ee * Ee) - je, ke.distX = F(ye) ? Math.abs(ye) - je : Number.MAX_VALUE })(ce, te); let ue = (ce[ne] || 0) - (te[ne] || 0) + (oe && ((fe = te.marker) == null ? void 0 : fe.radius) || 0), ge = ue < 0 ? "left" : "right", Se = ue < 0 ? "right" : "left"; return pe[ge] && (de = (ae = he(ce, pe[ge], V + 1, X))[ie] < de[ie] ? ae : te), pe[Se] && Math.sqrt(ue * ue) < de[ie] && (de = (le = he(ce, pe[Se], V + 1, X))[ie] < de[ie] ? le : de), de }(c, this.kdTree, re, re) } pointPlacementToXValue() { let { options: c, xAxis: M } = this, b = c.pointPlacement; return b === "between" && (b = M.reversed ? -.5 : .5), T(b) ? b * (c.pointRange || M.pointRange) : 0 } isPointInside(c) { let { chart: M, xAxis: b, yAxis: z } = this, { plotX: O = -1, plotY: q = -1 } = c; return q >= 0 && q <= (z ? z.len : M.plotHeight) && O >= 0 && O <= (b ? b.len : M.plotWidth) } drawTracker() { var pe; let c = this, M = c.options, b = M.trackByArea, z = [].concat((b ? c.areaPath : c.graphPath) || []), O = c.chart, q = O.pointer, ie = O.renderer, re = ((pe = O.options.tooltip) == null ? void 0 : pe.snap) || 0, oe = () => { M.enableMouseTracking && O.hoverSeries !== c && c.onMouseOver() }, he = "rgba(192,192,192," + (v ? 1e-4 : .002) + ")", ce = c.tracker; ce ? ce.attr({ d: z }) : c.graph && (c.tracker = ce = ie.path(z).attr({ visibility: c.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(b ? "highcharts-tracker-area" : "highcharts-tracker-line").add(c.group), O.styledMode || ce.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: he, fill: b ? he : "none", "stroke-width": c.graph.strokeWidth() + (b ? 0 : 2 * re) }), [c.tracker, c.markerGroup, c.dataLabelsGroup].forEach(V => { V && (V.addClass("highcharts-tracker").on("mouseover", oe).on("mouseout", X => { q.onTrackerMouseOut(X) }), M.cursor && !O.styledMode && V.css({ cursor: M.cursor }), a && V.on("touchstart", oe)) })), l(this, "afterDrawTracker") } addPoint(c, M, b, z, O) { let q, ie, re = this.options, oe = this.data, he = this.chart, ce = this.xAxis, pe = ce && ce.hasNames && ce.names, V = re.data, X = this.xData; M = H(M, !0); let te = { series: this }; this.pointClass.prototype.applyOptions.apply(te, [c]); let ne = te.x; if (ie = X.length, this.requireSorting && ne < X[ie - 1]) for (q = !0; ie && X[ie - 1] > ne;)ie--; this.updateParallelArrays(te, "splice", [ie, 0, 0]), this.updateParallelArrays(te, ie), pe && te.name && (pe[ne] = te.name), V.splice(ie, 0, c), (q || this.processedData) && (this.data.splice(ie, 0, null), this.processData()), re.legendType === "point" && this.generatePoints(), b && (oe[0] && oe[0].remove ? oe[0].remove(!1) : (oe.shift(), this.updateParallelArrays(te, "shift"), V.shift())), O !== !1 && l(this, "addPoint", { point: te }), this.isDirty = !0, this.isDirtyData = !0, M && he.redraw(z) } removePoint(c, M, b) { let z = this, O = z.data, q = O[c], ie = z.points, re = z.chart, oe = function () { ie && ie.length === O.length && ie.splice(c, 1), O.splice(c, 1), z.options.data.splice(c, 1), z.updateParallelArrays(q || { series: z }, "splice", [c, 1]), q && q.destroy(), z.isDirty = !0, z.isDirtyData = !0, M && re.redraw() }; I(b, re), M = H(M, !0), q ? q.firePointEvent("remove", null, oe) : oe() } remove(c, M, b, z) { let O = this, q = O.chart; function ie() { O.destroy(z), q.isDirtyLegend = q.isDirtyBox = !0, q.linkSeries(z), H(c, !0) && q.redraw(M) } b !== !1 ? l(O, "remove", null, ie) : ie() } update(c, M) { var ae, le, de; l(this, "update", { options: c = x(c, this.userOptions) }); let b = this, z = b.chart, O = b.userOptions, q = b.initialType || b.type, ie = z.options.plotOptions, re = w[q].prototype, oe = b.finishedAnimating && { animation: !1 }, he = {}, ce, pe, V = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], X = c.type || O.type || z.options.chart.type, te = !(this.hasDerivedData || X && X !== this.type || c.pointStart !== void 0 || c.pointInterval !== void 0 || c.relativeXValue !== void 0 || c.joinBy || c.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some(ue => b.hasOptionChanged(ue))); X = X || q, te && (V.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), c.visible !== !1 && V.push("area", "graph"), b.parallelArrays.forEach(function (ue) { V.push(ue + "Data") }), c.data && (c.dataSorting && o(b.options.dataSorting, c.dataSorting), this.setData(c.data, !1))), c = ee(O, { index: O.index === void 0 ? b.index : O.index, pointStart: ((ae = ie == null ? void 0 : ie.series) == null ? void 0 : ae.pointStart) ?? O.pointStart ?? ((le = b.xData) == null ? void 0 : le[0]) }, !te && { data: b.options.data }, c, oe), te && c.data && (c.data = b.options.data), (V = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(V)).forEach(function (ue) { V[ue] = b[ue], delete b[ue] }); let ne = !1; if (w[X]) { if (ne = X !== b.type, b.remove(!1, !1, !1, !0), ne) if (Object.setPrototypeOf) Object.setPrototypeOf(b, w[X].prototype); else { let ue = Object.hasOwnProperty.call(b, "hcEvents") && b.hcEvents; for (pe in re) b[pe] = void 0; o(b, w[X].prototype), ue ? b.hcEvents = ue : delete b.hcEvents } } else f(17, !0, z, { missingModuleFor: X }); if (V.forEach(function (ue) { b[ue] = V[ue] }), b.init(z, c), te && this.points) for (let ue of ((ce = b.options).visible === !1 ? (he.graphic = 1, he.dataLabel = 1) : (this.hasMarkerChanged(ce, O) && (he.graphic = 1), (de = b.hasDataLabels) != null && de.call(b) || (he.dataLabel = 1)), this.points)) ue && ue.series && (ue.resolveColor(), Object.keys(he).length && ue.destroyElements(he), ce.showInLegend === !1 && ue.legendItem && z.legend.destroyItem(ue)); b.initialType = q, z.linkSeries(), z.setSortedData(), ne && b.linkedSeries.length && (b.isDirtyData = !0), l(this, "afterUpdate"), H(M, !0) && z.redraw(!!te && void 0) } setName(c) { this.name = this.options.name = this.userOptions.name = c, this.chart.isDirtyLegend = !0 } hasOptionChanged(c) { var ie, re; let M = this.chart, b = this.options[c], z = M.options.plotOptions, O = this.userOptions[c], q = H((ie = z == null ? void 0 : z[this.type]) == null ? void 0 : ie[c], (re = z == null ? void 0 : z.series) == null ? void 0 : re[c]); return O && !F(q) ? b !== O : b !== H(q, b) } onMouseOver() { let c = this.chart, M = c.hoverSeries; c.pointer.setHoverChartIndex(), M && M !== this && M.onMouseOut(), this.options.events.mouseOver && l(this, "mouseOver"), this.setState("hover"), c.hoverSeries = this } onMouseOut() { let c = this.options, M = this.chart, b = M.tooltip, z = M.hoverPoint; M.hoverSeries = null, z && z.onMouseOut(), this && c.events.mouseOut && l(this, "mouseOut"), b && !this.stickyTracking && (!b.shared || this.noSharedTooltip) && b.hide(), M.series.forEach(function (O) { O.setState("", !0) }) } setState(c, M) { let b = this, z = b.options, O = b.graph, q = z.inactiveOtherPoints, ie = z.states, re = H(ie[c || "normal"] && ie[c || "normal"].animation, b.chart.options.chart.animation), oe = z.lineWidth, he = z.opacity; if (c = c || "", b.state !== c && ([b.group, b.markerGroup, b.dataLabelsGroup].forEach(function (ce) { ce && (b.state && ce.removeClass("highcharts-series-" + b.state), c && ce.addClass("highcharts-series-" + c)) }), b.state = c, !b.chart.styledMode)) { if (ie[c] && ie[c].enabled === !1) return; if (c && (oe = ie[c].lineWidth || oe + (ie[c].lineWidthPlus || 0), he = H(ie[c].opacity, he)), O && !O.dashstyle && T(oe)) for (let ce of [O, ...this.zones.map(pe => pe.graph)]) ce == null || ce.animate({ "stroke-width": oe }, re); q || [b.group, b.markerGroup, b.dataLabelsGroup, b.labelBySeries].forEach(function (ce) { ce && ce.animate({ opacity: he }, re) }) } M && q && b.points && b.setAllPointsToState(c || void 0) } setAllPointsToState(c) { this.points.forEach(function (M) { M.setState && M.setState(c) }) } setVisible(c, M) { var re; let b = this, z = b.chart, O = z.options.chart.ignoreHiddenSeries, q = b.visible; b.visible = c = b.options.visible = b.userOptions.visible = c === void 0 ? !q : c; let ie = c ? "show" : "hide";["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(oe => { var he; (he = b[oe]) == null || he[ie]() }), (z.hoverSeries === b || ((re = z.hoverPoint) == null ? void 0 : re.series) === b) && b.onMouseOut(), b.legendItem && z.legend.colorizeItem(b, c), b.isDirty = !0, b.options.stacking && z.series.forEach(oe => { oe.options.stacking && oe.visible && (oe.isDirty = !0) }), b.linkedSeries.forEach(oe => { oe.setVisible(c, !1) }), O && (z.isDirtyBox = !0), l(b, ie), M !== !1 && z.redraw() } show() { this.setVisible(!0) } hide() { this.setVisible(!1) } select(c) { this.selected = c = this.options.selected = c === void 0 ? !this.selected : c, this.checkbox && (this.checkbox.checked = c), l(this, c ? "select" : "unselect") } shouldShowTooltip(c, M, b = {}) { return b.series = this, b.visiblePlotOnly = !0, this.chart.isInsidePlot(c, M, b) } drawLegendSymbol(c, M) { var b; (b = D[this.options.legendSymbol || "rectangle"]) == null || b.call(this, c, M) } } return B.defaultOptions = se, B.types = $.seriesTypes, B.registerType = $.registerSeriesType, o(B.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, directTouch: !1, isCartesian: !0, kdAxisArray: ["clientX", "plotY"], parallelArrays: ["x", "y"], pointClass: J, requireSorting: !0, sorted: !0 }), $.series = B, B }), n(i, "Core/Chart/Chart.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Axis/Axis.js"], i["Core/Defaults.js"], i["Core/Templating.js"], i["Core/Foundation.js"], i["Core/Globals.js"], i["Core/Renderer/RendererRegistry.js"], i["Core/Series/Series.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Renderer/SVG/SVGRenderer.js"], i["Core/Time.js"], i["Core/Utilities.js"], i["Core/Renderer/HTML/AST.js"], i["Core/Axis/Tick.js"]], function (r, s, g, j, D, J, se, $, R, Q, E, I, W, y) { let { animate: a, animObject: v, setAnimation: k } = r, { defaultOptions: w, defaultTime: L } = g, { numberFormat: G } = j, { registerEventOptions: _ } = D, { charts: N, doc: F, marginNames: C, svg: x, win: P } = J, { seriesTypes: f } = R, { addEvent: o, attr: u, createElement: l, clamp: h, css: d, defined: m, diffObjects: p, discardElement: T, erase: U, error: ee, extend: Z, find: H, fireEvent: Y, getStyle: S, isArray: A, isNumber: B, isObject: K, isString: c, merge: M, objectEach: b, pick: z, pInt: O, relativeLength: q, removeEvent: ie, splat: re, syncTimeout: oe, uniqueKey: he } = I; class ce { static chart(V, X, te) { return new ce(V, X, te) } constructor(V, X, te) { this.sharedClips = {}; let ne = [...arguments]; (c(V) || V.nodeName) && (this.renderTo = ne.shift()), this.init(ne[0], ne[1]) } setZoomOptions() { let V = this.options.chart, X = V.zooming; this.zooming = { ...X, type: z(V.zoomType, X.type), key: z(V.zoomKey, X.key), pinchType: z(V.pinchType, X.pinchType), singleTouch: z(V.zoomBySingleTouch, X.singleTouch, !1), resetButton: M(X.resetButton, V.resetZoomButton) } } init(V, X) { Y(this, "init", { args: arguments }, function () { let te = M(w, V), ne = te.chart; this.userOptions = Z({}, V), this.margin = [], this.spacing = [], this.bounds = { h: {}, v: {} }, this.labelCollectors = [], this.callback = X, this.isResizing = 0, this.options = te, this.axes = [], this.series = [], this.time = V.time && Object.keys(V.time).length ? new E(V.time) : J.time, this.numberFormatter = ne.numberFormatter || G, this.styledMode = ne.styledMode, this.hasCartesianSeries = ne.showAxes, this.index = N.length, N.push(this), J.chartCount++, _(this, ne), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), Y(this, "afterInit"), this.firstRender() }) } initSeries(V) { let X = this.options.chart, te = V.type || X.type, ne = f[te]; ne || ee(17, !0, this, { missingModuleFor: te }); let ae = new ne; return typeof ae.init == "function" && ae.init(this, V), ae } setSortedData() { this.getSeriesOrderByLinks().forEach(function (V) { V.points || V.data || !V.enabledDataSorting || V.setData(V.options.data, !1) }) } getSeriesOrderByLinks() { return this.series.concat().sort(function (V, X) { return V.linkedSeries.length || X.linkedSeries.length ? X.linkedSeries.length - V.linkedSeries.length : 0 }) } orderItems(V, X = 0) { let te = this[V], ne = this.options[V] = re(this.options[V]).slice(), ae = this.userOptions[V] = this.userOptions[V] ? re(this.userOptions[V]).slice() : []; if (this.hasRendered && (ne.splice(X), ae.splice(X)), te) for (let le = X, de = te.length; le < de; ++le) { let ue = te[le]; ue && (ue.index = le, ue instanceof $ && (ue.name = ue.getName()), ue.options.isInternal || (ne[le] = ue.options, ae[le] = ue.userOptions)) } } isInsidePlot(V, X, te = {}) { let { inverted: ne, plotBox: ae, plotLeft: le, plotTop: de, scrollablePlotBox: ue } = this, ge = 0, Se = 0; te.visiblePlotOnly && this.scrollingContainer && ({ scrollLeft: ge, scrollTop: Se } = this.scrollingContainer); let fe = te.series, me = te.visiblePlotOnly && ue || ae, ke = te.inverted ? X : V, be = te.inverted ? V : X, we = { x: ke, y: be, isInsidePlot: !0, options: te }; if (!te.ignoreX) { let ye = fe && (ne && !this.polar ? fe.yAxis : fe.xAxis) || { pos: le, len: 1 / 0 }, Te = te.paneCoordinates ? ye.pos + ke : le + ke; Te >= Math.max(ge + le, ye.pos) && Te <= Math.min(ge + le + me.width, ye.pos + ye.len) || (we.isInsidePlot = !1) } if (!te.ignoreY && we.isInsidePlot) { let ye = !ne && te.axis && !te.axis.isXAxis && te.axis || fe && (ne ? fe.xAxis : fe.yAxis) || { pos: de, len: 1 / 0 }, Te = te.paneCoordinates ? ye.pos + be : de + be; Te >= Math.max(Se + de, ye.pos) && Te <= Math.min(Se + de + me.height, ye.pos + ye.len) || (we.isInsidePlot = !1) } return Y(this, "afterIsInsidePlot", we), we.isInsidePlot } redraw(V) { Y(this, "beforeRedraw"); let X = this.hasCartesianSeries ? this.axes : this.colorAxis || [], te = this.series, ne = this.pointer, ae = this.legend, le = this.userOptions.legend, de = this.renderer, ue = de.isHidden(), ge = [], Se, fe, me, ke = this.isDirtyBox, be = this.isDirtyLegend, we; for (de.rootFontSize = de.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), k(!!this.hasRendered && V, this), ue && this.temporaryDisplay(), this.layOutTitles(!1), me = te.length; me--;)if (((we = te[me]).options.stacking || we.options.centerInCategory) && (fe = !0, we.isDirty)) { Se = !0; break } if (Se) for (me = te.length; me--;)(we = te[me]).options.stacking && (we.isDirty = !0); te.forEach(function (ye) { ye.isDirty && (ye.options.legendType === "point" ? (typeof ye.updateTotals == "function" && ye.updateTotals(), be = !0) : le && (le.labelFormatter || le.labelFormat) && (be = !0)), ye.isDirtyData && Y(ye, "updatedData") }), be && ae && ae.options.enabled && (ae.render(), this.isDirtyLegend = !1), fe && this.getStacks(), X.forEach(function (ye) { ye.updateNames(), ye.setScale() }), this.getMargins(), X.forEach(function (ye) { ye.isDirty && (ke = !0) }), X.forEach(function (ye) { let Te = ye.min + "," + ye.max; ye.extKey !== Te && (ye.extKey = Te, ge.push(function () { Y(ye, "afterSetExtremes", Z(ye.eventArgs, ye.getExtremes())), delete ye.eventArgs })), (ke || fe) && ye.redraw() }), ke && this.drawChartBox(), Y(this, "predraw"), te.forEach(function (ye) { (ke || ye.isDirty) && ye.visible && ye.redraw(), ye.isDirtyData = !1 }), ne && ne.reset(!0), de.draw(), Y(this, "redraw"), Y(this, "render"), ue && this.temporaryDisplay(!0), ge.forEach(function (ye) { ye.call() }) } get(V) { let X = this.series; function te(ae) { return ae.id === V || ae.options && ae.options.id === V } let ne = H(this.axes, te) || H(this.series, te); for (let ae = 0; !ne && ae < X.length; ae++)ne = H(X[ae].points || [], te); return ne } getAxes() { let V = this.userOptions; for (let X of (Y(this, "getAxes"), ["xAxis", "yAxis"])) { let te = V[X] = re(V[X] || {}); for (let ne of te) new s(this, ne, X) } Y(this, "afterGetAxes") } getSelectedPoints() { return this.series.reduce((V, X) => (X.getPointsCollection().forEach(te => { z(te.selectedStaging, te.selected) && V.push(te) }), V), []) } getSelectedSeries() { return this.series.filter(function (V) { return V.selected }) } setTitle(V, X, te) { this.applyDescription("title", V), this.applyDescription("subtitle", X), this.applyDescription("caption", void 0), this.layOutTitles(te) } applyDescription(V, X) { let te = this, ne = this.options[V] = M(this.options[V], X), ae = this[V]; ae && X && (this[V] = ae = ae.destroy()), ne && !ae && ((ae = this.renderer.text(ne.text, 0, 0, ne.useHTML).attr({ align: ne.align, class: "highcharts-" + V, zIndex: ne.zIndex || 4 }).add()).update = function (le, de) { te.applyDescription(V, le), te.layOutTitles(de) }, this.styledMode || ae.css(Z(V === "title" ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, ne.style)), this[V] = ae) } layOutTitles(V = !0) { let X = [0, 0, 0], te = this.renderer, ne = this.spacingBox;["title", "subtitle", "caption"].forEach(function (le) { let de = this[le], ue = this.options[le], ge = ue.verticalAlign || "top", Se = le === "title" ? ge === "top" ? -3 : 0 : ge === "top" ? X[0] + 2 : 0; if (de) { de.css({ width: (ue.width || ne.width + (ue.widthAdjust || 0)) + "px" }); let fe = te.fontMetrics(de).b, me = Math.round(de.getBBox(ue.useHTML).height); de.align(Z({ y: ge === "bottom" ? fe : Se + fe, height: me }, ue), !1, "spacingBox"), ue.floating || (ge === "top" ? X[0] = Math.ceil(X[0] + me) : ge === "bottom" && (X[2] = Math.ceil(X[2] + me))) } }, this), X[0] && (this.options.title.verticalAlign || "top") === "top" && (X[0] += this.options.title.margin), X[2] && this.options.caption.verticalAlign === "bottom" && (X[2] += this.options.caption.margin); let ae = !this.titleOffset || this.titleOffset.join(",") !== X.join(","); this.titleOffset = X, Y(this, "afterLayOutTitles"), !this.isDirtyBox && ae && (this.isDirtyBox = this.isDirtyLegend = ae, this.hasRendered && V && this.isDirtyBox && this.redraw()) } getContainerBox() { return { width: S(this.renderTo, "width", !0) || 0, height: S(this.renderTo, "height", !0) || 0 } } getChartSize() { let V = this.options.chart, X = V.width, te = V.height, ne = this.getContainerBox(); this.chartWidth = Math.max(0, X || ne.width || 600), this.chartHeight = Math.max(0, q(te, this.chartWidth) || (ne.height > 1 ? ne.height : 400)), this.containerBox = ne } temporaryDisplay(V) { let X = this.renderTo, te; if (V) for (; X && X.style;)X.hcOrigStyle && (d(X, X.hcOrigStyle), delete X.hcOrigStyle), X.hcOrigDetached && (F.body.removeChild(X), X.hcOrigDetached = !1), X = X.parentNode; else for (; X && X.style && (F.body.contains(X) || X.parentNode || (X.hcOrigDetached = !0, F.body.appendChild(X)), (S(X, "display", !1) === "none" || X.hcOricDetached) && (X.hcOrigStyle = { display: X.style.display, height: X.style.height, overflow: X.style.overflow }, te = { display: "block", overflow: "hidden" }, X !== this.renderTo && (te.height = 0), d(X, te), X.offsetWidth || X.style.setProperty("display", "block", "important")), (X = X.parentNode) !== F.body);); } setClassName(V) { this.container.className = "highcharts-container " + (V || "") } getContainer() { let V = this.options, X = V.chart, te = "data-highcharts-chart", ne = he(), ae, le = this.renderTo; le || (this.renderTo = le = X.renderTo), c(le) && (this.renderTo = le = F.getElementById(le)), le || ee(13, !0, this); let de = O(u(le, te)); B(de) && N[de] && N[de].hasRendered && N[de].destroy(), u(le, te, this.index), le.innerHTML = W.emptyHTML, X.skipClone || le.offsetWidth || this.temporaryDisplay(), this.getChartSize(); let ue = this.chartWidth, ge = this.chartHeight; d(le, { overflow: "hidden" }), this.styledMode || (ae = Z({ position: "relative", overflow: "hidden", width: ue + "px", height: ge + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none" }, X.style || {})); let Se = l("div", { id: ne }, ae, le); this.container = Se, this._cursor = Se.style.cursor; let fe = X.renderer || !x ? se.getRendererType(X.renderer) : Q; if (this.renderer = new fe(Se, ue, ge, void 0, X.forExport, V.exporting && V.exporting.allowHTML, this.styledMode), this.containerBox = this.getContainerBox(), k(void 0, this), this.setClassName(X.className), this.styledMode) for (let me in V.defs) this.renderer.definition(V.defs[me]); else this.renderer.setStyle(X.style); this.renderer.chartIndex = this.index, Y(this, "afterGetContainer") } getMargins(V) { let { spacing: X, margin: te, titleOffset: ne } = this; this.resetMargins(), ne[0] && !m(te[0]) && (this.plotTop = Math.max(this.plotTop, ne[0] + X[0])), ne[2] && !m(te[2]) && (this.marginBottom = Math.max(this.marginBottom, ne[2] + X[2])), this.legend && this.legend.display && this.legend.adjustMargins(te, X), Y(this, "getMargins"), V || this.getAxisMargins() } getAxisMargins() { let V = this, X = V.axisOffset = [0, 0, 0, 0], te = V.colorAxis, ne = V.margin, ae = function (le) { le.forEach(function (de) { de.visible && de.getOffset() }) }; V.hasCartesianSeries ? ae(V.axes) : te && te.length && ae(te), C.forEach(function (le, de) { m(ne[de]) || (V[le] += X[de]) }), V.setChartSize() } getOptions() { return p(this.userOptions, w) } reflow(V) { let X = this, te = X.containerBox, ne = X.getContainerBox(); delete X.pointer.chartPosition, !X.isPrinting && !X.isResizing && te && ne.width && ((ne.width !== te.width || ne.height !== te.height) && (I.clearTimeout(X.reflowTimeout), X.reflowTimeout = oe(function () { X.container && X.setSize(void 0, void 0, !1) }, V ? 100 : 0)), X.containerBox = ne) } setReflow() { let V = this, X = te => { var ne; (ne = V.options) != null && ne.chart.reflow && V.hasLoaded && V.reflow(te) }; if (typeof ResizeObserver == "function") new ResizeObserver(X).observe(V.renderTo); else { let te = o(P, "resize", X); o(this, "destroy", te) } } setSize(V, X, te) { let ne = this, ae = ne.renderer; ne.isResizing += 1, k(te, ne); let le = ae.globalAnimation; ne.oldChartHeight = ne.chartHeight, ne.oldChartWidth = ne.chartWidth, V !== void 0 && (ne.options.chart.width = V), X !== void 0 && (ne.options.chart.height = X), ne.getChartSize(); let { chartWidth: de, chartHeight: ue, scrollablePixelsX: ge = 0, scrollablePixelsY: Se = 0 } = ne; (ne.isDirtyBox || de !== ne.oldChartWidth || ue !== ne.oldChartHeight) && (ne.styledMode || (le ? a : d)(ne.container, { width: `${de + ge}px`, height: `${ue + Se}px` }, le), ne.setChartSize(!0), ae.setSize(de, ue, le), ne.axes.forEach(function (fe) { fe.isDirty = !0, fe.setScale() }), ne.isDirtyLegend = !0, ne.isDirtyBox = !0, ne.layOutTitles(), ne.getMargins(), ne.redraw(le), ne.oldChartHeight = void 0, Y(ne, "resize"), setTimeout(() => { ne && Y(ne, "endResize", void 0, () => { ne.isResizing -= 1 }) }, v(le).duration)) } setChartSize(V) { let X, te, ne, ae, le = this.inverted, de = this.renderer, ue = this.chartWidth, ge = this.chartHeight, Se = this.options.chart, fe = this.spacing, me = this.clipOffset; this.plotLeft = X = Math.round(this.plotLeft), this.plotTop = te = Math.round(this.plotTop), this.plotWidth = ne = Math.max(0, Math.round(ue - X - this.marginRight)), this.plotHeight = ae = Math.max(0, Math.round(ge - te - this.marginBottom)), this.plotSizeX = le ? ae : ne, this.plotSizeY = le ? ne : ae, this.plotBorderWidth = Se.plotBorderWidth || 0, this.spacingBox = de.spacingBox = { x: fe[3], y: fe[0], width: ue - fe[3] - fe[1], height: ge - fe[0] - fe[2] }, this.plotBox = de.plotBox = { x: X, y: te, width: ne, height: ae }; let ke = 2 * Math.floor(this.plotBorderWidth / 2), be = Math.ceil(Math.max(ke, me[3]) / 2), we = Math.ceil(Math.max(ke, me[0]) / 2); this.clipBox = { x: be, y: we, width: Math.floor(this.plotSizeX - Math.max(ke, me[1]) / 2 - be), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(ke, me[2]) / 2 - we)) }, V || (this.axes.forEach(function (ye) { ye.setAxisSize(), ye.setAxisTranslation() }), de.alignElements()), Y(this, "afterSetChartSize", { skipAxes: V }) } resetMargins() { Y(this, "resetMargins"); let V = this, X = V.options.chart;["margin", "spacing"].forEach(function (te) { let ne = X[te], ae = K(ne) ? ne : [ne, ne, ne, ne];["Top", "Right", "Bottom", "Left"].forEach(function (le, de) { V[te][de] = z(X[te + le], ae[de]) }) }), C.forEach(function (te, ne) { V[te] = z(V.margin[ne], V.spacing[ne]) }), V.axisOffset = [0, 0, 0, 0], V.clipOffset = [0, 0, 0, 0] } drawChartBox() { let V = this.options.chart, X = this.renderer, te = this.chartWidth, ne = this.chartHeight, ae = this.styledMode, le = this.plotBGImage, de = V.backgroundColor, ue = V.plotBackgroundColor, ge = V.plotBackgroundImage, Se = this.plotLeft, fe = this.plotTop, me = this.plotWidth, ke = this.plotHeight, be = this.plotBox, we = this.clipRect, ye = this.clipBox, Te = this.chartBackground, Me = this.plotBackground, Ee = this.plotBorder, je, $e, ct, Ue = "animate"; Te || (this.chartBackground = Te = X.rect().addClass("highcharts-background").add(), Ue = "attr"), ae ? je = $e = Te.strokeWidth() : ($e = (je = V.borderWidth || 0) + (V.shadow ? 8 : 0), ct = { fill: de || "none" }, (je || Te["stroke-width"]) && (ct.stroke = V.borderColor, ct["stroke-width"] = je), Te.attr(ct).shadow(V.shadow)), Te[Ue]({ x: $e / 2, y: $e / 2, width: te - $e - je % 2, height: ne - $e - je % 2, r: V.borderRadius }), Ue = "animate", Me || (Ue = "attr", this.plotBackground = Me = X.rect().addClass("highcharts-plot-background").add()), Me[Ue](be), !ae && (Me.attr({ fill: ue || "none" }).shadow(V.plotShadow), ge && (le ? (ge !== le.attr("href") && le.attr("href", ge), le.animate(be)) : this.plotBGImage = X.image(ge, Se, fe, me, ke).add())), we ? we.animate({ width: ye.width, height: ye.height }) : this.clipRect = X.clipRect(ye), Ue = "animate", Ee || (Ue = "attr", this.plotBorder = Ee = X.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add()), ae || Ee.attr({ stroke: V.plotBorderColor, "stroke-width": V.plotBorderWidth || 0, fill: "none" }), Ee[Ue](Ee.crisp({ x: Se, y: fe, width: me, height: ke }, -Ee.strokeWidth())), this.isDirtyBox = !1, Y(this, "afterDrawChartBox") } propFromSeries() { let V, X, te, ne = this, ae = ne.options.chart, le = ne.options.series;["inverted", "angular", "polar"].forEach(function (de) { for (X = f[ae.type], te = ae[de] || X && X.prototype[de], V = le && le.length; !te && V--;)(X = f[le[V].type]) && X.prototype[de] && (te = !0); ne[de] = te }) } linkSeries(V) { let X = this, te = X.series; te.forEach(function (ne) { ne.linkedSeries.length = 0 }), te.forEach(function (ne) { let { linkedTo: ae } = ne.options; if (c(ae)) { let le; (le = ae === ":previous" ? X.series[ne.index - 1] : X.get(ae)) && le.linkedParent !== ne && (le.linkedSeries.push(ne), ne.linkedParent = le, le.enabledDataSorting && ne.setDataSortingOptions(), ne.visible = z(ne.options.visible, le.options.visible, ne.visible)) } }), Y(this, "afterLinkSeries", { isUpdating: V }) } renderSeries() { this.series.forEach(function (V) { V.translate(), V.render() }) } render() { var Se; let V = this.axes, X = this.colorAxis, te = this.renderer, ne = this.options.chart.axisLayoutRuns || 2, ae = fe => { fe.forEach(me => { me.visible && me.render() }) }, le = 0, de = !0, ue, ge = 0; for (let fe of (this.setTitle(), Y(this, "beforeMargins"), (Se = this.getStacks) == null || Se.call(this), this.getMargins(!0), this.setChartSize(), V)) { let { options: me } = fe, { labels: ke } = me; if (fe.horiz && fe.visible && ke.enabled && fe.series.length && fe.coll !== "colorAxis" && !this.polar) { le = me.tickLength, fe.createGroups(); let be = new y(fe, 0, "", !0), we = be.createLabel("x", ke); if (be.destroy(), we && z(ke.reserveSpace, !B(me.crossing)) && (le = we.getBBox().height + ke.distance + Math.max(me.offset || 0, 0)), le) { we == null || we.destroy(); break } } } for (this.plotHeight = Math.max(this.plotHeight - le, 0); (de || ue || ne > 1) && ge < ne;) { let fe = this.plotWidth, me = this.plotHeight; for (let ke of V) ge === 0 ? ke.setScale() : (ke.horiz && de || !ke.horiz && ue) && ke.setTickInterval(!0); ge === 0 ? this.getAxisMargins() : this.getMargins(), de = fe / this.plotWidth > (ge ? 1 : 1.1), ue = me / this.plotHeight > (ge ? 1 : 1.05), ge++ } this.drawChartBox(), this.hasCartesianSeries ? ae(V) : X && X.length && ae(X), this.seriesGroup || (this.seriesGroup = te.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0 } addCredits(V) { let X = this, te = M(!0, this.options.credits, V); te.enabled && !this.credits && (this.credits = this.renderer.text(te.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () { te.href && (P.location.href = te.href) }).attr({ align: te.position.align, zIndex: 8 }), X.styledMode || this.credits.css(te.style), this.credits.add().align(te.position), this.credits.update = function (ne) { X.credits = X.credits.destroy(), X.addCredits(ne) }) } destroy() { let V, X = this, te = X.axes, ne = X.series, ae = X.container, le = ae && ae.parentNode; for (Y(X, "destroy"), X.renderer.forExport ? U(N, X) : N[X.index] = void 0, J.chartCount--, X.renderTo.removeAttribute("data-highcharts-chart"), ie(X), V = te.length; V--;)te[V] = te[V].destroy(); for (this.scroller && this.scroller.destroy && this.scroller.destroy(), V = ne.length; V--;)ne[V] = ne[V].destroy();["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function (de) { let ue = X[de]; ue && ue.destroy && (X[de] = ue.destroy()) }), ae && (ae.innerHTML = W.emptyHTML, ie(ae), le && T(ae)), b(X, function (de, ue) { delete X[ue] }) } firstRender() { let V = this, X = V.options; V.getContainer(), V.resetMargins(), V.setChartSize(), V.propFromSeries(), V.getAxes(); let te = A(X.series) ? X.series : []; X.series = [], te.forEach(function (ne) { V.initSeries(ne) }), V.linkSeries(), V.setSortedData(), Y(V, "beforeRender"), V.render(), V.pointer.getChartPosition(), V.renderer.imgCount || V.hasLoaded || V.onload(), V.temporaryDisplay(!0) } onload() { this.callbacks.concat([this.callback]).forEach(function (V) { V && this.index !== void 0 && V.apply(this, [this]) }, this), Y(this, "load"), Y(this, "render"), m(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0 } warnIfA11yModuleNotLoaded() { let { options: V, title: X } = this; !V || this.accessibility || (this.renderer.boxWrapper.attr({ role: "img", "aria-label": (X && X.element.textContent || "").replace(/</g, "&lt;") }), V.accessibility && V.accessibility.enabled === !1 || ee('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this)) } addSeries(V, X, te) { let ne, ae = this; return V && (X = z(X, !0), Y(ae, "addSeries", { options: V }, function () { ne = ae.initSeries(V), ae.isDirtyLegend = !0, ae.linkSeries(), ne.enabledDataSorting && ne.setData(V.data, !1), Y(ae, "afterAddSeries", { series: ne }), X && ae.redraw(te) })), ne } addAxis(V, X, te, ne) { return this.createAxis(X ? "xAxis" : "yAxis", { axis: V, redraw: te, animation: ne }) } addColorAxis(V, X, te) { return this.createAxis("colorAxis", { axis: V, redraw: X, animation: te }) } createAxis(V, X) { let te = new s(this, X.axis, V); return z(X.redraw, !0) && this.redraw(X.animation), te } showLoading(V) { let X = this, te = X.options, ne = te.loading, ae = function () { le && d(le, { left: X.plotLeft + "px", top: X.plotTop + "px", width: X.plotWidth + "px", height: X.plotHeight + "px" }) }, le = X.loadingDiv, de = X.loadingSpan; le || (X.loadingDiv = le = l("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, X.container)), de || (X.loadingSpan = de = l("span", { className: "highcharts-loading-inner" }, null, le), o(X, "redraw", ae)), le.className = "highcharts-loading", W.setElementHTML(de, z(V, te.lang.loading, "")), X.styledMode || (d(le, Z(ne.style, { zIndex: 10 })), d(de, ne.labelStyle), X.loadingShown || (d(le, { opacity: 0, display: "" }), a(le, { opacity: ne.style.opacity || .5 }, { duration: ne.showDuration || 0 }))), X.loadingShown = !0, ae() } hideLoading() { let V = this.options, X = this.loadingDiv; X && (X.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || a(X, { opacity: 0 }, { duration: V.loading.hideDuration || 100, complete: function () { d(X, { display: "none" }) } })), this.loadingShown = !1 } update(V, X, te, ne) { let ae, le, de, ue = this, ge = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }, Se = V.isResponsiveOptions, fe = []; Y(ue, "update", { options: V }), Se || ue.setResponsive(!1, !0), V = p(V, ue.options), ue.userOptions = M(ue.userOptions, V); let me = V.chart; me && (M(!0, ue.options.chart, me), this.setZoomOptions(), "className" in me && ue.setClassName(me.className), ("inverted" in me || "polar" in me || "type" in me) && (ue.propFromSeries(), ae = !0), "alignTicks" in me && (ae = !0), "events" in me && _(this, me), b(me, function (we, ye) { ue.propsRequireUpdateSeries.indexOf("chart." + ye) !== -1 && (le = !0), ue.propsRequireDirtyBox.indexOf(ye) !== -1 && (ue.isDirtyBox = !0), ue.propsRequireReflow.indexOf(ye) === -1 || (ue.isDirtyBox = !0, Se || (de = !0)) }), !ue.styledMode && me.style && ue.renderer.setStyle(ue.options.chart.style || {})), !ue.styledMode && V.colors && (this.options.colors = V.colors), V.time && (this.time === L && (this.time = new E(V.time)), M(!0, ue.options.time, V.time)), b(V, function (we, ye) { ue[ye] && typeof ue[ye].update == "function" ? ue[ye].update(we, !1) : typeof ue[ge[ye]] == "function" ? ue[ge[ye]](we) : ye !== "colors" && ue.collectionsWithUpdate.indexOf(ye) === -1 && M(!0, ue.options[ye], V[ye]), ye !== "chart" && ue.propsRequireUpdateSeries.indexOf(ye) !== -1 && (le = !0) }), this.collectionsWithUpdate.forEach(function (we) { V[we] && (re(V[we]).forEach(function (ye, Te) { let Me, Ee = m(ye.id); Ee && (Me = ue.get(ye.id)), !Me && ue[we] && (Me = ue[we][z(ye.index, Te)]) && (Ee && m(Me.options.id) || Me.options.isInternal) && (Me = void 0), Me && Me.coll === we && (Me.update(ye, !1), te && (Me.touched = !0)), !Me && te && ue.collectionsWithInit[we] && (ue.collectionsWithInit[we][0].apply(ue, [ye].concat(ue.collectionsWithInit[we][1] || []).concat([!1])).touched = !0) }), te && ue[we].forEach(function (ye) { ye.touched || ye.options.isInternal ? delete ye.touched : fe.push(ye) })) }), fe.forEach(function (we) { we.chart && we.remove && we.remove(!1) }), ae && ue.axes.forEach(function (we) { we.update({}, !1) }), le && ue.getSeriesOrderByLinks().forEach(function (we) { we.chart && we.update({}, !1) }, this); let ke = me && me.width, be = me && (c(me.height) ? q(me.height, ke || ue.chartWidth) : me.height); de || B(ke) && ke !== ue.chartWidth || B(be) && be !== ue.chartHeight ? ue.setSize(ke, be, ne) : z(X, !0) && ue.redraw(ne), Y(ue, "afterUpdate", { options: V, redraw: X, animation: ne }) } setSubtitle(V, X) { this.applyDescription("subtitle", V), this.layOutTitles(X) } setCaption(V, X) { this.applyDescription("caption", V), this.layOutTitles(X) } showResetZoom() { let V = this, X = w.lang, te = V.zooming.resetButton, ne = te.theme, ae = te.relativeTo === "chart" || te.relativeTo === "spacingBox" ? null : "scrollablePlotBox"; function le() { V.zoomOut() } Y(this, "beforeShowResetZoom", null, function () { V.resetZoomButton = V.renderer.button(X.resetZoom, null, null, le, ne).attr({ align: te.position.align, title: X.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(te.position, !1, ae) }), Y(this, "afterShowResetZoom") } zoomOut() { Y(this, "selection", { resetSelection: !0 }, this.zoom) } zoom(V) { let X = this, te = X.pointer, ne = !1, ae; !V || V.resetSelection ? (X.axes.forEach(function (de) { ae = de.zoom() }), te.initiated = !1) : V.xAxis.concat(V.yAxis).forEach(function (de) { let ue = de.axis, ge = ue.isXAxis, { hasPinched: Se, mouseDownX: fe, mouseDownY: me } = te; (te[ge ? "zoomX" : "zoomY"] && m(fe) && m(me) && X.isInsidePlot(fe - X.plotLeft, me - X.plotTop, { axis: ue, ignoreX: Se, ignoreY: Se }) || !m(X.inverted ? fe : me)) && (ae = ue.zoom(de.min, de.max), ue.displayBtn && (ne = !0)) }); let le = X.resetZoomButton; ne && !le ? X.showResetZoom() : !ne && K(le) && (X.resetZoomButton = le.destroy()), ae && X.redraw(z(X.options.chart.animation, V && V.animation, X.pointCount < 100)) } pan(V, X) { let te, ne = this, ae = ne.hoverPoints, le = typeof X == "object" ? X : { enabled: X, type: "x" }, de = ne.options.chart; de && de.panning && (de.panning = le); let ue = le.type; Y(this, "pan", { originalEvent: V }, function () { ae && ae.forEach(function (fe) { fe.setState() }); let ge = ne.xAxis; ue === "xy" ? ge = ge.concat(ne.yAxis) : ue === "y" && (ge = ne.yAxis); let Se = {}; ge.forEach(function (fe) { if (!fe.options.panningEnabled || fe.options.isInternal) return; let me = fe.horiz, ke = V[me ? "chartX" : "chartY"], be = me ? "mouseDownX" : "mouseDownY", we = ne[be], ye = fe.minPointOffset || 0, Te = fe.reversed && !ne.inverted || !fe.reversed && ne.inverted ? -1 : 1, Me = fe.getExtremes(), Ee = fe.toValue(we - ke, !0) + ye * Te, je = fe.toValue(we + fe.len - ke, !0) - (ye * Te || fe.isXAxis && fe.pointRangePadding || 0), $e = je < Ee, ct = fe.hasVerticalPanning(), Ue = $e ? je : Ee, jt = $e ? Ee : je, dt = fe.panningState, Kn; ct && !fe.isXAxis && (!dt || dt.isDirty) && fe.series.forEach(function (qn) { let gc = qn.getProcessedData(!0), Jn = qn.getExtremes(gc.yData, !0); dt || (dt = { startMin: Number.MAX_VALUE, startMax: -Number.MAX_VALUE }), B(Jn.dataMin) && B(Jn.dataMax) && (dt.startMin = Math.min(z(qn.options.threshold, 1 / 0), Jn.dataMin, dt.startMin), dt.startMax = Math.max(z(qn.options.threshold, -1 / 0), Jn.dataMax, dt.startMax)) }); let Zn = Math.min(z(dt && dt.startMin, Me.dataMin), ye ? Me.min : fe.toValue(fe.toPixels(Me.min) - fe.minPixelPadding)), Qn = Math.max(z(dt && dt.startMax, Me.dataMax), ye ? Me.max : fe.toValue(fe.toPixels(Me.max) + fe.minPixelPadding)); fe.panningState = dt, fe.isOrdinal || ((Kn = Zn - Ue) > 0 && (jt += Kn, Ue = Zn), (Kn = jt - Qn) > 0 && (jt = Qn, Ue -= Kn), fe.series.length && Ue !== Me.min && jt !== Me.max && Ue >= Zn && jt <= Qn && (fe.setExtremes(Ue, jt, !1, !1, { trigger: "pan" }), !ne.resetZoomButton && Ue !== Zn && jt !== Qn && ue.match("y") && (ne.showResetZoom(), fe.displayBtn = !1), te = !0), Se[be] = ke) }), b(Se, (fe, me) => { ne[me] = fe }), te && ne.redraw(!1), d(ne.container, { cursor: "move" }) }) } } return Z(ce.prototype, { callbacks: [], collectionsWithInit: { xAxis: [ce.prototype.addAxis, [!0]], yAxis: [ce.prototype.addAxis, [!1]], series: [ce.prototype.addSeries] }, collectionsWithUpdate: ["xAxis", "yAxis", "series"], propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"], propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"], propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"] }), ce }), n(i, "Extensions/ScrollablePlotArea.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Globals.js"], i["Core/Renderer/RendererRegistry.js"], i["Core/Utilities.js"]], function (r, s, g, j) { let { stop: D } = r, { composed: J } = s, { addEvent: se, createElement: $, css: R, defined: Q, extend: E, merge: I, pick: W, pushUnique: y } = j; function a() { var O, q, ie; let N, { axisOffset: F, chartWidth: C, chartHeight: x, container: P, plotHeight: f, plotLeft: o, plotTop: u, plotWidth: l, scrollablePixelsX: h = 0, scrollablePixelsY: d = 0, scrollingContainer: m } = this, p = !this.fixedDiv, T = this.options.chart, U = T.scrollablePlotArea, { scrollPositionX: ee, scrollPositionY: Z } = U, H = g.getRendererType(), { fixedRenderer: Y } = this; Y ? Y.setSize(C, x) : (this.fixedDiv = $("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (((O = T.style) == null ? void 0 : O.zIndex) || 0) + 2, top: 0 }, void 0, !0), m == null || m.parentNode.insertBefore(this.fixedDiv, m), R(this.renderTo, { overflow: "visible" }), this.fixedRenderer = Y = new H(this.fixedDiv, C, x, T.style), this.scrollableMask = Y.path().attr({ fill: T.backgroundColor || "#fff", "fill-opacity": W(U.opacity, .85), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), se(this, "afterShowResetZoom", this.moveFixedElements), se(this, "afterApplyDrilldown", this.moveFixedElements), se(this, "afterLayOutTitles", this.moveFixedElements)), (this.scrollableDirty || p) && (this.scrollableDirty = !1, this.moveFixedElements()); let S = C + h, A = x + d; D(this.container), R(P, { width: `${S}px`, height: `${A}px` }), this.renderer.boxWrapper.attr({ width: S, height: A, viewBox: [0, 0, S, A].join(" ") }), (q = this.chartBackground) == null || q.attr({ width: S, height: A }), m && (R(m, { width: `${this.chartWidth}px`, height: `${this.chartHeight}px` }), p && (ee && (m.scrollLeft = h * ee), Z && (m.scrollTop = d * Z))); let B = u - F[0] - 1, K = o - F[3] - 1, c = u + f + F[2] + 1, M = o + l + F[1] + 1, b = o + l - h, z = u + f - d; N = h ? [["M", 0, B], ["L", o - 1, B], ["L", o - 1, c], ["L", 0, c], ["Z"], ["M", b, B], ["L", C, B], ["L", C, c], ["L", b, c], ["Z"]] : d ? [["M", K, 0], ["L", K, u - 1], ["L", M, u - 1], ["L", M, 0], ["Z"], ["M", K, z], ["L", K, x], ["L", M, x], ["L", M, z], ["Z"]] : [["M", 0, 0]], this.redrawTrigger !== "adjustHeight" && ((ie = this.scrollableMask) == null || ie.attr({ d: N })) } function v() { let N, F = this.container, C = this.fixedRenderer, x = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-reset-zoom", ".highcharts-drillup-button", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"]; for (let P of (this.scrollablePixelsX && !this.inverted ? N = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted || this.scrollablePixelsY && !this.inverted ? N = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (N = ".highcharts-yaxis"), N && x.push(`${N}:not(.highcharts-radial-axis)`, `${N}-labels:not(.highcharts-radial-axis-labels)`), x)) [].forEach.call(F.querySelectorAll(P), f => { (f.namespaceURI === C.SVG_NS ? C.box : C.box.parentNode).appendChild(f), f.style.pointerEvents = "auto" }) } function k() { let N, F = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" }; this.scrollablePixelsX && (F.overflowX = "auto"), this.scrollablePixelsY && (F.overflowY = "auto"), this.scrollingParent = $("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, this.renderTo), this.scrollingContainer = $("div", { className: "highcharts-scrolling" }, F, this.scrollingParent), se(this.scrollingContainer, "scroll", () => { this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (N = this.hoverPoint), this.pointer.runPointActions(void 0, N, !0)) }), this.innerContainer = $("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null } function w() { this.chart.scrollableDirty = !0 } function L(N) { let F, C, x, P = this.options.chart.scrollablePlotArea, f = P && P.minWidth, o = P && P.minHeight; if (!this.renderer.forExport && (f ? (this.scrollablePixelsX = F = Math.max(0, f - this.chartWidth), F && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = I(this.plotBox), this.plotBox.width = this.plotWidth += F, this.inverted ? this.clipBox.height += F : this.clipBox.width += F, x = { 1: { name: "right", value: F } })) : o && (this.scrollablePixelsY = C = Math.max(0, o - this.chartHeight), Q(C) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = I(this.plotBox), this.plotBox.height = this.plotHeight += C, this.inverted ? this.clipBox.width += C : this.clipBox.height += C, x = { 2: { name: "bottom", value: C } })), x && !N.skipAxes)) for (let u of this.axes) if (x[u.side]) { let l = u.getPlotLinePath; u.getPlotLinePath = function () { let h = x[u.side].name, d = x[u.side].value, m = this[h]; this[h] = m - d; let p = l.apply(this, arguments); return this[h] = m, p } } else u.setAxisSize(), u.setAxisTranslation() } function G() { this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed() } function _() { this.chart.scrollableDirty = !0 } return { compose: function N(F, C, x) { y(J, N) && (se(F, "afterInit", w), E(C.prototype, { applyFixed: a, moveFixedElements: v, setUpScrolling: k }), se(C, "afterSetChartSize", L), se(C, "render", G), se(x, "show", _)) } } }), n(i, "Core/Axis/Stacking/StackItem.js", [i["Core/Templating.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g) { let { format: j } = r, { series: D } = s, { destroyObjectProperties: J, fireEvent: se, isNumber: $, pick: R } = g; return class { constructor(Q, E, I, W, y) { let a = Q.chart.inverted, v = Q.reversed; this.axis = Q; let k = this.isNegative = !!I != !!v; this.options = E = E || {}, this.x = W, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = y, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = { align: E.align || (a ? k ? "left" : "right" : "center"), verticalAlign: E.verticalAlign || (a ? "middle" : k ? "bottom" : "top"), y: E.y, x: E.x }, this.textAlign = E.textAlign || (a ? k ? "right" : "left" : "center") } destroy() { J(this, this.axis) } render(Q) { let E = this.axis.chart, I = this.options, W = I.format, y = W ? j(W, this, E) : I.formatter.call(this); if (this.label) this.label.attr({ text: y, visibility: "hidden" }); else { this.label = E.renderer.label(y, null, void 0, I.shape, void 0, void 0, I.useHTML, !1, "stack-labels"); let a = { r: I.borderRadius || 0, text: y, padding: R(I.padding, 5), visibility: "hidden" }; E.styledMode || (a.fill = I.backgroundColor, a.stroke = I.borderColor, a["stroke-width"] = I.borderWidth, this.label.css(I.style || {})), this.label.attr(a), this.label.added || this.label.add(Q) } this.label.labelrank = E.plotSizeY, se(this, "afterRender") } setOffset(Q, E, I, W, y, a) { let { alignOptions: v, axis: k, label: w, options: L, textAlign: G } = this, _ = k.chart, N = this.getStackBox({ xOffset: Q, width: E, boxBottom: I, boxTop: W, defaultX: y, xAxis: a }), { verticalAlign: F } = v; if (w && N) { let C = w.getBBox(), x = w.padding, P = R(L.overflow, "justify") === "justify", f; v.x = L.x || 0, v.y = L.y || 0; let { x: o, y: u } = this.adjustStackPosition({ labelBox: C, verticalAlign: F, textAlign: G }); N.x -= o, N.y -= u, w.align(v, !1, N), (f = _.isInsidePlot(w.alignAttr.x + v.x + o, w.alignAttr.y + v.y + u)) || (P = !1), P && D.prototype.justifyDataLabel.call(k, w, v, w.alignAttr, C, N), w.attr({ x: w.alignAttr.x, y: w.alignAttr.y, rotation: L.rotation, rotationOriginX: C.width / 2, rotationOriginY: C.height / 2 }), R(!P && L.crop, !0) && (f = $(w.x) && $(w.y) && _.isInsidePlot(w.x - x + (w.width || 0), w.y) && _.isInsidePlot(w.x + x, w.y)), w[f ? "show" : "hide"]() } se(this, "afterSetOffset", { xOffset: Q, width: E }) } adjustStackPosition({ labelBox: Q, verticalAlign: E, textAlign: I }) { let W = { bottom: 0, middle: 1, top: 2, right: 1, center: 0, left: -1 }, y = W[E], a = W[I]; return { x: Q.width / 2 + Q.width / 2 * a, y: Q.height / 2 * y } } getStackBox(Q) { let E = this.axis, I = E.chart, { boxTop: W, defaultX: y, xOffset: a, width: v, boxBottom: k } = Q, w = E.stacking.usePercentage ? 100 : R(W, this.total, 0), L = E.toPixels(w), G = Q.xAxis || I.xAxis[0], _ = R(y, G.translate(this.x)) + a, N = E.toPixels(k || $(E.min) && E.logarithmic && E.logarithmic.lin2log(E.min) || 0), F = Math.abs(L - N), C = I.inverted, x = this.isNegative; return C ? { x: (x ? L : L - F) - I.plotLeft, y: G.height - _ - v, width: F, height: v } : { x: _ + G.transB - I.plotLeft, y: (x ? L - F : L) - I.plotTop, width: v, height: F } } } }), n(i, "Core/Axis/Stacking/StackingAxis.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Axis/Axis.js"], i["Core/Globals.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Axis/Stacking/StackItem.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J) { var se; let { getDeferredAnimation: $ } = r, { composed: R } = g, { series: { prototype: Q } } = j, { addEvent: E, correctFloat: I, defined: W, destroyObjectProperties: y, fireEvent: a, isArray: v, isNumber: k, objectEach: w, pick: L, pushUnique: G } = J; function _() { let l = this.inverted; this.axes.forEach(h => { h.stacking && h.stacking.stacks && h.hasVisibleSeries && (h.stacking.oldStacks = h.stacking.stacks) }), this.series.forEach(h => { let d = h.xAxis && h.xAxis.options || {}; h.options.stacking && h.reserveSpace() && (h.stackKey = [h.type, L(h.options.stack, ""), l ? d.top : d.left, l ? d.height : d.width].join(",")) }) } function N() { var h; let l = this.stacking; if (l) { let d = l.stacks; w(d, (m, p) => { y(m), delete d[p] }), (h = l.stackTotalGroup) == null || h.destroy() } } function F() { this.stacking || (this.stacking = new u(this)) } function C(l, h, d, m) { return !W(l) || l.x !== h || m && l.stackKey !== m ? l = { x: h, index: 0, key: m, stackKey: m } : l.index++, l.key = [d, h, l.index].join(","), l } function x() { let l, h = this, d = h.yAxis, m = h.stackKey || "", p = d.stacking.stacks, T = h.processedXData, U = h.options.stacking, ee = h[U + "Stacker"]; ee && [m, "-" + m].forEach(Z => { var B; let H = T.length, Y, S, A; for (; H--;)Y = T[H], l = h.getStackIndicator(l, Y, h.index, Z), S = (B = p[Z]) == null ? void 0 : B[Y], (A = S == null ? void 0 : S.points[l.key || ""]) && ee.call(h, A, S, H) }) } function P(l, h, d) { let m = h.total ? 100 / h.total : 0; l[0] = I(l[0] * m), l[1] = I(l[1] * m), this.stackedYData[d] = l[1] } function f(l) { (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? Q.setStackedPoints.call(this, l, "group") : l.stacking.resetStacks()) } function o(l, h) { var pe, V; let d, m, p, T, U, ee, Z, H, Y, S = h || this.options.stacking; if (!S || !this.reserveSpace() || ({ group: "xAxis" }[S] || "yAxis") !== l.coll) return; let A = this.processedXData, B = this.processedYData, K = [], c = B.length, M = this.options, b = M.threshold || 0, z = M.startFromThreshold ? b : 0, O = M.stack, q = h ? `${this.type},${S}` : this.stackKey || "", ie = "-" + q, re = this.negStacks, oe = l.stacking, he = oe.stacks, ce = oe.oldStacks; for (oe.stacksTouched += 1, Z = 0; Z < c; Z++) { H = A[Z], Y = B[Z], ee = (d = this.getStackIndicator(d, H, this.index)).key || "", he[U = (m = re && Y < (z ? 0 : b)) ? ie : q] || (he[U] = {}), he[U][H] || ((pe = ce[U]) != null && pe[H] ? (he[U][H] = ce[U][H], he[U][H].total = null) : he[U][H] = new D(l, l.options.stackLabels, !!m, H, O)), p = he[U][H], Y !== null ? (p.points[ee] = p.points[this.index] = [L(p.cumulative, z)], W(p.cumulative) || (p.base = ee), p.touched = oe.stacksTouched, d.index > 0 && this.singleStacks === !1 && (p.points[ee][0] = p.points[this.index + "," + H + ",0"][0])) : (delete p.points[ee], delete p.points[this.index]); let X = p.total || 0; S === "percent" ? (T = m ? q : ie, X = re && ((V = he[T]) != null && V[H]) ? (T = he[T][H]).total = Math.max(T.total || 0, X) + Math.abs(Y) || 0 : I(X + (Math.abs(Y) || 0))) : S === "group" ? (v(Y) && (Y = Y[0]), Y !== null && X++) : X = I(X + (Y || 0)), S === "group" ? p.cumulative = (X || 1) - 1 : p.cumulative = I(L(p.cumulative, z) + (Y || 0)), p.total = X, Y !== null && (p.points[ee].push(p.cumulative), K[Z] = p.cumulative, p.hasValidPoints = !0) } S === "percent" && (oe.usePercentage = !0), S !== "group" && (this.stackedYData = K), oe.oldStacks = {} } class u { constructor(h) { this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = h } buildStacks() { let h, d, m = this.axis, p = m.series, T = m.coll === "xAxis", U = m.options.reversedStacks, ee = p.length; for (this.resetStacks(), this.usePercentage = !1, d = ee; d--;)h = p[U ? d : ee - d - 1], T && h.setGroupedPoints(m), h.setStackedPoints(m); if (!T) for (d = 0; d < ee; d++)p[d].modifyStacks(); a(m, "afterBuildStacks") } cleanStacks() { this.oldStacks && (this.stacks = this.oldStacks, w(this.stacks, h => { w(h, d => { d.cumulative = d.total }) })) } resetStacks() { w(this.stacks, h => { w(h, (d, m) => { k(d.touched) && d.touched < this.stacksTouched ? (d.destroy(), delete h[m]) : (d.total = null, d.cumulative = null) }) }) } renderStackTotals() { var Z; let h = this.axis, d = h.chart, m = d.renderer, p = this.stacks, T = (Z = h.options.stackLabels) == null ? void 0 : Z.animation, U = $(d, T || !1), ee = this.stackTotalGroup = this.stackTotalGroup || m.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add(); ee.translate(d.plotLeft, d.plotTop), w(p, H => { w(H, Y => { Y.render(ee) }) }), ee.animate({ opacity: 1 }, U) } } return (se || (se = {})).compose = function l(h, d, m) { if (G(R, l)) { let p = d.prototype, T = m.prototype; E(h, "init", F), E(h, "destroy", N), p.getStacks = _, T.getStackIndicator = C, T.modifyStacks = x, T.percentStacker = P, T.setGroupedPoints = f, T.setStackedPoints = o } }, se }), n(i, "Series/Line/LineSeries.js", [i["Core/Series/Series.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g) { let { defined: j, merge: D, isObject: J } = g; class se extends r { drawGraph() { let R = this.options, Q = (this.gappedPath || this.getGraphPath).call(this), E = this.chart.styledMode;[this, ...this.zones].forEach((I, W) => { let y, a = I.graph, v = a ? "animate" : "attr", k = I.dashStyle || R.dashStyle; a ? (a.endX = this.preventGraphAnimation ? null : Q.xMap, a.animate({ d: Q })) : Q.length && (I.graph = a = this.chart.renderer.path(Q).addClass("highcharts-graph" + (W ? ` highcharts-zone-graph-${W - 1} ` : " ") + (W && I.className || "")).attr({ zIndex: 1 }).add(this.group)), a && !E && (y = { stroke: !W && R.lineColor || I.color || this.color || "#cccccc", "stroke-width": R.lineWidth || 0, fill: this.fillGraph && this.color || "none" }, k ? y.dashstyle = k : R.linecap !== "square" && (y["stroke-linecap"] = y["stroke-linejoin"] = "round"), a[v](y).shadow(W < 2 && R.shadow && D({ filterUnits: "userSpaceOnUse" }, J(R.shadow) ? R.shadow : {}))), a && (a.startX = Q.xMap, a.isArea = Q.isArea) }) } getGraphPath(R, Q, E) { let I = this, W = I.options, y = [], a = [], v, k = W.step; R = R || I.points; let w = R.reversed; return w && R.reverse(), (k = { right: 1, center: 2 }[k] || k && 3) && w && (k = 4 - k), (R = this.getValidPoints(R, !1, !(W.connectNulls && !Q && !E))).forEach(function (L, G) { let _, N = L.plotX, F = L.plotY, C = R[G - 1], x = L.isNull || typeof F != "number"; (L.leftCliff || C && C.rightCliff) && !E && (v = !0), x && !j(Q) && G > 0 ? v = !W.connectNulls : x && !Q ? v = !0 : (G === 0 || v ? _ = [["M", L.plotX, L.plotY]] : I.getPointSpline ? _ = [I.getPointSpline(R, L, G)] : k ? (_ = k === 1 ? [["L", C.plotX, F]] : k === 2 ? [["L", (C.plotX + N) / 2, C.plotY], ["L", (C.plotX + N) / 2, F]] : [["L", N, C.plotY]]).push(["L", N, F]) : _ = [["L", N, F]], a.push(L.x), k && (a.push(L.x), k === 2 && a.push(L.x)), y.push.apply(y, _), v = !1) }), y.xMap = a, I.graphPath = y, y } } return se.defaultOptions = D(r.defaultOptions, { legendSymbol: "lineMarker" }), s.registerSeriesType("line", se), se }), n(i, "Series/Area/AreaSeries.js", [i["Core/Color/Color.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g) { let { seriesTypes: { line: j } } = s, { extend: D, merge: J, objectEach: se, pick: $ } = g; class R extends j { drawGraph() { this.areaPath = [], super.drawGraph.apply(this); let { areaPath: E, options: I } = this;[this, ...this.zones].forEach((W, y) => { let a = {}, v = W.fillColor || I.fillColor, k = W.area, w = k ? "animate" : "attr"; k ? (k.endX = this.preventGraphAnimation ? null : E.xMap, k.animate({ d: E })) : (a.zIndex = 0, (k = W.area = this.chart.renderer.path(E).addClass("highcharts-area" + (y ? ` highcharts-zone-area-${y - 1} ` : " ") + (y && W.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (a.fill = v || W.color || this.color, a["fill-opacity"] = v ? 1 : I.fillOpacity ?? .75, k.css({ pointerEvents: this.stickyTracking ? "none" : "auto" })), k[w](a), k.startX = E.xMap, k.shiftUnit = I.step ? 2 : 1 }) } getGraphPath(E) { let I, W, y, a = j.prototype.getGraphPath, v = this.options, k = v.stacking, w = this.yAxis, L = [], G = [], _ = this.index, N = w.stacking.stacks[this.stackKey], F = v.threshold, C = Math.round(w.getThreshold(v.threshold)), x = $(v.connectNulls, k === "percent"), P = function (d, m, p) { let T = E[d], U = k && N[T.x].points[_], ee = T[p + "Null"] || 0, Z = T[p + "Cliff"] || 0, H, Y, S = !0; Z || ee ? (H = (ee ? U[0] : U[1]) + Z, Y = U[0] + Z, S = !!ee) : !k && E[m] && E[m].isNull && (H = Y = F), H !== void 0 && (G.push({ plotX: I, plotY: H === null ? C : w.getThreshold(H), isNull: S, isCliff: !0 }), L.push({ plotX: I, plotY: Y === null ? C : w.getThreshold(Y), doCurve: !1 })) }; E = E || this.points, k && (E = this.getStackPoints(E)); for (let d = 0, m = E.length; d < m; ++d)k || (E[d].leftCliff = E[d].rightCliff = E[d].leftNull = E[d].rightNull = void 0), W = E[d].isNull, I = $(E[d].rectPlotX, E[d].plotX), y = k ? $(E[d].yBottom, C) : C, W && !x || (x || P(d, d - 1, "left"), W && !k && x || (G.push(E[d]), L.push({ x: d, plotX: I, plotY: y })), x || P(d, d + 1, "right")); let f = a.call(this, G, !0, !0); L.reversed = !0; let o = a.call(this, L, !0, !0), u = o[0]; u && u[0] === "M" && (o[0] = ["L", u[1], u[2]]); let l = f.concat(o); l.length && l.push(["Z"]); let h = a.call(this, G, !1, x); return l.xMap = f.xMap, this.areaPath = l, h } getStackPoints(E) { let I = this, W = [], y = [], a = this.xAxis, v = this.yAxis, k = v.stacking.stacks[this.stackKey], w = {}, L = v.series, G = L.length, _ = v.options.reversedStacks ? 1 : -1, N = L.indexOf(I); if (E = E || this.points, this.options.stacking) { for (let C = 0; C < E.length; C++)E[C].leftNull = E[C].rightNull = void 0, w[E[C].x] = E[C]; se(k, function (C, x) { C.total !== null && y.push(x) }), y.sort(function (C, x) { return C - x }); let F = L.map(C => C.visible); y.forEach(function (C, x) { let P = 0, f, o; if (w[C] && !w[C].isNull) W.push(w[C]), [-1, 1].forEach(function (u) { let l = u === 1 ? "rightNull" : "leftNull", h = k[y[x + u]], d = 0; if (h) { let m = N; for (; m >= 0 && m < G;) { let p = L[m].index; !(f = h.points[p]) && (p === I.index ? w[C][l] = !0 : F[m] && (o = k[C].points[p]) && (d -= o[1] - o[0])), m += _ } } w[C][u === 1 ? "rightCliff" : "leftCliff"] = d }); else { let u = N; for (; u >= 0 && u < G;) { let l = L[u].index; if (f = k[C].points[l]) { P = f[1]; break } u += _ } P = $(P, 0), P = v.translate(P, 0, 1, 0, 1), W.push({ isNull: !0, plotX: a.translate(C, 0, 0, 0, 1), x: C, plotY: P, yBottom: P }) } }) } return W } } return R.defaultOptions = J(j.defaultOptions, { threshold: 0, legendSymbol: "areaMarker" }), D(R.prototype, { singleStacks: !1 }), s.registerSeriesType("area", R), R }), n(i, "Series/Spline/SplineSeries.js", [i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s) { let { line: g } = r.seriesTypes, { merge: j, pick: D } = s; class J extends g { getPointSpline($, R, Q) { let E, I, W, y, a = R.plotX || 0, v = R.plotY || 0, k = $[Q - 1], w = $[Q + 1]; function L(_) { return _ && !_.isNull && _.doCurve !== !1 && !R.isCliff } if (L(k) && L(w)) { let _ = k.plotX || 0, N = k.plotY || 0, F = w.plotX || 0, C = w.plotY || 0, x = 0; E = (1.5 * a + _) / 2.5, I = (1.5 * v + N) / 2.5, W = (1.5 * a + F) / 2.5, y = (1.5 * v + C) / 2.5, W !== E && (x = (y - I) * (W - a) / (W - E) + v - y), I += x, y += x, I > N && I > v ? (I = Math.max(N, v), y = 2 * v - I) : I < N && I < v && (I = Math.min(N, v), y = 2 * v - I), y > C && y > v ? (y = Math.max(C, v), I = 2 * v - y) : y < C && y < v && (y = Math.min(C, v), I = 2 * v - y), R.rightContX = W, R.rightContY = y, R.controlPoints = { low: [E, I], high: [W, y] } } let G = ["C", D(k.rightContX, k.plotX, 0), D(k.rightContY, k.plotY, 0), D(E, a, 0), D(I, v, 0), a, v]; return k.rightContX = k.rightContY = void 0, G } } return J.defaultOptions = j(g.defaultOptions), r.registerSeriesType("spline", J), J }), n(i, "Series/AreaSpline/AreaSplineSeries.js", [i["Series/Spline/SplineSeries.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g) { let { area: j, area: { prototype: D } } = s.seriesTypes, { extend: J, merge: se } = g; class $ extends r { } return $.defaultOptions = se(r.defaultOptions, j.defaultOptions), J($.prototype, { getGraphPath: D.getGraphPath, getStackPoints: D.getStackPoints, drawGraph: D.drawGraph }), s.registerSeriesType("areaspline", $), $ }), n(i, "Series/Column/ColumnSeriesDefaults.js", [], function () { return { borderRadius: 3, centerInCategory: !1, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: !1, brightness: .1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" } }), n(i, "Series/Column/ColumnSeries.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Color/Color.js"], i["Series/Column/ColumnSeriesDefaults.js"], i["Core/Globals.js"], i["Core/Series/Series.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J, se) { let { animObject: $ } = r, { parse: R } = s, { hasTouch: Q, noop: E } = j, { clamp: I, defined: W, extend: y, fireEvent: a, isArray: v, isNumber: k, merge: w, pick: L, objectEach: G, relativeLength: _ } = se; class N extends D { animate(C) { let x, P, f = this, o = this.yAxis, u = o.pos, l = f.options, h = this.chart.inverted, d = {}, m = h ? "translateX" : "translateY"; C ? (d.scaleY = .001, P = I(o.toPixels(l.threshold), u, u + o.len), h ? d.translateX = P - o.len : d.translateY = P, f.clipBox && f.setClip(), f.group.attr(d)) : (x = Number(f.group.attr(m)), f.group.animate({ scaleY: 1 }, y($(f.options.animation), { step: function (p, T) { f.group && (d[m] = x + T.pos * (u - x), f.group.attr(d)) } }))) } init(C, x) { super.init.apply(this, arguments); let P = this; (C = P.chart).hasRendered && C.series.forEach(function (f) { f.type === P.type && (f.isDirty = !0) }) } getColumnMetrics() { var Y, S; let C = this, x = C.options, P = C.xAxis, f = C.yAxis, o = P.options.reversedStacks, u = P.reversed && !o || !P.reversed && o, l = {}, h, d = 0; x.grouping === !1 ? d = 1 : C.chart.series.forEach(function (A) { let B, K = A.yAxis, c = A.options; A.type === C.type && A.reserveSpace() && f.len === K.len && f.pos === K.pos && (c.stacking && c.stacking !== "group" ? (l[h = A.stackKey] === void 0 && (l[h] = d++), B = l[h]) : c.grouping !== !1 && (B = d++), A.columnIndex = B) }); let m = Math.min(Math.abs(P.transA) * (!((Y = P.brokenAxis) != null && Y.hasBreaks) && ((S = P.ordinal) == null ? void 0 : S.slope) || x.pointRange || P.closestPointRange || P.tickInterval || 1), P.len), p = m * x.groupPadding, T = (m - 2 * p) / (d || 1), U = Math.min(x.maxPointWidth || P.len, L(x.pointWidth, T * (1 - 2 * x.pointPadding))), ee = (T - U) / 2, Z = (C.columnIndex || 0) + (u ? 1 : 0), H = ee + (p + Z * T - m / 2) * (u ? -1 : 1); return C.columnMetrics = { width: U, offset: H, paddedWidth: T, columnCount: d }, C.columnMetrics } crispCol(C, x, P, f) { this.chart; let o = this.borderWidth, u = -(o % 2 ? .5 : 0), l = o % 2 ? .5 : 1; this.options.crisp && (P = Math.round(C + P) + u - (C = Math.round(C) + u)); let h = Math.round(x + f) + l, d = .5 >= Math.abs(x) && h > .5; return f = h - (x = Math.round(x) + l), d && f && (x -= 1, f += 1), { x: C, y: x, width: P, height: f } } adjustForMissingColumns(C, x, P, f) { var o; if (!P.isNull && f.columnCount > 1) { let u = this.xAxis.series.filter(m => m.visible).map(m => m.index), l = 0, h = 0; G((o = this.xAxis.stacking) == null ? void 0 : o.stacks, m => { if (typeof P.x == "number") { let p = m[P.x.toString()]; if (p) { let T = p.points[this.index]; if (v(T)) { let U = Object.keys(p.points).filter(ee => !ee.match(",") && p.points[ee] && p.points[ee].length > 1).map(parseFloat).filter(ee => u.indexOf(ee) !== -1).sort((ee, Z) => Z - ee); l = U.indexOf(this.index), h = U.length } } } }); let d = (h - 1) * f.paddedWidth + x; C = (P.plotX || 0) + d / 2 - x - l * f.paddedWidth } return C } translate() { let C = this, x = C.chart, P = C.options, f = C.dense = C.closestPointRange * C.xAxis.transA < 2, o = C.borderWidth = L(P.borderWidth, f ? 0 : 1), u = C.xAxis, l = C.yAxis, h = P.threshold, d = L(P.minPointLength, 5), m = C.getColumnMetrics(), p = m.width, T = C.pointXOffset = m.offset, U = C.dataMin, ee = C.dataMax, Z = C.barW = Math.max(p, 1 + 2 * o), H = C.translatedThreshold = l.getThreshold(h); x.inverted && (H -= .5), P.pointPadding && (Z = Math.ceil(Z)), D.prototype.translate.apply(C), C.points.forEach(function (Y) { let S = L(Y.yBottom, H), A = 999 + Math.abs(S), B = Y.plotX || 0, K = I(Y.plotY, -A, l.len + A); Y.stackBox; let c, M = Math.min(K, S), b = Math.max(K, S) - M, z = p, O = B + T, q = Z; d && Math.abs(b) < d && (b = d, c = !l.reversed && !Y.negative || l.reversed && Y.negative, k(h) && k(ee) && Y.y === h && ee <= h && (l.min || 0) < h && (U !== ee || (l.max || 0) <= h) && (c = !c, Y.negative = !Y.negative), M = Math.abs(M - H) > d ? S - d : H - (c ? d : 0)), W(Y.options.pointWidth) && (O -= Math.round(((z = q = Math.ceil(Y.options.pointWidth)) - p) / 2)), P.centerInCategory && !P.stacking && (O = C.adjustForMissingColumns(O, z, Y, m)), Y.barX = O, Y.pointWidth = z, Y.tooltipPos = x.inverted ? [I(l.len + l.pos - x.plotLeft - K, l.pos - x.plotLeft, l.len + l.pos - x.plotLeft), u.len + u.pos - x.plotTop - O - q / 2, b] : [u.left - x.plotLeft + O + q / 2, I(K + l.pos - x.plotTop, l.pos - x.plotTop, l.len + l.pos - x.plotTop), b], Y.shapeType = C.pointClass.prototype.shapeType || "roundedRect", Y.shapeArgs = C.crispCol(O, Y.isNull ? H : M, q, Y.isNull ? 0 : b) }), a(this, "afterColumnTranslate") } drawGraph() { this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data") } pointAttribs(C, x) { let P = this.options, f = this.pointAttrToOptions || {}, o = f.stroke || "borderColor", u = f["stroke-width"] || "borderWidth", l, h, d, m = C && C.color || this.color, p = C && C[o] || P[o] || m, T = C && C.options.dashStyle || P.dashStyle, U = C && C[u] || P[u] || this[u] || 0, ee = L(C && C.opacity, P.opacity, 1); C && this.zones.length && (h = C.getZone(), m = C.options.color || h && (h.color || C.nonZonedColor) || this.color, h && (p = h.borderColor || p, T = h.dashStyle || T, U = h.borderWidth || U)), x && C && (d = (l = w(P.states[x], C.options.states && C.options.states[x] || {})).brightness, m = l.color || d !== void 0 && R(m).brighten(l.brightness).get() || m, p = l[o] || p, U = l[u] || U, T = l.dashStyle || T, ee = L(l.opacity, ee)); let Z = { fill: m, stroke: p, "stroke-width": U, opacity: ee }; return T && (Z.dashstyle = T), Z } drawPoints(C = this.points) { let x, P = this, f = this.chart, o = P.options, u = f.renderer, l = o.animationLimit || 250; C.forEach(function (h) { let d = h.plotY, m = h.graphic, p = !!m, T = m && f.pointCount < l ? "animate" : "attr"; k(d) && h.y !== null ? (x = h.shapeArgs, m && h.hasNewShapeType() && (m = m.destroy()), P.enabledDataSorting && (h.startXPos = P.xAxis.reversed ? -(x && x.width || 0) : P.xAxis.width), !m && (h.graphic = m = u[h.shapeType](x).add(h.group || P.group), m && P.enabledDataSorting && f.hasRendered && f.pointCount < l && (m.attr({ x: h.startXPos }), p = !0, T = "animate")), m && p && m[T](w(x)), f.styledMode || m[T](P.pointAttribs(h, h.selected && "select")).shadow(h.allowShadow !== !1 && o.shadow), m && (m.addClass(h.getClassName(), !0), m.attr({ visibility: h.visible ? "inherit" : "hidden" }))) : m && (h.graphic = m.destroy()) }) } drawTracker(C = this.points) { let x, P = this, f = P.chart, o = f.pointer, u = function (l) { let h = o.getPointFromEvent(l); h !== void 0 && P.options.enableMouseTracking && (o.isDirectTouch = !0, h.onMouseOver(l)) }; C.forEach(function (l) { x = v(l.dataLabels) ? l.dataLabels : l.dataLabel ? [l.dataLabel] : [], l.graphic && (l.graphic.element.point = l), x.forEach(function (h) { h.div ? h.div.point = l : h.element.point = l }) }), P._hasTracking || (P.trackerGroups.forEach(function (l) { P[l] && (P[l].addClass("highcharts-tracker").on("mouseover", u).on("mouseout", function (h) { o.onTrackerMouseOut(h) }), Q && P[l].on("touchstart", u), !f.styledMode && P.options.cursor && P[l].css({ cursor: P.options.cursor })) }), P._hasTracking = !0), a(this, "afterDrawTracker") } remove() { let C = this, x = C.chart; x.hasRendered && x.series.forEach(function (P) { P.type === C.type && (P.isDirty = !0) }), D.prototype.remove.apply(C, arguments) } } return N.defaultOptions = w(D.defaultOptions, g), y(N.prototype, { directTouch: !0, getSymbol: E, negStacks: !0, trackerGroups: ["group", "dataLabelsGroup"] }), J.registerSeriesType("column", N), N }), n(i, "Core/Series/DataLabel.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Templating.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g, j) { var D; let { getDeferredAnimation: J } = r, { format: se } = s, { composed: $ } = g, { defined: R, extend: Q, fireEvent: E, isArray: I, isString: W, merge: y, objectEach: a, pick: v, pInt: k, pushUnique: w, splat: L } = j; return function (G) { function _() { return o(this).some(l => l == null ? void 0 : l.enabled) } function N(l, h, d, m, p) { let T = this, U = this.chart, ee = this.isCartesian && U.inverted, Z = this.enabledDataSorting, H = l.plotX, Y = l.plotY, S = d.rotation, A = d.align, B = R(H) && R(Y) && U.isInsidePlot(H, Math.round(Y), { inverted: ee, paneCoordinates: !0, series: T }), K = ie => { Z && T.xAxis && !z && T.setDataLabelStartPos(l, h, p, B, ie) }, c, M, b, z = v(d.overflow, Z ? "none" : "justify") === "justify", O = this.visible && l.visible !== !1 && R(H) && (l.series.forceDL || Z && !z || B || v(d.inside, !!this.options.stacking) && m && U.isInsidePlot(H, ee ? m.x + 1 : m.y + m.height - 1, { inverted: ee, paneCoordinates: !0, series: T })), q = l.pos(); if (O && q) { S && h.attr({ align: A }); let ie = h.getBBox(!0), re = [0, 0]; if (c = U.renderer.fontMetrics(h).b, m = Q({ x: q[0], y: Math.round(q[1]), width: 0, height: 0 }, m), Q(d, { width: ie.width, height: ie.height }), S ? (z = !1, M = U.renderer.rotCorr(c, S), b = { x: m.x + (d.x || 0) + m.width / 2 + M.x, y: m.y + (d.y || 0) + { top: 0, middle: .5, bottom: 1 }[d.verticalAlign] * m.height }, re = [ie.x - Number(h.attr("x")), ie.y - Number(h.attr("y"))], K(b), h[p ? "attr" : "animate"](b)) : (K(m), h.align(d, void 0, m), b = h.alignAttr), z && m.height >= 0) this.justifyDataLabel(h, d, b, ie, m, p); else if (v(d.crop, !0)) { let { x: oe, y: he } = b; oe += re[0], he += re[1], O = U.isInsidePlot(oe, he, { paneCoordinates: !0, series: T }) && U.isInsidePlot(oe + ie.width, he + ie.height, { paneCoordinates: !0, series: T }) } d.shape && !S && h[p ? "attr" : "animate"]({ anchorX: q[0], anchorY: q[1] }) } p && Z && (h.placed = !1), O || Z && !z ? h.show() : (h.hide(), h.placed = !1) } function F() { return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6) } function C(l) { let h = this.hasRendered || 0, d = this.initDataLabelsGroup().attr({ opacity: +h }); return !h && d && (this.visible && d.show(), this.options.animation ? d.animate({ opacity: 1 }, l) : d.attr({ opacity: 1 })), d } function x(l) { var B; let h; l = l || this.points; let d = this, m = d.chart, p = d.options, T = m.renderer, { backgroundColor: U, plotBackgroundColor: ee } = m.options.chart, Z = T.getContrast(W(ee) && ee || W(U) && U || "#000000"), H = o(d), { animation: Y, defer: S } = H[0], A = S ? J(m, Y, d) : { defer: 0, duration: 0 }; E(this, "drawDataLabels"), (B = d.hasDataLabels) != null && B.call(d) && (h = this.initDataLabels(A), l.forEach(K => { var b, z; let c = K.dataLabels || []; L(f(H, K.dlOptions || ((b = K.options) == null ? void 0 : b.dataLabels))).forEach((O, q) => { var ue; let ie = O.enabled && K.visible && (!K.isNull || K.dataLabelOnNull) && function (ge, Se) { let fe = Se.filter; if (fe) { let me = fe.operator, ke = ge[fe.property], be = fe.value; return me === ">" && ke > be || me === "<" && ke < be || me === ">=" && ke >= be || me === "<=" && ke <= be || me === "==" && ke == be || me === "===" && ke === be || me === "!=" && ke != be || me === "!==" && ke !== be } return !0 }(K, O), { backgroundColor: re, borderColor: oe, distance: he, style: ce = {} } = O, pe, V, X, te, ne = {}, ae = c[q], le = !ae, de; if (ie && (V = v(O[K.formatPrefix + "Format"], O.format), pe = K.getLabelConfig(), X = R(V) ? se(V, pe, m) : (O[K.formatPrefix + "Formatter"] || O.formatter).call(pe, O), te = O.rotation, !m.styledMode && (ce.color = v(O.color, ce.color, W(d.color) ? d.color : void 0, "#000000"), ce.color === "contrast" ? (re !== "none" && (de = re), K.contrastColor = T.getContrast(de !== "auto" && de || K.color || d.color), ce.color = de || !R(he) && O.inside || 0 > k(he || 0) || p.stacking ? K.contrastColor : Z) : delete K.contrastColor, p.cursor && (ce.cursor = p.cursor)), ne = { r: O.borderRadius || 0, rotation: te, padding: O.padding, zIndex: 1 }, m.styledMode || (ne.fill = re === "auto" ? K.color : re, ne.stroke = oe === "auto" ? K.color : oe, ne["stroke-width"] = O.borderWidth), a(ne, (ge, Se) => { ge === void 0 && delete ne[Se] })), !ae || ie && R(X) && !!ae.div == !!O.useHTML && (ae.rotation && O.rotation || ae.rotation === O.rotation) || (ae = void 0, le = !0), ie && R(X) && (ae ? ne.text = X : (ae = te ? T.text(X, 0, 0, O.useHTML).addClass("highcharts-data-label") : T.label(X, 0, 0, O.shape, void 0, void 0, O.useHTML, void 0, "data-label")) && ae.addClass(" highcharts-data-label-color-" + K.colorIndex + " " + (O.className || "") + (O.useHTML ? " highcharts-tracker" : "")), ae)) { ae.options = O, ae.attr(ne), m.styledMode || ae.css(ce).shadow(O.shadow); let ge = O[K.formatPrefix + "TextPath"] || O.textPath; ge && !O.useHTML && (ae.setTextPath(((ue = K.getDataLabelPath) == null ? void 0 : ue.call(K, ae)) || K.graphic, ge), K.dataLabelPath && !ge.enabled && (K.dataLabelPath = K.dataLabelPath.destroy())), ae.added || ae.add(h), d.alignDataLabel(K, ae, O, void 0, le), ae.isActive = !0, c[q] && c[q] !== ae && c[q].destroy(), c[q] = ae } }); let M = c.length; for (; M--;)c[M] && c[M].isActive ? c[M].isActive = !1 : ((z = c[M]) == null || z.destroy(), c.splice(M, 1)); K.dataLabel = c[0], K.dataLabels = c })), E(this, "afterDrawDataLabels") } function P(l, h, d, m, p, T) { let U = this.chart, ee = h.align, Z = h.verticalAlign, H = l.box ? 0 : l.padding || 0, { x: Y = 0, y: S = 0 } = h, A, B; return (A = (d.x || 0) + H) < 0 && (ee === "right" && Y >= 0 ? (h.align = "left", h.inside = !0) : Y -= A, B = !0), (A = (d.x || 0) + m.width - H) > U.plotWidth && (ee === "left" && Y <= 0 ? (h.align = "right", h.inside = !0) : Y += U.plotWidth - A, B = !0), (A = d.y + H) < 0 && (Z === "bottom" && S >= 0 ? (h.verticalAlign = "top", h.inside = !0) : S -= A, B = !0), (A = (d.y || 0) + m.height - H) > U.plotHeight && (Z === "top" && S <= 0 ? (h.verticalAlign = "bottom", h.inside = !0) : S += U.plotHeight - A, B = !0), B && (h.x = Y, h.y = S, l.placed = !T, l.align(h, void 0, p)), B } function f(l, h) { let d = [], m; if (I(l) && !I(h)) d = l.map(function (p) { return y(p, h) }); else if (I(h) && !I(l)) d = h.map(function (p) { return y(l, p) }); else if (I(l) || I(h)) { if (I(l) && I(h)) for (m = Math.max(l.length, h.length); m--;)d[m] = y(l[m], h[m]) } else d = y(l, h); return d } function o(l) { var d, m; let h = l.chart.options.plotOptions; return L(f(f((d = h == null ? void 0 : h.series) == null ? void 0 : d.dataLabels, (m = h == null ? void 0 : h[l.type]) == null ? void 0 : m.dataLabels), l.options.dataLabels)) } function u(l, h, d, m, p) { let T = this.chart, U = T.inverted, ee = this.xAxis, Z = ee.reversed, H = ((U ? h.height : h.width) || 0) / 2, Y = l.pointWidth, S = Y ? Y / 2 : 0; h.startXPos = U ? p.x : Z ? -H - S : ee.width - H + S, h.startYPos = U ? Z ? this.yAxis.height - H + S : -H - S : p.y, m ? h.visibility === "hidden" && (h.show(), h.attr({ opacity: 0 }).animate({ opacity: 1 })) : h.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, h.hide), T.hasRendered && (d && h.attr({ x: h.startXPos, y: h.startYPos }), h.placed = !0) } G.compose = function l(h) { if (w($, l)) { let d = h.prototype; d.initDataLabelsGroup = F, d.initDataLabels = C, d.alignDataLabel = N, d.drawDataLabels = x, d.justifyDataLabel = P, d.setDataLabelStartPos = u, d.hasDataLabels = _ } } }(D || (D = {})), D }), n(i, "Series/Column/ColumnDataLabel.js", [i["Core/Series/DataLabel.js"], i["Core/Globals.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g, j) { var D; let { composed: J } = s, { series: se } = g, { merge: $, pick: R, pushUnique: Q } = j; return function (E) { function I(W, y, a, v, k) { let w = this.chart.inverted, L = W.series, G = (L.xAxis ? L.xAxis.len : this.chart.plotSizeX) || 0, _ = (L.yAxis ? L.yAxis.len : this.chart.plotSizeY) || 0, N = W.dlBox || W.shapeArgs, F = R(W.below, W.plotY > R(this.translatedThreshold, _)), C = R(a.inside, !!this.options.stacking); if (N) { if (v = $(N), !(a.overflow === "allow" && a.crop === !1)) { v.y < 0 && (v.height += v.y, v.y = 0); let x = v.y + v.height - _; x > 0 && x < v.height && (v.height -= x) } w && (v = { x: _ - v.y - v.height, y: G - v.x - v.width, width: v.height, height: v.width }), C || (w ? (v.x += F ? 0 : v.width, v.width = 0) : (v.y += F ? v.height : 0, v.height = 0)) } a.align = R(a.align, !w || C ? "center" : F ? "right" : "left"), a.verticalAlign = R(a.verticalAlign, w || C ? "middle" : F ? "top" : "bottom"), se.prototype.alignDataLabel.call(this, W, y, a, v, k), a.inside && W.contrastColor && y.css({ color: W.contrastColor }) } E.compose = function W(y) { r.compose(se), Q(J, W) && (y.prototype.alignDataLabel = I) } }(D || (D = {})), D }), n(i, "Series/Bar/BarSeries.js", [i["Series/Column/ColumnSeries.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g) { let { extend: j, merge: D } = g; class J extends r { } return J.defaultOptions = D(r.defaultOptions, {}), j(J.prototype, { inverted: !0 }), s.registerSeriesType("bar", J), J }), n(i, "Series/Scatter/ScatterSeriesDefaults.js", [], function () { return { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: !0 }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } } }), n(i, "Series/Scatter/ScatterSeries.js", [i["Series/Scatter/ScatterSeriesDefaults.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g) { let { column: j, line: D } = s.seriesTypes, { addEvent: J, extend: se, merge: $ } = g; class R extends D { applyJitter() { let E = this, I = this.options.jitter, W = this.points.length; I && this.points.forEach(function (y, a) { ["x", "y"].forEach(function (v, k) { let w, L = "plot" + v.toUpperCase(), G, _, N; I[v] && !y.isNull && (w = E[v + "Axis"], N = I[v] * w.transA, w && !w.isLog && (G = Math.max(0, y[L] - N), _ = Math.min(w.len, y[L] + N), y[L] = G + (_ - G) * function (F) { let C = 1e4 * Math.sin(F); return C - Math.floor(C) }(a + k * W), v === "x" && (y.clientX = y.plotX))) }) }) } drawGraph() { this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy()) } } return R.defaultOptions = $(D.defaultOptions, r), se(R.prototype, { drawTracker: j.prototype.drawTracker, sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"] }), J(R, "afterTranslate", function () { this.applyJitter() }), s.registerSeriesType("scatter", R), R }), n(i, "Series/CenteredUtilities.js", [i["Core/Globals.js"], i["Core/Series/Series.js"], i["Core/Utilities.js"]], function (r, s, g) { var j, D; let { deg2rad: J } = r, { fireEvent: se, isNumber: $, pick: R, relativeLength: Q } = g; return (D = j || (j = {})).getCenter = function () { let E = this.options, I = this.chart, W = 2 * (E.slicedOffset || 0), y = I.plotWidth - 2 * W, a = I.plotHeight - 2 * W, v = E.center, k = Math.min(y, a), w = E.thickness, L, G = E.size, _ = E.innerSize || 0, N, F; typeof G == "string" && (G = parseFloat(G)), typeof _ == "string" && (_ = parseFloat(_)); let C = [R(v[0], "50%"), R(v[1], "50%"), R(G && G < 0 ? void 0 : E.size, "100%"), R(_ && _ < 0 ? void 0 : E.innerSize || 0, "0%")]; for (!I.angular || this instanceof s || (C[3] = 0), N = 0; N < 4; ++N)F = C[N], L = N < 2 || N === 2 && /%$/.test(F), C[N] = Q(F, [y, a, k, C[2]][N]) + (L ? W : 0); return C[3] > C[2] && (C[3] = C[2]), $(w) && 2 * w < C[2] && w > 0 && (C[3] = C[2] - 2 * w), se(this, "afterGetCenter", { positions: C }), C }, D.getStartAndEndRadians = function (E, I) { let W = $(E) ? E : 0, y = $(I) && I > W && I - W < 360 ? I : W + 360; return { start: J * (W + -90), end: J * (y + -90) } }, j }), n(i, "Series/Pie/PiePoint.js", [i["Core/Animation/AnimationUtilities.js"], i["Core/Series/Point.js"], i["Core/Utilities.js"]], function (r, s, g) { let { setAnimation: j } = r, { addEvent: D, defined: J, extend: se, isNumber: $, isString: R, pick: Q, relativeLength: E } = g; class I extends s { getConnectorPath(y) { let a = y.dataLabelPosition, v = y.options || {}, k = v.connectorShape, w = this.connectorShapes[k] || k; return a && w.call(this, { ...a.computed, alignment: a.alignment }, a.connectorPosition, v) || [] } getTranslate() { return this.sliced && this.slicedTranslation || { translateX: 0, translateY: 0 } } haloPath(y) { let a = this.shapeArgs; return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(a.x, a.y, a.r + y, a.r + y, { innerR: a.r - 1, start: a.start, end: a.end, borderRadius: a.borderRadius }) } constructor(y, a, v) { super(y, a, v), this.half = 0, this.name ?? (this.name = "Slice"); let k = w => { this.slice(w.type === "select") }; D(this, "select", k), D(this, "unselect", k) } isValid() { return $(this.y) && this.y >= 0 } setVisible(y, a = !0) { y !== this.visible && this.update({ visible: y ?? !this.visible }, a, void 0, !1) } slice(y, a, v) { let k = this.series, w = k.chart; j(v, w), a = Q(a, !0), this.sliced = this.options.sliced = y = J(y) ? y : !this.sliced, k.options.data[k.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate()) } } return se(I.prototype, { connectorShapes: { fixedOffset: function (W, y, a) { let v = y.breakAt, k = y.touchingSliceAt, w = a.softConnector ? ["C", W.x + (W.alignment === "left" ? -5 : 5), W.y, 2 * v.x - k.x, 2 * v.y - k.y, v.x, v.y] : ["L", v.x, v.y]; return [["M", W.x, W.y], w, ["L", k.x, k.y]] }, straight: function (W, y) { let a = y.touchingSliceAt; return [["M", W.x, W.y], ["L", a.x, a.y]] }, crookedLine: function (W, y, a) { let { breakAt: v, touchingSliceAt: k } = y, { series: w } = this, [L, G, _] = w.center, N = _ / 2, { plotLeft: F, plotWidth: C } = w.chart, x = W.alignment === "left", { x: P, y: f } = W, o = v.x; if (a.crookDistance) { let l = E(a.crookDistance, 1); o = x ? L + N + (C + F - L - N) * (1 - l) : F + (L - N) * l } else o = L + (G - f) * Math.tan((this.angle || 0) - Math.PI / 2); let u = [["M", P, f]]; return (x ? o <= P && o >= v.x : o >= P && o <= v.x) && u.push(["L", o, f]), u.push(["L", v.x, v.y], ["L", k.x, k.y]), u } } }), I }), n(i, "Series/Pie/PieSeriesDefaults.js", [], function () { return { borderRadius: 3, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: !0, formatter: function () { return this.point.isNull ? void 0 : this.point.name }, softConnector: !0, x: 0 }, fillColor: void 0, ignoreHiddenPoint: !0, inactiveOtherPoints: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, stickyTracking: !1, tooltip: { followPointer: !0 }, borderColor: "#ffffff", borderWidth: 1, lineWidth: void 0, states: { hover: { brightness: .1 } } } }), n(i, "Series/Pie/PieSeries.js", [i["Series/CenteredUtilities.js"], i["Series/Column/ColumnSeries.js"], i["Core/Globals.js"], i["Series/Pie/PiePoint.js"], i["Series/Pie/PieSeriesDefaults.js"], i["Core/Series/Series.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Renderer/SVG/Symbols.js"], i["Core/Utilities.js"]], function (r, s, g, j, D, J, se, $, R) { let { getStartAndEndRadians: Q } = r, { noop: E } = g, { clamp: I, extend: W, fireEvent: y, merge: a, pick: v, relativeLength: k, splat: w } = R; class L extends J { animate(_) { let N = this, F = N.points, C = N.startAngleRad; _ || F.forEach(function (x) { let P = x.graphic, f = x.shapeArgs; P && f && (P.attr({ r: v(x.startR, N.center && N.center[3] / 2), start: C, end: C }), P.animate({ r: f.r, start: f.start, end: f.end }, N.options.animation)) }) } drawEmpty() { let _, N, F = this.startAngleRad, C = this.endAngleRad, x = this.options; this.total === 0 && this.center ? (_ = this.center[0], N = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(_, N, this.center[1] / 2, 0, F, C).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: $.arc(_, N, this.center[2] / 2, 0, { start: F, end: C, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": x.borderWidth, fill: x.fillColor || "none", stroke: x.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy()) } drawPoints() { let _ = this.chart.renderer; this.points.forEach(function (N) { N.graphic && N.hasNewShapeType() && (N.graphic = N.graphic.destroy()), N.graphic || (N.graphic = _[N.shapeType](N.shapeArgs).add(N.series.group), N.delayedRendering = !0) }) } generatePoints() { super.generatePoints(), this.updateTotals() } getX(_, N, F, C) { let x = this.center, P = this.radii ? this.radii[F.index] || 0 : x[2] / 2, f = C.dataLabelPosition, o = (f == null ? void 0 : f.distance) || 0, u = Math.asin(I((_ - x[1]) / (P + o), -1, 1)); return x[0] + (N ? -1 : 1) * (Math.cos(u) * (P + o)) + (o > 0 ? (N ? -1 : 1) * (C.padding || 0) : 0) } hasData() { return !!this.processedXData.length } redrawPoints() { let _, N, F, C, x = this, P = x.chart; this.drawEmpty(), x.group && !P.styledMode && x.group.shadow(x.options.shadow), x.points.forEach(function (f) { let o = {}; N = f.graphic, !f.isNull && N ? (C = f.shapeArgs, _ = f.getTranslate(), P.styledMode || (F = x.pointAttribs(f, f.selected && "select")), f.delayedRendering ? (N.setRadialReference(x.center).attr(C).attr(_), P.styledMode || N.attr(F).attr({ "stroke-linejoin": "round" }), f.delayedRendering = !1) : (N.setRadialReference(x.center), P.styledMode || a(!0, o, F), a(!0, o, C, _), N.animate(o)), N.attr({ visibility: f.visible ? "inherit" : "hidden" }), N.addClass(f.getClassName(), !0)) : N && (f.graphic = N.destroy()) }) } sortByAngle(_, N) { _.sort(function (F, C) { return F.angle !== void 0 && (C.angle - F.angle) * N }) } translate(_) { y(this, "translate"), this.generatePoints(); let N = this.options, F = N.slicedOffset, C = Q(N.startAngle, N.endAngle), x = this.startAngleRad = C.start, P = this.endAngleRad = C.end, f = P - x, o = this.points, u = N.ignoreHiddenPoint, l = o.length, h, d, m, p, T, U, ee, Z = 0; for (_ || (this.center = _ = this.getCenter()), U = 0; U < l; U++) { ee = o[U], h = x + Z * f, ee.isValid() && (!u || ee.visible) && (Z += ee.percentage / 100), d = x + Z * f; let H = { x: _[0], y: _[1], r: _[2] / 2, innerR: _[3] / 2, start: Math.round(1e3 * h) / 1e3, end: Math.round(1e3 * d) / 1e3 }; ee.shapeType = "arc", ee.shapeArgs = H, (m = (d + h) / 2) > 1.5 * Math.PI ? m -= 2 * Math.PI : m < -Math.PI / 2 && (m += 2 * Math.PI), ee.slicedTranslation = { translateX: Math.round(Math.cos(m) * F), translateY: Math.round(Math.sin(m) * F) }, p = Math.cos(m) * _[2] / 2, T = Math.sin(m) * _[2] / 2, ee.tooltipPos = [_[0] + .7 * p, _[1] + .7 * T], ee.half = m < -Math.PI / 2 || m > Math.PI / 2 ? 1 : 0, ee.angle = m } y(this, "afterTranslate") } updateTotals() { let _ = this.points, N = _.length, F = this.options.ignoreHiddenPoint, C, x, P = 0; for (C = 0; C < N; C++)(x = _[C]).isValid() && (!F || x.visible) && (P += x.y); for (C = 0, this.total = P; C < N; C++)(x = _[C]).percentage = P > 0 && (x.visible || !F) ? x.y / P * 100 : 0, x.total = P } } return L.defaultOptions = a(J.defaultOptions, D), W(L.prototype, { axisTypes: [], directTouch: !0, drawGraph: void 0, drawTracker: s.prototype.drawTracker, getCenter: r.getCenter, getSymbol: E, isCartesian: !1, noSharedTooltip: !0, pointAttribs: s.prototype.pointAttribs, pointClass: j, requireSorting: !1, searchPoint: E, trackerGroups: ["group", "dataLabelsGroup"] }), se.registerSeriesType("pie", L), L }), n(i, "Series/Pie/PieDataLabel.js", [i["Core/Series/DataLabel.js"], i["Core/Globals.js"], i["Core/Renderer/RendererUtilities.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function (r, s, g, j, D) { var J; let { composed: se, noop: $ } = s, { distribute: R } = g, { series: Q } = j, { arrayMax: E, clamp: I, defined: W, pick: y, pushUnique: a, relativeLength: v } = D; return function (k) { let w = { radialDistributionY: function (F, C) { var x; return (((x = C.dataLabelPosition) == null ? void 0 : x.top) || 0) + F.distributeBox.pos }, radialDistributionX: function (F, C, x, P, f) { let o = f.dataLabelPosition; return F.getX(x < ((o == null ? void 0 : o.top) || 0) + 2 || x > ((o == null ? void 0 : o.bottom) || 0) - 2 ? P : x, C.half, C, f) }, justify: function (F, C, x, P) { var f; return P[0] + (F.half ? -1 : 1) * (x + (((f = C.dataLabelPosition) == null ? void 0 : f.distance) || 0)) }, alignToPlotEdges: function (F, C, x, P) { let f = F.getBBox().width; return C ? f + P : x - f - P }, alignToConnectors: function (F, C, x, P) { let f = 0, o; return F.forEach(function (u) { (o = u.dataLabel.getBBox().width) > f && (f = o) }), C ? f + P : x - f - P } }; function L(F, C) { let { center: x, options: P } = this, f = x[2] / 2, o = F.angle || 0, u = Math.cos(o), l = Math.sin(o), h = x[0] + u * f, d = x[1] + l * f, m = Math.min((P.slicedOffset || 0) + (P.borderWidth || 0), C / 5); return { natural: { x: h + u * C, y: d + l * C }, computed: {}, alignment: C < 0 ? "center" : F.half ? "right" : "left", connectorPosition: { breakAt: { x: h + u * m, y: d + l * m }, touchingSliceAt: { x: h, y: d } }, distance: C } } function G() { var Y; let F = this, C = F.points, x = F.chart, P = x.plotWidth, f = x.plotHeight, o = x.plotLeft, u = Math.round(x.chartWidth / 3), l = F.center, h = l[2] / 2, d = l[1], m = [[], []], p = [0, 0, 0, 0], T = F.dataLabelPositioners, U, ee, Z, H = 0; F.visible && ((Y = F.hasDataLabels) != null && Y.call(F)) && (C.forEach(S => { (S.dataLabels || []).forEach(A => { A.shortened && (A.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), A.shortened = !1) }) }), Q.prototype.drawDataLabels.apply(F), C.forEach(S => { (S.dataLabels || []).forEach((A, B) => { var b; let K = l[2] / 2, c = A.options, M = v((c == null ? void 0 : c.distance) || 0, K); B === 0 && m[S.half].push(S), !W((b = c == null ? void 0 : c.style) == null ? void 0 : b.width) && A.getBBox().width > u && (A.css({ width: Math.round(.7 * u) + "px" }), A.shortened = !0), A.dataLabelPosition = this.getDataLabelPosition(S, M), H = Math.max(H, M) }) }), m.forEach((S, A) => { let B = S.length, K = [], c, M, b = 0, z; B && (F.sortByAngle(S, A - .5), H > 0 && (c = Math.max(0, d - h - H), M = Math.min(d + h + H, x.plotHeight), S.forEach(O => { (O.dataLabels || []).forEach((q, ie) => { var oe; let re = q.dataLabelPosition; re && re.distance > 0 && (re.top = Math.max(0, d - h - re.distance), re.bottom = Math.min(d + h + re.distance, x.plotHeight), b = q.getBBox().height || 21, O.distributeBox = { target: (((oe = q.dataLabelPosition) == null ? void 0 : oe.natural.y) || 0) - re.top + b / 2, size: b, rank: O.y }, K.push(O.distributeBox)) }) }), R(K, z = M + b - c, z / 5)), S.forEach(O => { (O.dataLabels || []).forEach(q => { let ie = q.options || {}, re = O.distributeBox, oe = q.dataLabelPosition, he = (oe == null ? void 0 : oe.natural.y) || 0, ce = ie.connectorPadding || 0, pe = 0, V = he, X = "inherit"; if (oe) { if (K && W(re) && oe.distance > 0 && (re.pos === void 0 ? X = "hidden" : (Z = re.size, V = T.radialDistributionY(O, q))), ie.justify) pe = T.justify(O, q, h, l); else switch (ie.alignTo) { case "connectors": pe = T.alignToConnectors(S, A, P, o); break; case "plotEdges": pe = T.alignToPlotEdges(q, A, P, o); break; default: pe = T.radialDistributionX(F, O, V, he, q) }if (oe.attribs = { visibility: X, align: oe.alignment }, oe.posAttribs = { x: pe + (ie.x || 0) + ({ left: ce, right: -ce }[oe.alignment] || 0), y: V + (ie.y || 0) - q.getBBox().height / 2 }, oe.computed.x = pe, oe.computed.y = V, y(ie.crop, !0)) { let te; pe - (ee = q.getBBox().width) < ce && A === 1 ? (te = Math.round(ee - pe + ce), p[3] = Math.max(te, p[3])) : pe + ee > P - ce && A === 0 && (te = Math.round(pe + ee - P + ce), p[1] = Math.max(te, p[1])), V - Z / 2 < 0 ? p[0] = Math.max(Math.round(-V + Z / 2), p[0]) : V + Z / 2 > f && (p[2] = Math.max(Math.round(V + Z / 2 - f), p[2])), oe.sideOverflow = te } } }) })) }), (E(p) === 0 || this.verifyDataLabelOverflow(p)) && (this.placeDataLabels(), this.points.forEach(S => { (S.dataLabels || []).forEach(A => { var M; let { connectorColor: B, connectorWidth: K = 1 } = A.options || {}, c = A.dataLabelPosition; if (K) { let b; U = A.connector, c && c.distance > 0 ? (b = !U, U || (A.connector = U = x.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + S.colorIndex + (S.className ? " " + S.className : "")).add(F.dataLabelsGroup)), x.styledMode || U.attr({ "stroke-width": K, stroke: B || S.color || "#666666" }), U[b ? "attr" : "animate"]({ d: S.getConnectorPath(A) }), U.attr({ visibility: (M = c.attribs) == null ? void 0 : M.visibility })) : U && (A.connector = U.destroy()) } }) }))) } function _() { this.points.forEach(F => { (F.dataLabels || []).forEach(C => { var P; let x = C.dataLabelPosition; x ? (x.sideOverflow && (C.css({ width: Math.max(C.getBBox().width - x.sideOverflow, 0) + "px", textOverflow: (((P = C.options) == null ? void 0 : P.style) || {}).textOverflow || "ellipsis" }), C.shortened = !0), C.attr(x.attribs), C[C.moved ? "animate" : "attr"](x.posAttribs), C.moved = !0) : C && C.attr({ y: -9999 }) }), delete F.distributeBox }, this) } function N(F) { let C = this.center, x = this.options, P = x.center, f = x.minSize || 80, o = f, u = x.size !== null; return !u && (P[0] !== null ? o = Math.max(C[2] - Math.max(F[1], F[3]), f) : (o = Math.max(C[2] - F[1] - F[3], f), C[0] += (F[3] - F[1]) / 2), P[1] !== null ? o = I(o, f, C[2] - Math.max(F[0], F[2])) : (o = I(o, f, C[2] - F[0] - F[2]), C[1] += (F[0] - F[2]) / 2), o < C[2] ? (C[2] = o, C[3] = Math.min(x.thickness ? Math.max(0, o - 2 * x.thickness) : Math.max(0, v(x.innerSize || 0, o)), o), this.translate(C), this.drawDataLabels && this.drawDataLabels()) : u = !0), u } k.compose = function F(C) { if (r.compose(Q), a(se, F)) { let x = C.prototype; x.dataLabelPositioners = w, x.alignDataLabel = $, x.drawDataLabels = G, x.getDataLabelPosition = L, x.placeDataLabels = _, x.verifyDataLabelOverflow = N } } }(J || (J = {})), J }), n(i, "Extensions/OverlappingDataLabels.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { let { composed: g } = r, { addEvent: j, fireEvent: D, isNumber: J, objectEach: se, pick: $, pushUnique: R } = s; function Q(W) { let y = W.length, a = this.renderer, v = (C, x) => !(x.x >= C.x + C.width || x.x + x.width <= C.x || x.y >= C.y + C.height || x.y + x.height <= C.y), k = C => { let x = C.box ? 0 : C.padding || 0, P, f, o, u = 0, l = 0, h, d; if (C && (!C.alignAttr || C.placed)) return P = C.alignAttr || { x: C.attr("x"), y: C.attr("y") }, f = C.parentGroup, C.width || (o = C.getBBox(), C.width = o.width, C.height = o.height, u = a.fontMetrics(C.element).h), h = C.width - 2 * x, (d = { left: "0", center: "0.5", right: "1" }[C.alignValue]) ? l = +d * h : J(C.x) && Math.round(C.x) !== C.translateX && (l = C.x - (C.translateX || 0)), { x: P.x + (f.translateX || 0) + x - (l || 0), y: P.y + (f.translateY || 0) + x - u, width: C.width - 2 * x, height: (C.height || 0) - 2 * x } }, w, L, G, _, N, F = !1; for (let C = 0; C < y; C++)(w = W[C]) && (w.oldOpacity = w.opacity, w.newOpacity = 1, w.absoluteBox = k(w)); W.sort((C, x) => (x.labelrank || 0) - (C.labelrank || 0)); for (let C = 0; C < y; ++C) { _ = (L = W[C]) && L.absoluteBox; for (let x = C + 1; x < y; ++x)N = (G = W[x]) && G.absoluteBox, _ && N && L !== G && L.newOpacity !== 0 && G.newOpacity !== 0 && L.visibility !== "hidden" && G.visibility !== "hidden" && v(_, N) && ((L.labelrank < G.labelrank ? L : G).newOpacity = 0) } for (let C of W) E(C, this) && (F = !0); F && D(this, "afterHideAllOverlappingLabels") } function E(W, y) { let a, v = !1; return W && (a = W.newOpacity, W.oldOpacity !== a && (W.hasClass("highcharts-data-label") ? (W[a ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), v = !0, W[W.isOld ? "animate" : "attr"]({ opacity: a }, void 0, function () { y.styledMode || W.css({ pointerEvents: a ? "auto" : "none" }) }), D(y, "afterHideOverlappingLabel")) : W.attr({ opacity: a })), W.isOld = !0), v } function I() { var a; let W = this, y = []; for (let v of W.labelCollectors || []) y = y.concat(v()); for (let v of W.yAxis || []) v.stacking && v.options.stackLabels && !v.options.stackLabels.allowOverlap && se(v.stacking.stacks, k => { se(k, w => { w.label && y.push(w.label) }) }); for (let v of W.series || []) if (v.visible && ((a = v.hasDataLabels) != null && a.call(v))) { let k = w => { for (let L of w) L.visible && (L.dataLabels || []).forEach(G => { var N; let _ = G.options || {}; G.labelrank = $(_.labelrank, L.labelrank, (N = L.shapeArgs) == null ? void 0 : N.height), _.allowOverlap ?? Number(_.distance) > 0 ? (G.oldOpacity = G.opacity, G.newOpacity = 1, E(G, W)) : y.push(G) }) }; k(v.nodes || []), k(v.points) } this.hideOverlappingLabels(y) } return { compose: function W(y) { if (R(g, W)) { let a = y.prototype; a.hideOverlappingLabels = Q, j(y, "render", I) } } } }), n(i, "Extensions/BorderRadius.js", [i["Core/Defaults.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s, g) { let { defaultOptions: j } = r, { composed: D, noop: J } = s, { addEvent: se, extend: $, isObject: R, merge: Q, pushUnique: E, relativeLength: I } = g, W = { radius: 0, scope: "stack", where: void 0 }, y = J, a = J; function v(_, N, F, C, x = {}) { let P = y(_, N, F, C, x), { innerR: f = 0, r: o = F, start: u = 0, end: l = 0 } = x; if (x.open || !x.borderRadius) return P; let h = l - u, d = Math.sin(h / 2), m = Math.max(Math.min(I(x.borderRadius || 0, o - f), (o - f) / 2, o * d / (1 + d)), 0), p = Math.min(m, 2 * (h / Math.PI) * f), T = P.length - 1; for (; T--;)(function (U, ee, Z) { let H, Y, S, A = U[ee], B = U[ee + 1]; if (B[0] === "Z" && (B = U[0]), (A[0] === "M" || A[0] === "L") && B[0] === "A" ? (H = A, Y = B, S = !0) : A[0] === "A" && (B[0] === "M" || B[0] === "L") && (H = B, Y = A), H && Y && Y.params) { let K = Y[1], c = Y[5], M = Y.params, { start: b, end: z, cx: O, cy: q } = M, ie = c ? K - Z : K + Z, re = ie ? Math.asin(Z / ie) : 0, oe = c ? re : -re, he = Math.cos(re) * ie; S ? (M.start = b + oe, H[1] = O + he * Math.cos(b), H[2] = q + he * Math.sin(b), U.splice(ee + 1, 0, ["A", Z, Z, 0, 0, 1, O + K * Math.cos(M.start), q + K * Math.sin(M.start)])) : (M.end = z - oe, Y[6] = O + K * Math.cos(M.end), Y[7] = q + K * Math.sin(M.end), U.splice(ee + 1, 0, ["A", Z, Z, 0, 0, 1, O + he * Math.cos(z), q + he * Math.sin(z)])), Y[4] = Math.abs(M.end - M.start) < Math.PI ? 0 : 1 } })(P, T, T > 1 ? p : m); return P } function k() { var _, N; if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) { let { options: F, yAxis: C } = this, x = F.stacking === "percent", P = (N = (_ = j.plotOptions) == null ? void 0 : _[this.type]) == null ? void 0 : N.borderRadius, f = w(F.borderRadius, R(P) ? P : {}), o = C.options.reversed; for (let u of this.points) { let { shapeArgs: l } = u; if (u.shapeType === "roundedRect" && l) { let { width: h = 0, height: d = 0, y: m = 0 } = l, p = m, T = d; if (f.scope === "stack" && u.stackTotal) { let H = C.translate(x ? 100 : u.stackTotal, !1, !0, !1, !0), Y = C.translate(F.threshold || 0, !1, !0, !1, !0), S = this.crispCol(0, Math.min(H, Y), 0, Math.abs(H - Y)); p = S.y, T = S.height } let U = (u.negative ? -1 : 1) * (o ? -1 : 1) == -1, ee = f.where; !ee && this.is("waterfall") && Math.abs((u.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (ee = "all"), ee || (ee = "end"); let Z = Math.min(I(f.radius, h), h / 2, ee === "all" ? d / 2 : 1 / 0) || 0; ee === "end" && (U && (p -= Z), T += Z), $(l, { brBoxHeight: T, brBoxY: p, r: Z }) } } } } function w(_, N) { return R(_) || (_ = { radius: _ || 0 }), Q(W, N, _) } function L() { let _ = w(this.options.borderRadius); for (let N of this.points) { let F = N.shapeArgs; F && (F.borderRadius = I(_.radius, (F.r || 0) - (F.innerR || 0))) } } function G(_, N, F, C, x = {}) { let P = a(_, N, F, C, x), { r: f = 0, brBoxHeight: o = C, brBoxY: u = N } = x, l = N - u, h = u + o - (N + C), d = l - f > -.1 ? 0 : f, m = h - f > -.1 ? 0 : f, p = Math.max(d && l, 0), T = Math.max(m && h, 0), U = [_ + d, N], ee = [_ + F - d, N], Z = [_ + F, N + d], H = [_ + F, N + C - m], Y = [_ + F - m, N + C], S = [_ + m, N + C], A = [_, N + C - m], B = [_, N + d], K = (c, M) => Math.sqrt(Math.pow(c, 2) - Math.pow(M, 2)); if (p) { let c = K(d, d - p); U[0] -= c, ee[0] += c, Z[1] = B[1] = N + d - p } if (C < d - p) { let c = K(d, d - p - C); Z[0] = H[0] = _ + F - d + c, Y[0] = Math.min(Z[0], Y[0]), S[0] = Math.max(H[0], S[0]), A[0] = B[0] = _ + d - c, Z[1] = B[1] = N + C } if (T) { let c = K(m, m - T); Y[0] += c, S[0] -= c, H[1] = A[1] = N + C - m + T } if (C < m - T) { let c = K(m, m - T - C); Z[0] = H[0] = _ + F - m + c, ee[0] = Math.min(Z[0], ee[0]), U[0] = Math.max(H[0], U[0]), A[0] = B[0] = _ + m - c, H[1] = A[1] = N } return P.length = 0, P.push(["M", ...U], ["L", ...ee], ["A", d, d, 0, 0, 1, ...Z], ["L", ...H], ["A", m, m, 0, 0, 1, ...Y], ["L", ...S], ["A", m, m, 0, 0, 1, ...A], ["L", ...B], ["A", d, d, 0, 0, 1, ...U], ["Z"]), P } return { compose: function _(N, F, C, x) { if (E(D, _)) { let P = x.prototype.symbols; se(N, "afterColumnTranslate", k, { order: 9 }), se(F, "afterTranslate", L), C.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), y = P.arc, a = P.roundedRect, P.arc = v, P.roundedRect = G } }, optionsToObject: w } }), n(i, "Core/Responsive.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function (r, s) { var g; let { composed: j } = r, { diffObjects: D, extend: J, find: se, merge: $, pick: R, pushUnique: Q, uniqueKey: E } = s; return function (I) { function W(a, v) { let k = a.condition; (k.callback || function () { return this.chartWidth <= R(k.maxWidth, Number.MAX_VALUE) && this.chartHeight <= R(k.maxHeight, Number.MAX_VALUE) && this.chartWidth >= R(k.minWidth, 0) && this.chartHeight >= R(k.minHeight, 0) }).call(this) && v.push(a._id) } function y(a, v) { let k = this.options.responsive, w = this.currentResponsive, L = [], G; !v && k && k.rules && k.rules.forEach(F => { F._id === void 0 && (F._id = E()), this.matchResponsiveRule(F, L) }, this); let _ = $(...L.map(F => se((k || {}).rules || [], C => C._id === F)).map(F => F && F.chartOptions)); _.isResponsiveOptions = !0, L = L.toString() || void 0; let N = w && w.ruleIds; L !== N && (w && this.update(w.undoOptions, a, !0), L ? ((G = D(_, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = { ruleIds: L, mergedOptions: _, undoOptions: G }, this.update(_, a, !0)) : this.currentResponsive = void 0) } I.compose = function a(v) { return Q(j, a) && J(v.prototype, { matchResponsiveRule: W, setResponsive: y }), v } }(g || (g = {})), g }), n(i, "masters/highcharts.src.js", [i["Core/Globals.js"], i["Core/Utilities.js"], i["Core/Defaults.js"], i["Core/Animation/Fx.js"], i["Core/Animation/AnimationUtilities.js"], i["Core/Renderer/HTML/AST.js"], i["Core/Templating.js"], i["Core/Renderer/RendererUtilities.js"], i["Core/Renderer/SVG/SVGElement.js"], i["Core/Renderer/SVG/SVGRenderer.js"], i["Core/Renderer/HTML/HTMLElement.js"], i["Core/Renderer/HTML/HTMLRenderer.js"], i["Core/Axis/Axis.js"], i["Core/Axis/DateTimeAxis.js"], i["Core/Axis/LogarithmicAxis.js"], i["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], i["Core/Axis/Tick.js"], i["Core/Tooltip.js"], i["Core/Series/Point.js"], i["Core/Pointer.js"], i["Core/Legend/Legend.js"], i["Core/Chart/Chart.js"], i["Extensions/ScrollablePlotArea.js"], i["Core/Axis/Stacking/StackingAxis.js"], i["Core/Axis/Stacking/StackItem.js"], i["Core/Series/Series.js"], i["Core/Series/SeriesRegistry.js"], i["Series/Column/ColumnSeries.js"], i["Series/Column/ColumnDataLabel.js"], i["Series/Pie/PieSeries.js"], i["Series/Pie/PieDataLabel.js"], i["Core/Series/DataLabel.js"], i["Extensions/OverlappingDataLabels.js"], i["Extensions/BorderRadius.js"], i["Core/Responsive.js"], i["Core/Color/Color.js"], i["Core/Time.js"]], function (r, s, g, j, D, J, se, $, R, Q, E, I, W, y, a, v, k, w, L, G, _, N, F, C, x, P, f, o, u, l, h, d, m, p, T, U, ee) { return r.animate = D.animate, r.animObject = D.animObject, r.getDeferredAnimation = D.getDeferredAnimation, r.setAnimation = D.setAnimation, r.stop = D.stop, r.timers = j.timers, r.AST = J, r.Axis = W, r.Chart = N, r.chart = N.chart, r.Fx = j, r.Legend = _, r.PlotLineOrBand = v, r.Point = L, r.Pointer = G, r.Series = P, r.StackItem = x, r.SVGElement = R, r.SVGRenderer = Q, r.Templating = se, r.Tick = k, r.Time = ee, r.Tooltip = w, r.Color = U, r.color = U.parse, I.compose(Q), E.compose(R), G.compose(N), _.compose(N), r.defaultOptions = g.defaultOptions, r.getOptions = g.getOptions, r.time = g.defaultTime, r.setOptions = g.setOptions, r.dateFormat = se.dateFormat, r.format = se.format, r.numberFormat = se.numberFormat, s.extend(r, s), r.distribute = $.distribute, r.seriesType = f.seriesType, u.compose(o), p.compose(P, l, R, Q), d.compose(P), y.compose(W), a.compose(W), m.compose(N), h.compose(l), v.compose(W), T.compose(N), F.compose(W, N, P), C.compose(W, N, P), w.compose(G), r }), i["masters/highcharts.src.js"]._modules = i, i["masters/highcharts.src.js"]
    })
})(dc); var af = dc.exports; const Va = _o(af); var pc = { exports: {} }; (function (e, t) {
    (function (i, n) { e.exports = n(We) })(typeof self < "u" ? self : Ka, function (i) {
        return function (n) { function r(g) { if (s[g]) return s[g].exports; var j = s[g] = { i: g, l: !1, exports: {} }; return n[g].call(j.exports, j, j.exports, r), j.l = !0, j.exports } var s = {}; return r.m = n, r.c = s, r.d = function (g, j, D) { r.o(g, j) || Object.defineProperty(g, j, { configurable: !1, enumerable: !0, get: D }) }, r.n = function (g) { var j = g && g.__esModule ? function () { return g.default } : function () { return g }; return r.d(j, "a", j), j }, r.o = function (g, j) { return Object.prototype.hasOwnProperty.call(g, j) }, r.p = "", r(r.s = 0) }([function (n, r, s) {
            function g() { return g = Object.assign ? Object.assign.bind() : function (a) { for (var v = 1; v < arguments.length; v++) { var k = arguments[v]; for (var w in k) Object.prototype.hasOwnProperty.call(k, w) && (a[w] = k[w]) } return a }, g.apply(this, arguments) } function j(a) { return $(a) || se(a) || J(a) || D() } function D() {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            } function J(a, v) { if (a) { if (typeof a == "string") return R(a, v); var k = Object.prototype.toString.call(a).slice(8, -1); return k === "Object" && a.constructor && (k = a.constructor.name), k === "Map" || k === "Set" ? Array.from(a) : k === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(k) ? R(a, v) : void 0 } } function se(a) { if (typeof Symbol < "u" && a[Symbol.iterator] != null || a["@@iterator"] != null) return Array.from(a) } function $(a) { if (Array.isArray(a)) return R(a) } function R(a, v) { (v == null || v > a.length) && (v = a.length); for (var k = 0, w = new Array(v); k < v; k++)w[k] = a[k]; return w } function Q(a) { "@babel/helpers - typeof"; return (Q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (v) { return typeof v } : function (v) { return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v })(a) } Object.defineProperty(r, "__esModule", { value: !0 }), s.d(r, "HighchartsReact", function () { return y }); var E = s(1), I = s.n(E), W = typeof window < "u" ? E.useLayoutEffect : E.useEffect, y = Object(E.memo)(Object(E.forwardRef)(function (a, v) { var k = Object(E.useRef)(), w = Object(E.useRef)(), L = Object(E.useRef)(a.constructorType), G = Object(E.useRef)(a.highcharts); return W(function () { function _() { var F = a.highcharts || (typeof window > "u" ? "undefined" : Q(window)) === "object" && window.Highcharts, C = a.constructorType || "chart"; F ? F[C] ? a.options ? w.current = F[C](k.current, a.options, a.callback) : console.warn('The "options" property was not passed.') : console.warn('The "constructorType" property is incorrect or some required module is not imported.') : console.warn('The "highcharts" property was not passed.') } if (w.current) { if (a.allowChartUpdate !== !1) if (a.constructorType !== L.current || a.highcharts !== G.current) L.current = a.constructorType, G.current = a.highcharts, _(); else if (!a.immutable && w.current) { var N; (N = w.current).update.apply(N, [a.options].concat(j(a.updateArgs || [!0, !0]))) } else _() } else _() }, [a.options, a.allowChartUpdate, a.updateArgs, a.containerProps, a.highcharts, a.constructorType]), W(function () { return function () { w.current && (w.current.destroy(), w.current = null) } }, []), Object(E.useImperativeHandle)(v, function () { return { get chart() { return w.current }, container: k } }, []), I.a.createElement("div", g({}, a.containerProps, { ref: k })) })); r.default = y
        }, function (n, r) { n.exports = i }])
    })
})(pc); var hf = pc.exports; const $a = _o(hf); function uf() { const e = [], t = Date.now(); for (let i = 0; i < 30; i++) { const n = t - i * 60 * 1e3; for (let r = 0; r < 8; r++) { const s = Math.random() * 30; e.push({ id: r + 1, time: n, value: s }) } } return e } function cf() { const e = [], t = Date.now(); for (let i = 0; i < 30; i++) { const n = t - i * 60 * 1e3; for (let r = 0; r < 8; r++) { const s = Math.random() * 40 + 10; e.push({ id: r + 1, time: n, value: s }) } } return e } const fc = { legend: { layout: "vertical", align: "right", verticalAlign: "middle" }, chart: { backgroundColor: "transparent" }, plotOptions: { series: { label: { connectorAllowed: !1 }, pointStart: Date.now() - 6e4 } }, xAxis: { accessibility: { rangeDescription: "Timestamps" }, type: "datetime", labels: { overflow: "justify", formatter() { const e = new Date(Number(this.value)); return `${String(e.getHours()).padStart(2, "0")}:${String(e.getMinutes()).padStart(2, "0")}` } } }, credits: { enabled: !1 }, responsive: { rules: [{ condition: { maxWidth: 500 }, chartOptions: { legend: { layout: "horizontal", align: "center", verticalAlign: "bottom" } } }] } }, df = { ...fc, title: { text: "Flow Rate by Sensor", align: "left" }, yAxis: { title: { text: "Flow Rate" }, labels: { formatter() { return `${this.value} L/min` } } } }, pf = { ...fc, title: { text: "Pressure by Sensor", align: "left" }, yAxis: { title: { text: "Pressure" }, labels: { formatter() { return `${this.value} kPa` } } } }, ff = () => { const [e, t] = We.useState([]), [i, n] = We.useState([]); return We.useEffect(() => { const r = uf(), s = Array(8).fill(0).map((g, j) => ({ name: `Sensor ${j + 1}`, data: r.filter(D => D.id === j + 1).map(D => [D.time, D.value]) })); t(s) }, []), We.useEffect(() => { const r = cf(), s = Array(8).fill(0).map((g, j) => ({ name: `Sensor ${j + 1}`, data: r.filter(D => D.id === j + 1).map(D => [D.time, D.value]) })); n(s) }, []), ve.jsxs(We.Fragment, { children: [ve.jsx("h3", { className: "page-title", children: "Graph views" }), ve.jsxs("div", { className: "flex flex-col gap-4 md:gap-8", children: [ve.jsx(is, { children: ve.jsx($a, { highcharts: Va, options: { ...df, series: e } }) }), ve.jsx(is, { children: ve.jsx($a, { highcharts: Va, options: { ...pf, series: i } }) })] })] }) }, gf = [{ id: 1, sensor_id: 1, mail_code: 1, flowrate: .5, consumption: .5, timestamp: "2021-10-11 12:00:00" }, { id: 2, sensor_id: 1, mail_code: 1, flowrate: .5, consumption: .5, timestamp: "2021-10-11 12:00:00" }], mf = [{ id: 1, sensor_id: 1, mail_code: 1, pressure: .5, timestamp: "2021-10-11 12:00:00" }, { id: 2, sensor_id: 1, mail_code: 1, pressure: .5, timestamp: "2021-10-11 12:00:00" }], yf = () => ve.jsxs("div", { className: "content-container", children: [ve.jsxs("div", { children: [ve.jsx("h3", { className: "page-title", children: "Flow Data" }), ve.jsx("div", { className: "table-container", children: ve.jsxs("table", { children: [ve.jsx("thead", { children: ve.jsxs("tr", { children: [ve.jsx("th", { children: "ID" }), ve.jsx("th", { children: "Sensor ID" }), ve.jsx("th", { children: "Mal Code" }), ve.jsx("th", { children: "Flowrate" }), ve.jsx("th", { children: "Consumption" }), ve.jsx("th", { children: "Timestamp" })] }) }), ve.jsx("tbody", { children: gf.map(e => ve.jsxs("tr", { children: [ve.jsx("td", { children: e.id }), ve.jsx("td", { children: e.sensor_id }), ve.jsx("td", { children: e.mail_code }), ve.jsx("td", { children: e.flowrate }), ve.jsx("td", { children: e.consumption }), ve.jsx("td", { children: e.timestamp })] }, e.id)) })] }) })] }), ve.jsxs("div", { children: [ve.jsx("h3", { className: "page-title", children: "Pressure Data" }), ve.jsx("div", { className: "table-container", children: ve.jsxs("table", { children: [ve.jsx("thead", { children: ve.jsxs("tr", { children: [ve.jsx("th", { children: "ID" }), ve.jsx("th", { children: "Sensor ID" }), ve.jsx("th", { children: "Mal Code" }), ve.jsx("th", { children: "Pressure" }), ve.jsx("th", { children: "Timestamp" })] }) }), ve.jsx("tbody", { children: mf.map(e => ve.jsxs("tr", { children: [ve.jsx("td", { children: e.id }), ve.jsx("td", { children: e.sensor_id }), ve.jsx("td", { children: e.mail_code }), ve.jsx("td", { children: e.pressure }), ve.jsx("td", { children: e.timestamp })] }, e.id)) })] }) })] })] }), xf = () => ve.jsx("div", { children: ve.jsx("h1", { children: "Settings" }) }), Wo = [{ id: "home", name: "Home", icon: $p, activeIcon: Kp, active: !0, component: ve.jsx(lf, {}) }, { id: "graph", name: "Graph", icon: Qp, activeIcon: Zp, active: !1, component: ve.jsx(ff, {}) }, { id: "table", name: "Table", icon: qp, activeIcon: Jp, active: !1, component: ve.jsx(yf, {}) }, { id: "settings", name: "Settings", icon: ef, activeIcon: tf, active: !1, component: ve.jsx(xf, {}) }], vf = ({ view: e, setView: t }) => { const [i, n] = We.useState(Wo), [r, s] = We.useState(!1); return We.useEffect(() => { const g = () => { const j = window.pageYOffset; s(j > 0) }; return window.addEventListener("scroll", g, { passive: !0 }), () => { window.removeEventListener("scroll", g) } }, []), We.useEffect(() => { n(i.map(g => (g.active = g.id === e, g))) }, [e]), ve.jsx("header", { className: "z-[100] mt-8 fixed w-full h-10 flex items-center justify-center box-border", children: ve.jsx("div", { className: Fo("flex gap-3 inline-block px-6 py-3 shadow-header rounded-full transition-all duration-200", r ? "bg-black text-white" : "bg-foreground"), children: i.map(g => ve.jsxs("button", { className: Fo("inline-block [&>svg]:hover:scale-105 [&>svg]:transition-all [&>svg]:duration-200", g.active && r ? "text-white" : r ? "text-zinc-500 hover:text-white" : "text-content-2 hover:text-content-1"), "aria-current": g.active ? "page" : void 0, onClick: () => t(g.id), children: [ve.jsx("span", { className: "sr-only", children: g.name }), g.active ? ve.jsx(g.activeIcon, { className: "w-7 h-7" }) : ve.jsx(g.icon, { className: "w-7 h-7" })] }, g.id)) }) }) }; function Sf() { const [e, t] = We.useState(Wo[0].id), i = We.useCallback(() => { var n; return (n = Wo.find(r => r.id === e)) == null ? void 0 : n.component }, [e]); return ve.jsxs("div", { className: "absolute w-full h-full", children: [ve.jsx(vf, { view: e, setView: t }), ve.jsx("div", { className: "p-8 mt-16 mb-8 flex flex-col items-stretch justify-stretch max-w-7xl mx-auto", children: i() })] }) } const kf = hc(document.getElementById("root")); kf.render(ve.jsx(We.StrictMode, { children: ve.jsx(Sf, {}) }));
